<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="Dream high">
<meta property="og:type" content="website">
<meta property="og:title" content="ZhangWei2222">
<meta property="og:url" content="http://super-wei.xyz/index.html">
<meta property="og:site_name" content="ZhangWei2222">
<meta property="og:description" content="Dream high">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhangWei2222">
<meta name="twitter:description" content="Dream high">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://super-wei.xyz/"/>





  <title>ZhangWei2222</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhangWei2222</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2018/03/23/跨域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/跨域/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T11:14:20+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: 跨域<br>date: 2018-03-23 11:14:20<br>tags:</p>
<ul>
<li>小题<br>-</li>
</ul>
<h1 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h1><p>由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一个与当前页面地址不同即为跨域。存在跨域的情况：</p>
<blockquote>
<p>何谓同源:</p>
<p> URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。</p>
<p>同源策略:</p>
<p>浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。</p>
<p>从一个域上加载的脚本不允许访问另外一个域的文档属性。</p>
</blockquote>
<ul>
<li>网络协议不同，如http协议访问https协议。</li>
</ul>
<ul>
<li>端口不同，如80端口访问8080端口。</li>
</ul>
<ul>
<li>域名不同，如qianduanblog.com访问baidu.com。</li>
</ul>
<ul>
<li>子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。</li>
</ul>
<ul>
<li>域名和域名对应ip,如www.a.com访问20.205.28.90.</li>
</ul>
<h1 id="跨域请求资源的方法？"><a href="#跨域请求资源的方法？" class="headerlink" title="跨域请求资源的方法？"></a>跨域请求资源的方法？</h1><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>这种方式主要是通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。</p>
<pre><code>js代码
&lt;script&gt;  
   var _script = document.createElement(&apos;script&apos;);  
   _script.type = &quot;text/javascript&quot;;  
   _script.src = &quot;http://localhost:8888/jsonp?callback=f&quot;;  
   document.head.appendChild(_script);  
 &lt;/script&gt;  
</code></pre><p>实际项目中JSONP通常用来获取json格式数据，这时前后端通常约定一个参数callback，该参数的值，就是处理返回数据的函数名称。</p>
<pre><code>html代码
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt;
    &lt;title&gt;jsonp_test&lt;/title&gt;

    &lt;script&gt;
      var f = function(data){
        alert(data.name);
      }
      /*var xhr = new XMLHttpRequest();
      xhr.onload = function(){
        alert(xhr.responseText);
      };
      xhr.open(&apos;POST&apos;, &apos;http://localhost:8888/cors&apos;, true);
      xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
      xhr.send(&quot;f=json&quot;);*/
    &lt;/script&gt;

    &lt;script&gt;
      var _script = document.createElement(&apos;script&apos;);
      _script.type = &quot;text/javascript&quot;;
      _script.src = &quot;http://localhost:8888/jsonp?callback=f&quot;;
      document.head.appendChild(_script);
    &lt;/script&gt;
  &lt;/head&gt;
</code></pre><p>后端</p>
<pre><code>java代码
var query = _url.query;
        console.log(query);
        var params = qs.parse(query);
        console.log(params);
        var f = &quot;&quot;;

        f = params.callback;

        res.writeHead(200, {&quot;Content-Type&quot;: &quot;text/javascript&quot;});
        res.write(f + &quot;({name:&apos;hello world&apos;})&quot;);
        res.end();
</code></pre><p>缺点：</p>
<ol>
<li>这种方式无法发送post请求（这里）</li>
</ol>
<ol>
<li>另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。</li>
</ol>
<h3 id="2-proxy代理"><a href="#2-proxy代理" class="headerlink" title="2.proxy代理"></a>2.proxy代理</h3><p>这种方式首先将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。</p>
<pre><code>html代码
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt;
    &lt;title&gt;proxy_test&lt;/title&gt;

    &lt;script&gt;
      var f = function(data){
        alert(data.name);
      }
      var xhr = new XMLHttpRequest();
      xhr.onload = function(){
        alert(xhr.responseText);
      };
      xhr.open(&apos;POST&apos;, &apos;http://localhost:8888/proxy?http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer&apos;, true);
      xhr.send(&quot;f=json&quot;);
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>后端</p>
<pre><code>java代码
var proxyUrl = &quot;&quot;;
      if (req.url.indexOf(&apos;?&apos;) &gt; -1) {
          proxyUrl = req.url.substr(req.url.indexOf(&apos;?&apos;) + 1);
          console.log(proxyUrl);
      }
      if (req.method === &apos;GET&apos;) {
          request.get(proxyUrl).pipe(res);
      } else if (req.method === &apos;POST&apos;) {
          var post = &apos;&apos;;     //定义了一个post变量，用于暂存请求体的信息

        req.on(&apos;data&apos;, function(chunk){    //通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
            post += chunk;
        });

        req.on(&apos;end&apos;, function(){    //在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
            post = qs.parse(post);
            request({
                      method: &apos;POST&apos;,
                      url: proxyUrl,
                      form: post
                  }).pipe(res);
        });
      }
</code></pre><p>需要注意的是如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。12306就提供了一个鲜活的例子。</p>
<p>还需要注意一点，对于同一请求浏览器通常会从缓存中读取数据，我们有时候不想从缓存中读取，所以会加一个preventCache参数，这个时 候请求url变成：url?preventCache=12345567….;这本身没有什么问题，问题出在当使用某些前端框架（比如jquery） 发送proxy代理请求时，请求url为proxy?url，同时设置preventCache：true，框架不能正确处理这个参数，结果发出去的请求 变成proxy?url&amp;preventCache=123456（正长应为proxy?url?preventCache=12356）;后端 截取后发送的请求为url&amp;preventCache=123456，根本没有这个地址，所以你得不到正确结果</p>
<h3 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h3><p>这是现代浏览器支持跨域资源请求的一种方式。</p>
<p>当你使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处 理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin;浏览器判断该相应头中是否包含 Origin的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据</p>
<pre><code>html代码
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt;
    &lt;title&gt;jsonp_test&lt;/title&gt;

    &lt;script&gt;
      /*var f = function(data){
        alert(data.name);
      }*/
      var xhr = new XMLHttpRequest();
      xhr.onload = function(){
        alert(xhr.responseText);
      };
      xhr.open(&apos;POST&apos;, &apos;http://localhost:8888/cors&apos;, true);
      xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
      xhr.send(&quot;f=json&quot;);
    &lt;/script&gt;

    &lt;script&gt;
     /* var _script = document.createElement(&apos;script&apos;);
      _script.type = &quot;text/javascript&quot;;
      _script.src = &quot;http://localhost:8888/jsonp?callback=f&quot;;
      document.head.appendChild(_script);*/
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;

后端
if (req.headers.origin) {

            res.writeHead(200, {
                &quot;Content-Type&quot;: &quot;text/html; charset=UTF-8&quot;,
                &quot;Access-Control-Allow-Origin&quot;:&apos;http://localhost&apos;/*,
                &apos;Access-Control-Allow-Methods&apos;: &apos;GET, POST, OPTIONS&apos;,
                &apos;Access-Control-Allow-Headers&apos;: &apos;X-Requested-With, Content-Type&apos;*/
            });
            res.write(&apos;cors&apos;);
            res.end();
        }
</code></pre><p>以上是简单请求，还有一种非简单请求</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li><p>HEAD</p>
</li>
<li><p>GET</p>
</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<p>详情见<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">阮一峰的文章</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2018/03/23/四种方式实现JS异步编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/四种方式实现JS异步编程/" itemprop="url">四种方式实现JS异步编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T11:10:37+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>使用回调、Promise、generator和asnyc/await四种方式，请求api/data中的数据</p>
<p>为方便理解，首先封装了一个库去实现ajax的get方法，调用方式如下</p>
<pre><code>http.get(&apos;api/data&apos;, callback)
</code></pre><p>但是如果以同步的方式来写，如</p>
<pre><code>function getData (url) {
  return http.get(url)
}
const data = getData(&apos;api/data&apos;);
console.log(data) // undefined
</code></pre><p>结果报错了，这是因为http.get(url)本身是个异步（非阻塞）的过程，这行代码运行的时候并没有马上得到结果，它的结果出现时间与服务器有关，是无法预知的。js会把它放到异步线程然后继续运行下去，下一行打印它自然是undefined。</p>
<p>所以才有了接下来的讨论，采用异步的方式去获取它的结果。</p>
<h1 id="回调（callback）"><a href="#回调（callback）" class="headerlink" title="回调（callback）"></a>回调（callback）</h1><pre><code>function getData (url, callback) {
  http.getData(url, data =&gt; {
    if (data.status == 200) {
      // let err = null
      // callback(err, data);

      callback(null, data);

    } else {
      // let err = data
      // callback(err, data);

      callback(data);

    }
  });
}

getData(&apos;api/data&apos;, (err, data) =&gt; {
  if (err) {
    console.log(err)
  } else {
    console.log(data)
  }
})
</code></pre><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise对象代表一个未完成、但预计将来会完成的操作，有三种状态：</p>
<p>pending：初始值，不是fulfilled，也不是rejected<br>resolved(也叫fulfilled）：代表操作成功<br>rejected：代表操作失败</p>
<p>整个promise的状态只支持两种转换：从pending转变为resolved，或从pending转变为rejected，一旦转化发生就会保持这种状态，不可以再发生变化，状态发生变化后会触发then方法。</p>
<pre><code>function getData (url) {
  return new Promise((resolve, reject) =&gt; {
    http.get(url, data =&gt; {
      if (data.status == 200) {
        resolve(data);
      } else {
        reject(data);
      }
    });
  })
}

getData(&apos;api/data&apos;).then(data =&gt; {
  console.log(data);
}).catch(err =&gt; {
  console.log(err);
})
</code></pre><p>拓展：<br>Promise还有一个Promise.all()方法，当我们需要请求多个接口的数据时，可以这么用</p>
<pre><code>function getData (url, callback) {
  http.get(url, data =&gt; {
    if (data.status == 200) {
      callback(null, data);
    } else {
      callback(data);
    }
  });
}

const ansycTask = {
  getData(&apos;data/api1&apos;, (err, data) =&gt; {
    if (err) {
      console.log(err)
    } else {
      console.log(data)
      return data
    }
  },
  getData(&apos;data/api2&apos;, (err, data) =&gt; {
    if (err) {
      console.log(err)
    } else {
      console.log(data)
      return data
    }
  },
  getData(&apos;data/api3&apos;, (err, data) =&gt; {
    if (err) {
      console.log(err)
    } else {
      console.log(data)
      return data
    }
  }
}

Promise.all(asyncTask).then(data =&gt; {
  console.log(data)
})
</code></pre><p>全部请求得到返回后，会返回一个由3个data组成的数组，并且是按请求顺序排列的。</p>
<h1 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h1><p>相当于Promise的升级，可以手动控制Promise的进行</p>
<pre><code>function getData (url) {
  return new Promise((resolve, reject) =&gt; {
    http.get(url, data =&gt; {
      if (data.status == 200) {
        resolve(data);
      } else {
        reject(data);
      }
    });
  })
}

function *getDataGen (url) {
  yield getData(url);
  yield () =&gt; {
    console.log(&apos;end&apos;)
  }
}

const task = getDataGen(&apos;api/data&apos;);
task.next(); // 打印data
task next(); // 打印&apos;end&apos;
</code></pre><p>generator里面可以使用yield关键字来表示暂停，它接收一个promise对象，返回promise的结果并且停在此处等待，不是一次性执行完。</p>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><p>async/await是ES7新特性，必须配合使用，在function前加上async，然后在需要等待结果的代码前面加上await，函数将在await的那个东西取得结果后再赋值，可以和Promise配合使用。</p>
<pre><code>function getDataPromise (url) {
  return new Promise((resolve, reject) =&gt; {
    http.get(url, data =&gt; {
      if (data.status == 200) {
        resolve(data);
      } else {
        reject(data);
      }
    });
  })
}

async function getData(url) {
  await getDataPromise(url);
}

const data = await getData(&apos;data/api&apos;);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2018/03/19/wow-js-animate-css/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/wow-js-animate-css/" itemprop="url">wow.js & animate.css</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T16:08:43+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何实现随着滚动条滚动加载动画呢"><a href="#如何实现随着滚动条滚动加载动画呢" class="headerlink" title="如何实现随着滚动条滚动加载动画呢"></a>如何实现随着滚动条滚动加载动画呢</h1><p>使用wow.js 和animate.css即可实现随滚动条加载酷炫动画</p>
<ul>
<li><p>引入js和css</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/animate.css&quot;&gt;

&lt;script src=&quot;js/wow.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
new WOW().init();
&lt;/script&gt;    
</code></pre></li>
<li><p>在类名加入 wow 和喜欢的动画效果名字</p>
<pre><code>&lt;div class=&quot;wow bounceInUp&quot;&gt;
Content to Reveal Here
&lt;/div&gt;
</code></pre></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2018/03/19/git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/git/" itemprop="url">git</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T16:05:00+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>克隆仓库到本地</li>
<li>git status</li>
<li>git add . </li>
<li>git commit -m ‘更新的内容写在这’</li>
<li>git pull origin master</li>
<li>git push origin master</li>
</ul>
<p>如果仓库更新，则在之前把仓库更新的内容拉过来</p>
<ul>
<li>git pull</li>
</ul>
<p>如果本地文件需要改动，则直接在仓库的文件中改动</p>
<ul>
<li>git status  //可以查看状态 红色表示修改了</li>
<li>git add . </li>
<li>git commit -m ‘更新的内容写在这’</li>
<li>git pull origin master //先从远端把代码先拉过来，在本地合并</li>
<li>git push origin master</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2018/03/19/移动端网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/移动端网站/" itemprop="url">移动端网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T15:57:22+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何适配移动端呢？"><a href="#如何适配移动端呢？" class="headerlink" title="如何适配移动端呢？"></a>如何适配移动端呢？</h1><p>可使用flexible框架</p>
<ul>
<li><p>在head标签引入文件</p>
<pre><code>&lt;script src=&quot;./common/flexible.debug.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./common/flexible_css.debug.js&quot;&gt;&lt;/script&gt;
</code></pre></li>
<li><p>注释</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; --&gt;
</code></pre></li>
</ul>
<p>然后html会在不同的设备下产生不同的font-size值，我们可以利用px2rem进行书写css，以达到自动适配的目的。对于gulp配置px2rem的方法，详情写gulp-px2rem</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2018/03/19/gulp-px2rem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/19/gulp-px2rem/" itemprop="url">gulp px2rem</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-19T15:52:08+08:00">
                2018-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何用px2rem处理css文件呢？"><a href="#如何用px2rem处理css文件呢？" class="headerlink" title="如何用px2rem处理css文件呢？"></a>如何用px2rem处理css文件呢？</h1><p>先把.styl文件编译成.css文件，接着处理</p>
<pre><code>//px2rem处理
gulp.task(&apos;px2rem&apos;,function() {
  return gulp.src(&apos;./src/css/index.css&apos;)
    .pipe(px2rem({
      baseDpr: 2,             // base device pixel ratio (default: 2)
      threeVersion: false,    // whether to generate @1x, @2x and @3x version (default: false)
      remVersion: true,       // whether to generate rem version (default: true)
      remUnit: 75,            // rem unit value (default: 75)
      remPrecision: 6         // rem precision (default: 6)
    }))
    .pipe(gulp.dest(&apos;./src/css&apos;))
});
</code></pre><p>在./src/css中就会生成index.debug.css文件</p>
<p>最终的结果是</p>
<pre><code>.selector {
    width: 150px;
    height: 64px; /*px*/
    font-size: 28px; /*px*/
    border: 1px solid #ddd; /*no*/
}

.selector {
    width: 2rem;
    border: 1px solid #ddd;
}
[data-dpr=&quot;1&quot;] .selector {
    height: 32px;
    font-size: 14px;
}
[data-dpr=&quot;2&quot;] .selector {
    height: 64px;
    font-size: 28px;
}
[data-dpr=&quot;3&quot;] .selector {
    height: 96px;
    font-size: 42px;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2018/03/15/gulp初接触/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/gulp初接触/" itemprop="url">gulp初接触</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T15:43:08+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="gulp安装"><a href="#gulp安装" class="headerlink" title="gulp安装"></a>gulp安装</h1><p>全局：<strong>npm install gulp -g</strong></p>
<p>开发环境：<strong>npm install gulp –save-dev</strong></p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><pre><code>-dist //打包目录
    -css
        -built.css
        -built.min.css
    -js
        -built.js
        -built.min.js
    -images
-src //开发目录
    -css
        -built.css
        -built.css.map
    -js
        -js1.js
        -js2.js
    -stylus
        -stylus1.styl
        -stylus2.styl
    -images
    -index.html //项目入口
-gulpfile.js //配置文件
-package-lock.json
-package.json //配置信息
</code></pre><p>首先在package.json文件中添加项目信息</p>
<pre><code>{
    &quot;name&quot;: &quot;gulp_test&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;
}
</code></pre><h1 id="引入模块和插件"><a href="#引入模块和插件" class="headerlink" title="引入模块和插件"></a>引入模块和插件</h1><h2 id="1-引入模块"><a href="#1-引入模块" class="headerlink" title="1.引入模块"></a>1.引入模块</h2><pre><code>// gulpfile.js
var gulp = require(&apos;gulp&apos;);
</code></pre><h2 id="2-插件"><a href="#2-插件" class="headerlink" title="2.插件"></a>2.插件</h2><h3 id="gulp中的几个比较常用的插件"><a href="#gulp中的几个比较常用的插件" class="headerlink" title="gulp中的几个比较常用的插件"></a>gulp中的几个比较常用的插件</h3><blockquote>
<p>gulp-concat : 合并文件(js/css)</p>
<p>gulp-rename : 文件重命名</p>
<p>gulp-htmlmin : 压缩html文件</p>
<p>gulp-imagemin : 压缩图片</p>
<p>gulp-uglify : 压缩js文件</p>
<p>gulp-livereload : 实时自动编译刷新</p>
<p>gulp-connect : 热加载</p>
<p>gulp-stylus : 编译stylus</p>
<p>gulp-clean-css : 压缩css</p>
<p>gulp-sourcemaps : 可在浏览器调试工具中查看到对应代码在stylus的位置</p>
<p>gulp-postcss : 扩展的语法和特性转换成现代的浏览器友好的CSS</p>
<p>autoprefixer : 自动添加css浏览器前缀</p>
<p>cssnano : 压缩，去空格，去注释，去覆盖等</p>
</blockquote>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><blockquote>
<p>gulp.src(filePath/pathArr)：指向指定路径的所有文件，返回文件流对象，用于读取文件</p>
<p>gulp.dest(dirPath/pathArr)：指向指定的所有文件夹，用于向文件夹中输出文件</p>
<p>gulp.task(name, [deps], fn)：定义一个任务</p>
<p>gulp.watch()：监听文件的变化</p>
</blockquote>
<h2 id="3-各部分打包代码"><a href="#3-各部分打包代码" class="headerlink" title="3.各部分打包代码"></a>3.各部分打包代码</h2><h3 id="stylus-css处理"><a href="#stylus-css处理" class="headerlink" title="stylus css处理"></a>stylus css处理</h3><pre><code>gulp.task(&apos;stylusTask&apos;, function () {
  var processor = [
    autoprefixer,
    cssnano
  ];
  return gulp.src(&apos;src/stylus/*.styl&apos;)
    .pipe(sourcemaps.init())
    .pipe(stylus())
    .pipe(postcss(processor))
    .pipe(concat(&apos;built.css&apos;))
    .pipe(sourcemaps.write(&apos;./&apos;))
    .pipe(gulp.dest(&apos;src/css&apos;))
    .pipe(livereload());
});
</code></pre><h3 id="打包asset"><a href="#打包asset" class="headerlink" title="打包asset"></a>打包asset</h3><pre><code>gulp.task(&apos;copyAsset&apos;, function () {
  return gulp.src([
    &apos;./src/asset/**/*&apos;
    // &apos;./src/asset/jquery/**/*&apos;
  ])
    .pipe(gulp.dest(&apos;./dist/asset&apos;))
})
</code></pre><h3 id="打包html"><a href="#打包html" class="headerlink" title="打包html"></a>打包html</h3><pre><code>gulp.task(&apos;copyHtml&apos;, function () {
  return gulp.src(&apos;./src/*.html&apos;)
    .pipe(htmlmin({
        collapseWhitespace:true,
        collapseBooleanAttributes:true,
        removeComments:true,
        removeEmptyAttributes:true,
        removeScriptTypeAttributes:true,
        removeStyleLinkTypeAttributes:true,
        minifyJS:true,
        minifyCSS:true    
    }))
    .pipe(gulp.dest(&apos;./dist&apos;))
})
</code></pre><h3 id="打包css"><a href="#打包css" class="headerlink" title="打包css"></a>打包css</h3><pre><code>gulp.task(&apos;cssTask&apos;, [&apos;stylusTask&apos;], function () {
  return gulp.src(&apos;./src/css/built.css&apos;)
    .pipe(gulp.dest(&apos;./dist/css&apos;))
    .pipe(rename({suffix:&apos;.min&apos;}))
    .pipe(cleanCSS({compatibility:&apos;ie8&apos;}))
    .pipe(gulp.dest(&apos;./dist/css&apos;))
})
</code></pre><h3 id="打包js"><a href="#打包js" class="headerlink" title="打包js"></a>打包js</h3><pre><code>gulp.task(&apos;jsTask&apos;, function () {
  return gulp.src(&apos;./src/js/*.js&apos;)
    .pipe(concat(&apos;built.js&apos;)) //合并到临时文件夹
    .pipe(gulp.dest(&apos;./dist/js&apos;)) //生成到目标文件夹
    .pipe(rename({suffix:&apos;.min&apos;})) //重命名
    .pipe(uglify()) //压缩
    .pipe(gulp.dest(&apos;./dist/js&apos;))
})
</code></pre><h3 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h3><pre><code>gulp.task(&apos;copyImages&apos;, function () {
  return gulp.src(&apos;./src/images/*&apos;)
    .pipe(imagemin({
      optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
      progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
      interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染
      multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化
    }))
    .pipe(gulp.dest(&apos;./dist/images&apos;))
})
</code></pre><h3 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h3><pre><code>gulp.task(&apos;reload&apos;, function () {
  return gulp.src(&apos;src/*.html&apos;)
    .pipe(connect.reload())
});
</code></pre><h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><pre><code>gulp.task(&apos;server&apos;, function () {
  connect.server({
    root: &apos;src&apos;,
    livereload: true,
    port: 5000
  })
});

gulp.task(&apos;auto&apos;, function() {
  gulp.watch(&apos;src/stylus/*.styl&apos;, [&apos;stylusTask&apos;]);
  gulp.watch(&apos;src/css/*.css&apos;, [&apos;reload&apos;])
  gulp.watch(&apos;src/*.html&apos;, [&apos;reload&apos;]);
  gulp.watch(&apos;src/js/*.js&apos;, [&apos;reload&apos;]);
});
</code></pre><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><pre><code>gulp.task(&apos;default&apos;, [&apos;server&apos;, &apos;auto&apos;]);

gulp.task(&apos;product&apos;, [&apos;cssTask&apos;, &apos;copyHtml&apos;, &apos;copyImages&apos;, &apos;jsTask&apos;, &apos;copyAsset&apos;, &apos;copyImages&apos;])
</code></pre><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre><code>// /*
// * gulp-concat : 合并文件(js/css)
// * gulp-rename : 文件重命名
// * gulp-htmlmin : 压缩html文件
// * gulp-imagemin : 压缩图片
// * gulp-uglify : 压缩js文件
// * gulp-livereload : 实时自动编译刷新
// * gulp-connect : 热加载

// * gulp-stylus : 编译stylus
// * gulp-clean-css : 压缩css
// * gulp-sourcemaps : 可在浏览器调试工具中查看到对应代码在stylus的位置
// * gulp-postcss : 扩展的语法和特性转换成现代的浏览器友好的CSS
// * autoprefixer : 自动添加css浏览器前缀
// * cssnano : 压缩，去空格，去注释，去覆盖等

// *
// * gulp.src(filePath/pathArr)：指向指定路径的所有文件, 返回文件流对象，用于读取文件
// * gulp.dest(dirPath/pathArr)：指向指定的所有文件夹，用于向文件夹中输出文件
// * gulp.task(name, [deps], fn)：定义一个任务
// * gulp.watch()：监视文件的变化
// */

var gulp = require(&apos;gulp&apos;);

// common plyugin
var concat = require(&apos;gulp-concat&apos;),
    rename = require(&apos;gulp-rename&apos;),
    htmlmin = require(&apos;gulp-htmlmin&apos;),
    imagemin = require(&apos;gulp-imagemin&apos;),
    uglify = require(&apos;gulp-uglify&apos;),
    livereload = require(&apos;gulp-livereload&apos;),
    connect = require(&apos;gulp-connect&apos;);

var stylus = require(&apos;gulp-stylus&apos;),
    sourcemaps = require(&apos;gulp-sourcemaps&apos;),
    postcss = require(&apos;gulp-postcss&apos;),
    autoprefixer = require(&apos;autoprefixer&apos;),
    cleanCSS = require(&apos;gulp-clean-css&apos;),
    cssnano = require(&apos;cssnano&apos;);

// var cheerio = require(&apos;gulp-cheerio&apos;);

// instruction
gulp.task(&apos;help&apos;,function () {
  console.log(&apos;    gulp                       自定义开发模式&apos;);
  console.log(&apos;    gulp build                文件打包&apos;);
  console.log(&apos;    gulp watch                文件监控打包&apos;);
  console.log(&apos;    gulp help                  gulp参数说明&apos;);
  console.log(&apos;    gulp server                测试server&apos;);
  console.log(&apos;    gulp -p                      生产环境（默认生产环境）&apos;);
  console.log(&apos;    gulp -d                      开发环境&apos;);
  console.log(&apos;    gulp -m &lt;module&gt;        部分模块打包（默认全部打包）&apos;);
});

//stylus css处理
gulp.task(&apos;stylusTask&apos;, function () {
  var processor = [
    autoprefixer,
    cssnano
  ];
  return gulp.src(&apos;src/stylus/*.styl&apos;)
    .pipe(sourcemaps.init())
    .pipe(stylus())
    .pipe(postcss(processor))
    .pipe(concat(&apos;built.css&apos;))
    .pipe(sourcemaps.write(&apos;./&apos;))
    .pipe(gulp.dest(&apos;src/css&apos;))
    .pipe(livereload());
});

//打包asset
gulp.task(&apos;copyAsset&apos;, function () {
  return gulp.src([
    &apos;./src/asset/**/*&apos;
    // &apos;./src/asset/jquery/**/*&apos;
  ])
    .pipe(gulp.dest(&apos;./dist/asset&apos;))
})

//打包html
gulp.task(&apos;copyHtml&apos;, function () {
  return gulp.src(&apos;./src/*.html&apos;)
    .pipe(htmlmin({
        collapseWhitespace:true,
        collapseBooleanAttributes:true,
        removeComments:true,
        removeEmptyAttributes:true,
        removeScriptTypeAttributes:true,
        removeStyleLinkTypeAttributes:true,
        minifyJS:true,
        minifyCSS:true    
    }))
    .pipe(gulp.dest(&apos;./dist&apos;))
})

//打包css
gulp.task(&apos;cssTask&apos;, [&apos;stylusTask&apos;], function () {
  return gulp.src(&apos;./src/css/built.css&apos;)
    .pipe(gulp.dest(&apos;./dist/css&apos;))
    .pipe(rename({suffix:&apos;.min&apos;}))
    .pipe(cleanCSS({compatibility:&apos;ie8&apos;}))
    .pipe(gulp.dest(&apos;./dist/css&apos;))
})

//打包js
gulp.task(&apos;jsTask&apos;, function () {
  return gulp.src(&apos;./src/js/*.js&apos;)
    .pipe(concat(&apos;built.js&apos;)) //合并到临时文件夹
    .pipe(gulp.dest(&apos;./dist/js&apos;)) //生成到目标文件夹
    .pipe(rename({suffix:&apos;.min&apos;})) //重命名
    .pipe(uglify()) //压缩
    .pipe(gulp.dest(&apos;./dist/js&apos;))
})

//打包图片
gulp.task(&apos;copyImages&apos;, function () {
  return gulp.src(&apos;./src/images/*&apos;)
    .pipe(imagemin({
      optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）
      progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片
      interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染
      multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化
    }))
    .pipe(gulp.dest(&apos;./dist/images&apos;))
})

//热加载
gulp.task(&apos;reload&apos;, function () {
  return gulp.src(&apos;src/*.html&apos;)
    .pipe(connect.reload())
});

//监听
gulp.task(&apos;server&apos;, function () {
  connect.server({
    root: &apos;src&apos;,
    livereload: true,
    port: 5000
  })
});

gulp.task(&apos;auto&apos;, function() {
  gulp.watch(&apos;src/stylus/*.styl&apos;, [&apos;stylusTask&apos;]);
  gulp.watch(&apos;src/css/*.css&apos;, [&apos;reload&apos;])
  gulp.watch(&apos;src/*.html&apos;, [&apos;reload&apos;]);
  gulp.watch(&apos;src/js/*.js&apos;, [&apos;reload&apos;]);
});


//执行任务
gulp.task(&apos;default&apos;, [&apos;server&apos;, &apos;auto&apos;]);

gulp.task(&apos;product&apos;, [&apos;cssTask&apos;, &apos;copyHtml&apos;, &apos;copyImages&apos;, &apos;jsTask&apos;, &apos;copyAsset&apos;, &apos;copyImages&apos;])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/12/23/摇头晃脑小哥/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/23/摇头晃脑小哥/" itemprop="url">摇头晃脑小哥</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T12:28:58+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://oncweb6po.bkt.clouddn.com/person.gif" alt=""></p>
<blockquote>
<p>因为之前做过一个动画的项目，大量运用animation，keyframe。无意中发现这个小demo，有一些启发。</p>
</blockquote>
<h3 id="1-包含层不用设置高度"><a href="#1-包含层不用设置高度" class="headerlink" title="1.包含层不用设置高度"></a>1.包含层不用设置高度</h3><pre><code>&lt;div class=&quot;head&quot;&gt;
    &lt;div class=&quot;face&quot;&gt;&lt;/div&gt;    
&lt;/div&gt;
.head{
    position: absolute;
    top: 20px;
    left: 50%;
}
.face{
    position: absolute;
    top:75px;
    left: 50%;
    margin-left: -60px;
    width: 120px;
    height: 170px;
    border-radius: 30px;
    background-color:  #fff7e5;
}
</code></pre><p>到时高度会被子元素撑起</p>
<h3 id="2-animation-延迟参数"><a href="#2-animation-延迟参数" class="headerlink" title="2.animation 延迟参数"></a>2.animation 延迟参数</h3><p>之前的项目用的是js的settimeout，做了demo才恍然大悟，有延迟参数呀！</p>
<h3 id="3-z-index"><a href="#3-z-index" class="headerlink" title="3.z-index"></a>3.z-index</h3><p>想要设置z-index，就必须要设position：relative, absolute或者fixed都可以。</p>
<h3 id="4-倾斜"><a href="#4-倾斜" class="headerlink" title="4.倾斜"></a>4.倾斜</h3><p>如果只是简单的倾斜，transform: rotate(Xdeg);就可以做到了，但是有时候还要考虑这个倾斜掉的元素的定位，所以严谨一点的话，还可以设置transform-origin这个属性。最主要就是记住：第一个值是水平（X），第二个值是竖直（Y）；默认的中心是50%，50%，左上角是0，0，右下角是100%，100%。</p>
<h3 id="5-圆角"><a href="#5-圆角" class="headerlink" title="5.圆角"></a>5.圆角</h3><ul>
<li><p>上下两头是半圆、中间是长方形</p>
<ul>
<li>只要让border-radius的值等于宽度的一半就可以了</li>
</ul>
</li>
<li><p>半圆形</p>
<ul>
<li>底部两个的圆角border-radius: 0 0 10px 10px</li>
</ul>
</li>
<li><p>下半圆角</p>
<ul>
<li>border-bottom-left-radius(上下左右)</li>
</ul>
</li>
</ul>
<h3 id="6-代码优化"><a href="#6-代码优化" class="headerlink" title="6.代码优化"></a>6.代码优化</h3><p>因为keyframe,animation需要写很多兼容，所以采用stylus，可以节省很多时间</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/10/17/css3实现网页平滑过渡效果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/css3实现网页平滑过渡效果/" itemprop="url">css3实现网页平滑过渡效果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-17T21:31:19+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、如何用纯css判断盒子被选中？"><a href="#一、如何用纯css判断盒子被选中？" class="headerlink" title="一、如何用纯css判断盒子被选中？"></a>一、如何用纯css判断盒子被选中？</h1><p>用radio</p>
<h1 id="二、font-smoothing"><a href="#二、font-smoothing" class="headerlink" title="二、font-smoothing"></a>二、font-smoothing</h1><ul>
<li>功能：css3中用于设置字体的抗锯齿或者说光滑度的属性</li>
<li><p>语法规则：</p>
<pre><code>font-smoothing:subpixel-antialiased | none | antialiased
</code></pre></li>
<li><p>取值说明</p>
</li>
</ul>
<blockquote>
<p>none用于小像素的文本、subpixel-antialiased浏览器默认的、antialiased反锯齿</p>
</blockquote>
<h1 id="三、translate3d"><a href="#三、translate3d" class="headerlink" title="三、translate3d"></a>三、translate3d</h1><p>可以开启GPU硬件加速</p>
<h1 id="四、backface-visibility"><a href="#四、backface-visibility" class="headerlink" title="四、backface-visibility"></a>四、backface-visibility</h1><ul>
<li>功能：定义当元素不面向屏幕时是否可见</li>
<li>语法规则：<pre><code>backface-visibility:visible | hidden
</code></pre></li>
<li>取值说明：</li>
</ul>
<p>visible:背面是可见的</p>
<p>hidden:背面是不可见的</p>
<h1 id="五、图标三角背景制作"><a href="#五、图标三角背景制作" class="headerlink" title="五、图标三角背景制作"></a>五、图标三角背景制作</h1><p>当画一个大三角形的时候，可以先用css画一个大矩形，再旋转，最后放到合适的地方露出直角，隐藏其他</p>
<h1 id="六、怎么实现动画过渡"><a href="#六、怎么实现动画过渡" class="headerlink" title="六、怎么实现动画过渡"></a>六、怎么实现动画过渡</h1><p>当写了transform时，动画是一下子变得，没有过渡。要实现过渡，需要在变换的盒子上加上transition</p>
<h1 id="七、怎么实现网页平滑过渡效果"><a href="#七、怎么实现网页平滑过渡效果" class="headerlink" title="七、怎么实现网页平滑过渡效果"></a>七、怎么实现网页平滑过渡效果</h1><pre><code>/* 内容 */
.st-scroll,
.st-panel{
    width: 100%;
    height:100%;
    position: relative; 
}

.st-scroll{
    left: 0;
    top: 0;
    -webkit-transform: translate3d(0,0,0);
    -moz-transform: translate3d(0,0,0);
    -o-transform: translate3d(0,0,0);
    -ms-transform: translate3d(0,0,0);
    transform: translate3d(0,0,0);
    -webkit-backface-visibility: hidden;
    /* 过渡谁就写谁 */
    -webkit-transition: all 0.6s ease-in-out; 
    -moz-transition: all 0.6s ease-in-out;
    -o-transition: all 0.6s ease-in-out;
    -ms-transition: all 0.6s ease-in-out;
    transition: all 0.6s ease-in-out;
}

.st-panel{
    background: #fff;
    overflow: hidden;
}

#st-control-1:checked ~ .st-scroll{
    -webkit-transform: translateY(0%);
    -moz-transform: translateY(0%);
    -o-transform: translateY(0%);
    -ms-transform: translateY(0%);
    transform: translateY(0%);
}
</code></pre><p>.st-scroll 是全部内容，.st-panel是单个内容。核心思想是，让每个内容100%占据网页，然后通过选择导航栏，让scroll移动（translateY)</p>
<h1 id="八、-font-face实现小icon"><a href="#八、-font-face实现小icon" class="headerlink" title="八、@font-face实现小icon"></a>八、@font-face实现小icon</h1><p>所有你要出现图标的div，都要加上data-icon的属性。里面的值就是显示的东西。css中用属性选择器进行书写，属性选择器要加[]</p>
<pre><code>&lt;div class=&quot;st-desc&quot; data-icon=&quot;C&quot;&gt;&lt;/div&gt;

[data-icon]:after{
    content: attr(data-icon);
}
</code></pre><h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><ul>
<li>功能</li>
</ul>
<p>@font-face 是css3中的一个模块，主要用于将自己定义的Web字体嵌入到网页中</p>
<ul>
<li><p>语法规则</p>
<p>  @font-face{</p>
<pre><code>font-family : &lt;YourWebFontName&gt;;
src : &lt;source&gt; [&lt;format&gt;][,&lt;source&gt;[&lt;format&gt;]]*;
[font-weight:&lt;weight&gt;];
[font-style:&lt;style&gt;];
</code></pre><p>  }</p>
</li>
<li><p>取值说明</p>
</li>
</ul>
<p>source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝对路径；</p>
<p>format:此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：</p>
<p>truetype,opentype,truetype-aat,embedded-opentype,svg等；</p>
<ul>
<li>常用的几种字体格式</li>
</ul>
<ol>
<li>TureType(.ttf)格式</li>
<li>OpenType(.otf)格式</li>
<li>Web Open Font Format(.woff)格式</li>
<li>Embedded Open Type(.eot)格式</li>
<li>SVG(.svg)格式</li>
</ol>
<ul>
<li>字体下载</li>
</ul>
<p>网址：<a href="http://www.dafont.com/" target="_blank" rel="external">http://www.dafont.com/</a></p>
<p>网址：<a href="http://www.google.com/webfonts" target="_blank" rel="external">http://www.google.com/webfonts</a></p>
<h1 id="九、transition-amp-amp-animation-区别"><a href="#九、transition-amp-amp-animation-区别" class="headerlink" title="九、transition &amp;&amp; animation 区别"></a>九、transition &amp;&amp; animation 区别</h1><p>transition 必须要事件触发，而animation用不用事件触发都可以</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/09/09/split-formatDate-store-util组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/split-formatDate-store-util组件/" itemprop="url">split,formatDate,store,util组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T17:58:01+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="split组件-vue-的代码"><a href="#split组件-vue-的代码" class="headerlink" title="split组件(vue)的代码"></a>split组件(vue)的代码</h2><p>split组件因为常使用,所以单独独立出来,并且结构相当简单.</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;split&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {};
&lt;/script&gt;

&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;
  .split
    width: 100%
    height: 16px
    border-top: 1px solid rgba(7, 17, 27, 0.1)
    border-bottom: 1px solid rgba(7, 17, 27, 0.1)
    background: #f3f5f7
&lt;/style&gt;
</code></pre><h2 id="formatDate-js组件"><a href="#formatDate-js组件" class="headerlink" title="formatDate.js组件"></a>formatDate.js组件</h2><pre><code>&lt;!--vue过滤器使用--&gt;
&lt;div class=&quot;time&quot;&gt;{{rating.rateTime | formatDate}}&lt;/div&gt;
</code></pre><hr>
<pre><code>//在es6下,export 函数function的导入需要这样写
import { formatDate } from &apos;../../common/js/date&apos;; //导入自定义的date模块

//vue里面的filters
filters: {
      formatDate(time) {
        let date = new Date(time);
        //调用date模块的formatDate函数来解析时间
        return formatDate(date, &apos;yyyy-MM-dd hh:mm&apos;);
      }
    },
</code></pre><p>formatDate.js是一个自定义的js组件,不是vue组件,目录位于:src/common/js,这种写法是为了练习js的模块化编程</p>
<ul>
<li>将单独的一个函数写成一个模块</li>
</ul>
<ul>
<li>通过export导出函数</li>
</ul>
<ul>
<li><p>通过import导入函数</p>
<pre><code>export function formatDate(date, fmt) { //在es6下导出一个函数
//对一个或多个y进行匹配,匹配到就进行年的替换(年有四位,所以需要特殊处理)
  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length));
  }
  let o = {
    &apos;M+&apos;: date.getMonth() + 1, //js的月是从0开始算,所以要加1
    &apos;d+&apos;: date.getDate(),
    &apos;h+&apos;: date.getHours(),
    &apos;m+&apos;: date.getMinutes(),
    &apos;s+&apos;: date.getSeconds()
  };
  //对月,日,时,分,秒进行匹配替换(这些都是两位,可以一起处理)
  for (let k in o) {
    if (new RegExp(`(${k})`).test(fmt)) { //匹配到key例如MM
      let str = o[k] + &apos;&apos;; //然后o[&apos;MM&apos;] 就是date.getMonth() + 1

      //如果匹配到的时间是1位数,例如是M,那么就直接使用date.getMonth() + 1的值,
      //如果是两位数,那么就在前面补0,使用padLeftZero函数
      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)); 
    }
  }
  return fmt;
};

//先加两个0,然后再根据长度截取(因为最长也就2个0的长度)
function padLeftZero(str) {
  return (&apos;00&apos; + str).substr(str.length);
}
</code></pre><h2 id="store-js组件"><a href="#store-js组件" class="headerlink" title="store.js组件"></a>store.js组件</h2></li>
</ul>
<p>这是一个js模块,负责html5的localstoage存储和读取的,位置: src/common/js/store.js</p>
<p>使用的方法是:</p>
<pre><code>//在es6下,export 函数function的导入需要这样写
 import { saveToLocal, loadFromLocal } from &apos;../../common/js/store&apos;;
</code></pre><p>代码:</p>
<pre><code>//存储
//传入三个参数,seller的id,要存储的key和value
export function saveToLocal (id, key, value) {
//需要加上window对象来使用localstorage
  let seller = window.localStorage.__seller__; //使用__只是一种标记写法,标记是自定义的某种编码规范,这里代表这只是seller的数据
  if (!seller) { //第一次生成seller的时候初始化
    seller = {}; 
    seller[id] = {};
  } else {
    seller = JSON.parse(seller); //json字符串需要解析
    if (!seller[id]) { //不同seller的时候初始化
      seller[id] = {};
    }
  }
  seller[id][key] = value; //生成当前的seller对象
  //localStorage只能存储字符串,需要转成json字符串
  window.localStorage.__seller__ = JSON.stringify(seller);
}

//读取
三个参数,seller的id,之前存储的key,和一个默认值
export function loadFromLocal (id, key, def) {
  let seller = window.localStorage.__seller__;
  if (!seller) { //读取不到返回默认值
    return def; 
  }
  seller = JSON.parse(seller)[id]; //json解析
  if (!seller) { //解析失败返回默认值
    return def;
  }
  let ret = seller[key]; 
  return ret || def; //解析成功但是没有这个seller的id的也返回默认值
}
</code></pre><ul>
<li>在node里面,没有默认全局window对象,所以需要指定加上才能使用window的相关方法和属性</li>
</ul>
<ul>
<li>seller[id][key] = value; 相当于是某个id的seller的某个属性(key)和值(value)保存为一个对象</li>
</ul>
<ul>
<li>关于写入的逻辑:先读取localstorage的已有值,判断是否存在,然后再去解析localstoage的已有值,判断是否等于当前的数据的key值(id),最后再处理最终的值是否存储,这里逻辑需要先判断已有值.</li>
</ul>
<ul>
<li>关于读取的逻辑:先读取localstorage判断是否有值,然后再去判断解析localstoage读取得到的值,最后再处理最终得到的值是否正常,按顺序进行逻辑处理<h2 id="util-js组件"><a href="#util-js组件" class="headerlink" title="util.js组件"></a>util.js组件</h2></li>
</ul>
<p>这个js模块负责获取url的参数,位置:src/common/js/util.js</p>
<pre><code>/**
 * 解析url参数
 * @example ?id=12345&amp;a=b
 * @return Object {id:12345,a:b}
 */

export function urlParse () {
  let url = window.location.search; //获取到url的所有参数
  let obj = {};
  let reg = /[?&amp;][^?&amp;]+=[^?&amp;]+/g; //正则判断获取
  let arr = url.match(reg); //正则获取后会保存到一个数组
  // [&apos;?id=12345&apos;,&apos;&amp;a=b&apos;]
  if (arr) {
    arr.forEach((item) =&gt; {
      let tempArr = item.substring(1).split(&apos;=&apos;); //将第一位去掉,然后用等号分隔
      let key = decodeURIComponent(tempArr[0]); //URI对于utf8格式会转码,所以这里需要解码
      let val = decodeURIComponent(tempArr[1]);
      obj[key] = val;
    });
  }
  return obj;
}
</code></pre><ul>
<li>读取url的所有参数,例如<a href="http://a.com/?id=12345&amp;a=b的?id=12345&amp;a=b" target="_blank" rel="external">http://a.com/?id=12345&amp;a=b的?id=12345&amp;a=b</a></li>
</ul>
<ul>
<li>然后进行正则匹配,/[?&amp;][^?&amp;]+=[&amp;?&amp;]+/g,以?id=12345&amp;a=b为举例:</li>
</ul>
<pre><code>- [?&amp;] 先匹配?和&amp;的,url参数都是有这个2个字符作为连接符,就是指匹配?


- [^?&amp;]+ 然后匹配非?和&amp;的多个,就是指匹配id


- = 匹配等号


- [^?&amp;]+ 然后匹配非?和&amp;的多个,就是指匹配12345
加起来就是能够匹配?id=12345&amp;a=b
</code></pre><ul>
<li>用对象返回,方便处理.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/person.jpg"
               alt="ZhangWei2222" />
          <p class="site-author-name" itemprop="name">ZhangWei2222</p>
           
              <p class="site-description motion-element" itemprop="description">Dream high</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangWei2222</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
