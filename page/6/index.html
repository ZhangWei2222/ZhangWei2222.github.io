<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="Dream high">
<meta property="og:type" content="website">
<meta property="og:title" content="ZhangWei2222">
<meta property="og:url" content="http://super-wei.xyz/page/6/index.html">
<meta property="og:site_name" content="ZhangWei2222">
<meta property="og:description" content="Dream high">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhangWei2222">
<meta name="twitter:description" content="Dream high">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://super-wei.xyz/page/6/"/>





  <title>ZhangWei2222</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhangWei2222</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/px-pd-pid-等移动端知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/px-pd-pid-等移动端知识/" itemprop="url">px pd pid 等移动端知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:21:03+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-PX（css-pixels）——虚拟像素"><a href="#1-PX（css-pixels）——虚拟像素" class="headerlink" title="1.PX（css pixels）——虚拟像素"></a>1.PX（css pixels）——虚拟像素</h1><p>px是一个相对单位，相对的是设备像素</p>
<p>显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为ppi和dpi：</p>
<p>ppi：每英寸多少像素数，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。</p>
<p>dpi：每英寸多少点。</p>
<h1 id="2-DP-device-pixels-——设备像素（物理像素）"><a href="#2-DP-device-pixels-——设备像素（物理像素）" class="headerlink" title="2.DP(device pixels)——设备像素（物理像素）"></a>2.DP(device pixels)——设备像素（物理像素）</h1><p>pt在css单位中属于真正的绝对单位，1pt = 1/72(inch),inch及英寸，而1英寸等于2.54厘米。</p>
<blockquote>
<p>屏幕普遍采用RGB色域(红、绿、蓝三个子像素构成),而印刷行业普遍使用CMYK色域(青、品红、黄和黑)</p>
</blockquote>
<h1 id="3-设备像素-DP-与CSS像素之间的关系"><a href="#3-设备像素-DP-与CSS像素之间的关系" class="headerlink" title="3.设备像素(DP)与CSS像素之间的关系"></a>3.设备像素(DP)与CSS像素之间的关系</h1><pre><code>DPR = 设备像素/CSS像素
</code></pre><p>当这个比率为1:1时，使用1个设备像素显示1个CSS像素。当这个比率为2:1时，使用4个设备像素显示1个CSS像素，当这个比率为3:1时，使用9（3*3）个设备像素显示1个CSS像素。</p>
<p>window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。</p>
<h1 id="4-DIP-Device-independent-Pixel"><a href="#4-DIP-Device-independent-Pixel" class="headerlink" title="4.DIP(Device independent Pixel)"></a>4.DIP(Device independent Pixel)</h1><p>设备独立像素，也称为逻辑像素，简称dip。</p>
<blockquote>
<p>CSS像素 =设备独立像素 = 逻辑像素</p>
</blockquote>
<h1 id="5-PPI-pixels-per-inch"><a href="#5-PPI-pixels-per-inch" class="headerlink" title="5.PPI(pixels per inch)"></a>5.PPI(pixels per inch)</h1><blockquote>
<p>每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。</p>
</blockquote>
<h1 id="6-ppi和dpr到底什么关系？"><a href="#6-ppi和dpr到底什么关系？" class="headerlink" title="6.ppi和dpr到底什么关系？"></a>6.ppi和dpr到底什么关系？</h1><p>设备像素比与ppi相关，一般是ppi/160的整数倍：</p>
<h1 id="7-分辨率、像素和屏幕尺寸"><a href="#7-分辨率、像素和屏幕尺寸" class="headerlink" title="7.分辨率、像素和屏幕尺寸"></a>7.分辨率、像素和屏幕尺寸</h1><p>PPI 说的是像素密度，而分辨率说的是块屏幕的像素尺寸，譬如说 1334*750 就是 iPhone（6~7）的分辨率，说 iPhone（6~7）的分辨率是 326 是错误的表述，326 是它的像素密度，单位是 PPI。</p>
<h1 id="8-Viewport"><a href="#8-Viewport" class="headerlink" title="8.Viewport"></a>8.Viewport</h1><blockquote>
<p>ppk认为，移动设备上有三个viewport。</p>
<ol>
<li>layout viewport  document.documentElement.clientWidth 来获取</li>
<li>visual viewport的宽度可以通过window.innerWidth 来获取</li>
<li>viewport——移动设备的理想viewport。根据不同的设备有不同的宽度</li>
</ol>
</blockquote>
<h3 id="1-怎么让layout-viewport-visual-viewport？"><a href="#1-怎么让layout-viewport-visual-viewport？" class="headerlink" title="(1).怎么让layout viewport=visual viewport？"></a>(1).怎么让layout viewport=visual viewport？</h3><blockquote>
<meta name="viewport" content="width=device-width, initial-scale=1">

</blockquote>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723080857.png" alt=""></p>
<h3 id="2-关于缩放以及initial-scale的默认值"><a href="#2-关于缩放以及initial-scale的默认值" class="headerlink" title="(2).关于缩放以及initial-scale的默认值"></a>(2).关于缩放以及initial-scale的默认值</h3><pre><code>visual viewport宽度 = ideal viewport宽度 / 当前缩放值
当前缩放值 = ideal viewport宽度 / visual viewport宽度
</code></pre><p>在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/两个viewport的故事-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/两个viewport的故事-二/" itemprop="url">两个viewport的故事(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:20:44+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-两个viewport"><a href="#1-两个viewport" class="headerlink" title="1.两个viewport"></a>1.两个viewport</h1><h3 id="1-visual-viewport"><a href="#1-visual-viewport" class="headerlink" title="(1).visual viewport"></a>(1).visual viewport</h3><p>visual viewport是页面当前显示在屏幕上的部分。用户可以通过滚动来改变他所看到的页面的部分，或者通过缩放来改变visual viewport的大小。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722214021.png" alt=""></p>
<h3 id="2-layout-viewport"><a href="#2-layout-viewport" class="headerlink" title="(2).layout viewport"></a>(2).layout viewport</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214137.png" alt=""></p>
<h3 id="3-度量visual-viewport"><a href="#3-度量visual-viewport" class="headerlink" title="(3).度量visual viewport"></a>(3).度量visual viewport</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214430.png" alt=""></p>
<h3 id="4-滚动距离Scrolling-offset"><a href="#4-滚动距离Scrolling-offset" class="headerlink" title="(4).滚动距离Scrolling offset"></a>(4).滚动距离Scrolling offset</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214525.png" alt=""></p>
<p>你还需知道的是visual viewport当前相对于layout viewport的位置。这是滚动距离，并且就像在桌面一样，它被存储在window.pageX/YOffset之中。</p>
<h3 id="5-元素"><a href="#5-元素" class="headerlink" title="(5). 元素"></a>(5).<html> 元素</html></h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214558.png" alt=""></p>
<p>就像在桌面上一样，document.documentElement.offsetWidth/Height提供了以CSS像素为单位的<html>元素的整个尺寸。</html></p>
<h3 id="6-媒体查询Media-queries"><a href="#6-媒体查询Media-queries" class="headerlink" title="(6).媒体查询Media queries"></a>(6).媒体查询Media queries</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214709.png" alt=""></p>
<p>媒体查询和其在桌面环境上的工作方式一样。width/height使用layout　viewport做为参照物，并且以CSS像素进行度量，device-width/height使用设备屏幕，并且以设备像素进行度量。</p>
<p>换句话说，width/height是document.documentElement.clientWidth/Height值的镜像，同时device-width/height是screen.width/height值的镜像。（它们在所有浏览器中实际上就是这么做的，即使这个镜像的值不正确。）</p>
<h3 id="7-事件坐标"><a href="#7-事件坐标" class="headerlink" title="(7).事件坐标"></a>(7).事件坐标</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214758.png" alt=""></p>
<p>pageX/Y仍然是相对于页面，以CSS像素为单位，并且它是目前为止三个属性对中最有用的，就像它在桌面环境上的那样。</p>
<p>clientX/Y是相对于visual viewport来计算，以CSS像素为单位的。这有道理的，即使我还不能完全指出这么做的好处。</p>
<p>screenX/Y是相对于屏幕来计算，以设备像素为单位。当然，这和clientX/Y用的参照系是一样的，并且设备像素在这没有用处。所以我们不需要担心screenX/Y；跟在桌面环境上一样没有用处。</p>
<h3 id="8-viewport-meta标签"><a href="#8-viewport-meta标签" class="headerlink" title="(8).viewport meta标签"></a>(8).viewport meta标签</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/两个viewport的故事-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/两个viewport的故事-一/" itemprop="url">两个viewport的故事(一))</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:20:24+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、设备像素和css像素"><a href="#一、设备像素和css像素" class="headerlink" title="一、设备像素和css像素"></a>一、设备像素和css像素</h1><h3 id="1-设备像素dp-device-pixels"><a href="#1-设备像素dp-device-pixels" class="headerlink" title="(1).设备像素dp(device pixels)"></a>(1).设备像素dp(device pixels)</h3><p>设备像素又称物理像素（physical pixel），设备能控制显示的最小单位，我们可以把这些像素看作成显示器上一个个的点。</p>
<h3 id="2-CSS像素"><a href="#2-CSS像素" class="headerlink" title="(2).CSS像素"></a>(2).CSS像素</h3><p>CSS像素是Web编程的概念，独立于设备的用于逻辑上衡量像素的单位，也就是说我们在做网页时用到的CSS像素单位，是抽象的，而不是实际存在的。</p>
<h3 id="设备独立像素比"><a href="#设备独立像素比" class="headerlink" title="设备独立像素比"></a>设备独立像素比</h3><p>独立于设备的用于逻辑上衡量像素的单位。（(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”，<strong>两个基本一样</strong>）</p>
<p>不管是移动端还是PC端通过screen.width/height获取的这个值是设备独立像素（CSS 像素），而不是设备的屏幕分辨率</p>
<h3 id="3-PPI"><a href="#3-PPI" class="headerlink" title="(3).PPI"></a>(3).PPI</h3><p>PPI就是设备像素dp的单位</p>
<p>pixel per inch 翻译下就是每英寸内有多少个像素点,这个像素点指的是设备像素点（物理像素），说得接地气点PPI就是像素密度（pixel density）。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722111500.png" alt=""></p>
<h3 id="4-设备像素比"><a href="#4-设备像素比" class="headerlink" title="(4).设备像素比"></a>(4).设备像素比</h3><pre><code>设备像素比 = 设备像素/设备独立像素 // 在某一方向上，x方向或者y方向
</code></pre><p>可以通过JavaScript 中的window.devicePixelRatio来获取设备中的像素比值。</p>
<p>它可以告诉我们，一个设备像素对应多少个css像素</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722112006.png" alt=""></p>
<blockquote>
<p>科普：什么是Retina视网膜屏幕？PPI 值超过 300 的叫做超高密度屏幕，只是 Apple 给它换了个高大尚的名称：Retina 视网膜屏幕而已。</p>
</blockquote>
<h3 id="5-屏幕尺寸"><a href="#5-屏幕尺寸" class="headerlink" title="(5).屏幕尺寸"></a>(5).屏幕尺寸</h3><p>意义：用户屏幕的整体大小。</p>
<p>度量单位：设备像素。</p>
<p>screen.width和screen.height</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722204008.png" alt=""></p>
<h3 id="6-窗口尺寸"><a href="#6-窗口尺寸" class="headerlink" title="(6).窗口尺寸"></a>(6).窗口尺寸</h3><p>意义：浏览器窗口的整体大小，包括滚动条。</p>
<p>度量单位：CSS像素。</p>
<p>它告诉了你用户到底有多少空间可以用来做CSS布局。你可以通过window.innerWidth和window.innerHeight来获取这些尺寸。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722204315.png" alt=""></p>
<h3 id="7-滚动距离"><a href="#7-滚动距离" class="headerlink" title="(7).滚动距离"></a>(7).滚动距离</h3><p>意义：页面滚动的距离。</p>
<p>度量单位：CSS像素。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722204457.png" alt=""></p>
<h3 id="8-viewport"><a href="#8-viewport" class="headerlink" title="(8).viewport"></a>(8).viewport</h3><p>viewport的功能是用来约束你网站中最顶级包含块元素（containing block）<html\>的。</html\></p>
<p>viewport，接着，实际上等于浏览器窗口：它就是那么定义的。</p>
<h3 id="9-度量viewport"><a href="#9-度量viewport" class="headerlink" title="(9).度量viewport"></a>(9).度量viewport</h3><p>document.documentElement.clientWidth/Height</p>
<p>意义：Viewport尺寸。</p>
<p>度量单位：CSS像素。</p>
<p>不等于html的尺寸</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722205640.png" alt=""></p>
<h3 id="10-度量元素"><a href="#10-度量元素" class="headerlink" title="(10).度量元素"></a>(10).度量<html>元素</html></h3><p>document.documentElement.offsetWidth/Height</p>
<p>意义：<html>元素（也就是页面）的尺寸。</html></p>
<p>度量单位：CSS像素。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722210037.png" alt=""></p>
<h3 id="11-事件中的坐标"><a href="#11-事件中的坐标" class="headerlink" title="(11).事件中的坐标"></a>(11).事件中的坐标</h3><ol>
<li>pageX/Y提供了相对于<html>元素的以CSS像素度量的坐标。(IEb不支持)</html></li>
</ol>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722210548.png" alt=""></p>
<ol>
<li>clientX/Y提供了相对于viewport的以CSS像素度量的坐标。</li>
</ol>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722210555.png" alt=""></p>
<ol>
<li>screenX/Y提供了相对于屏幕的以设备像素进行度量的坐标。</li>
</ol>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722210607.png" alt=""></p>
<p>90%的时间你将会使用pageX/Y；通常情况下你想知道的是相对于文档的事件坐标。其他的10%时间你将会使用clientX/Y。你永远不需要知道事件相对于屏幕的坐标。</p>
<h3 id="12-媒体查询"><a href="#12-媒体查询" class="headerlink" title="(12).媒体查询"></a>(12).媒体查询</h3><p>关于媒体查询的事。原理很简单：你可以声明「只在页面宽度大于，等于或者小于一个特定尺寸的时候才会被执行」的特殊的CSS规则。比如：</p>
<pre><code>div.sidebar {
    width: 300px;
}

@media all and (max-width: 400px) {
    // styles assigned when width is smaller than 400px;
    div.sidebar {
        width: 100px;
    }

}
</code></pre><p>当前sidebar是300px宽，除了当宽度小于400px的时候，在那种情况下sidebar变得100px宽。</p>
<p>这个宽度是 viewport的宽高</p>
<p>width/height使用和documentElement .clientWidth/Height（换句话说就是viewport宽高）一样的值。它是工作在CSS像素下的。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722211808.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/浏览器页面加载解析渲染机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/浏览器页面加载解析渲染机制/" itemprop="url">浏览器页面加载解析渲染机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:19:57+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。"><a href="#一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。" class="headerlink" title="一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。"></a>一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。</h1><ul>
<li><p>了解浏览器如何进行<strong>加载</strong>，我们可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。</p>
</li>
<li><p>了解浏览器如何进行<strong>解析</strong>，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。</p>
</li>
<li><p>了解浏览器如何进行<strong>渲染</strong>，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少”重绘“”重新布局“的消耗。</p>
</li>
</ul>
<h1 id="二：用户访问网页都发生了什么。"><a href="#二：用户访问网页都发生了什么。" class="headerlink" title="二：用户访问网页都发生了什么。"></a>二：用户访问网页都发生了什么。</h1><ol>
<li><p>用户访问网页，DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址，找到后，系统会向对应IP地址的网络服务器发送一个http请求。</p>
</li>
<li><p>网络服务器解析请求，并发送请求给数据库服务器。</p>
</li>
<li><p>数据库服务器将请求的资源返回给网络服务器，网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器。</p>
</li>
<li><p>浏览器解析 http response。</p>
</li>
<li><p>浏览器解析 http response后，需要下载html文件，以及html文件内包含的外部引用文件，及文件内涉及的图片或者多媒体文件。（这里进入主题了也就是下面的第三大点）</p>
</li>
</ol>
<blockquote>
<p>1~4步骤HTTP协议的一些内容，访问服务器端可能遭遇的问题：如果网络服务器无法获取数据库服务器返回的资源文件（http response 404），或者由于并发原因暂时无法处理用户的http请求（http response 500）。</p>
</blockquote>
<h1 id="三：浏览器加载页面机制"><a href="#三：浏览器加载页面机制" class="headerlink" title="三：浏览器加载页面机制"></a>三：浏览器加载页面机制</h1><p>加载，即为获取资源文件的过程，不同浏览器，以及他们的不同版本在实现这一过程时，会有不同的实现效果(资源间互相阻塞，可以用timeline来做测试)。这里先说下浏览器的<strong>5个常驻线程</strong>：</p>
<ol>
<li><p>浏览器GUI渲染线程</p>
</li>
<li><p>javascript引擎线程</p>
</li>
<li><p>浏览器定时器触发线程（setTimeout）</p>
</li>
<li><p>浏览器事件触发线程</p>
</li>
<li><p>浏览器http异步请求线程（.jpg <link>这类请求）</p>
</li>
</ol>
<blockquote>
<p>备注：现代浏览器存在 prefetch 优化，浏览器会另外开启线程，提前下载js、css文件，需要注意的是，预加载js并不会改变dom结构，他将这个工作留给主加载。</p>
<p>注意：这里也涉及到 阻塞 的现象，当js引擎线程（第二个）进行时，会挂起其他一切线程，这个时候3、4、5这三类线程也会产生不同的异步事件，由于 javascript引擎线程为单线程，所以代码都是先压到队列，采用先进先出的方式运行，事件处理函数，timer函数也会压在队列中，不断的从队头取出事件，这就叫：javascript-event-loop。简单点说应该是当在进行第二线程的时候，1，3，4，5都会挂起，比如这时候触发click事件，即使先前JS已经加载完成，click事件会压在队列里，这里也要先完成第二线程才会执行click事件。</p>
</blockquote>
<p><strong>加载顺序：</strong></p>
<ol>
<li><p>浏览器解析http response 下载html文件会”自上而下“加载，并在加载过程中进行解析渲染。“自上而下”加载时遇到图片、视频之类资源时便会进入第5个线程，这是异步请求，并不会影响html文档进行加载。</p>
</li>
<li><p>加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。这里也是第5个线程，这里css解析会生成一个rule tree（规则树），这个以后会更新。</p>
</li>
<li><p>当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。</p>
</li>
</ol>
<blockquote>
<p>原因：JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。</p>
<p>办法：可以将外部引用的js文件放在前。</p>
</blockquote>
<p> 4、  css可能影响js的执行造成阻塞。</p>
<p>原因：如js里面var width = $(‘#id’).width();这里js执行前，浏览器必须保证之前的css文件已下载和解析完成(后面的不会影响)，这也是css阻塞后续js的根本原因。当js文件不需要依赖css文件时，可以将js文件放在头部css的前面。</p>
<p>5、 预加载网页，利用空余时间来提前加载该网页的后续网页。</p>
<pre><code>&lt;link rel=&quot;prefetch&quot; href=&quot;http://&quot;&gt;
</code></pre><p>6、为js脚本添加defer属性，其不会阻塞后续DOM的的渲染。但是因为这个defer只是IE专用，所以一般用得比较少。</p>
<p>而我们标准的的HTML5也加入了一个异步载入javascript的属性：async，无论你对它赋什么样的值，只要它出现，它就开始异步加载js文件。</p>
<p>但是， async的异步加载会有一个比较严重的问题，那就是它忠实地践行着“载入后马上执行”这条军规，所以，虽然它并不阻塞页面的渲染，但是你也无法控制他执行的次序和时机。</p>
<h1 id="四、浏览器解析渲染机制"><a href="#四、浏览器解析渲染机制" class="headerlink" title="四、浏览器解析渲染机制"></a>四、浏览器解析渲染机制</h1><h3 id="1-浏览器是如何对网页进行渲染的"><a href="#1-浏览器是如何对网页进行渲染的" class="headerlink" title="1.浏览器是如何对网页进行渲染的"></a>1.浏览器是如何对网页进行渲染的</h3><p>（1）.浏览器将从服务器获取的HTML文档构建成文档对象模型DOM(Document Object Model)</p>
<p>（2）.样式将被载入和解析，构成层叠样式表模型CSSOM(CSS Object Model)</p>
<p>（3）.在DOM和CSSOM之上，渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象（这在Webkit内核中被称为renderer或者渲染对象render object，在Gecko内核中被称为框架frame）。<strong>渲染树映射除了不可见元素（例如<head>或者含有display:none;的标签）外的所有DOM结构。</head></strong>每一段文本字符串都将划分在不同的渲染对象中，每一个渲染对象都包含了它相应的DOM对象以及计算后的样式。换句话讲，渲染树是DOM的直观表示。</p>
<p>（4）.渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout.浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素（tables需要多次pass绘制，pass表示像素处理和顶点处理）。</p>
<p>（5）.最后布局完成，渲染树将转化为屏幕上的实际内容，这一步被称为绘制painting。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170714155844.png" alt=""></p>
<h3 id="DOM-CSSOM-rendering-tree-layout-painting"><a href="#DOM-CSSOM-rendering-tree-layout-painting" class="headerlink" title="DOM-CSSOM-rendering tree-layout-painting"></a>DOM-CSSOM-rendering tree-layout-painting</h3><h3 id="2-重绘Repaint"><a href="#2-重绘Repaint" class="headerlink" title="2.重绘Repaint"></a>2.重绘Repaint</h3><p>当页面元素样式的改变不影响元素在文档流中的位置时（例如background-color, border-color,visibility）,浏览器只会将新样式赋予元素并进行重绘操作。</p>
<h3 id="3-回流Reflow"><a href="#3-回流Reflow" class="headerlink" title="3.回流Reflow"></a>3.回流Reflow</h3><p>当改变影响文档内容或者结构，或者元素位置时，回流操作就会被触发，一般有以下几种情况：</p>
<ol>
<li><p>DOM操作（对元素的增删改，顺序变化等）</p>
</li>
<li><p>内容变化，包括表单区域内的文本改变</p>
</li>
<li><p>CSS属性的更改或重新计算</p>
</li>
<li><p>增删样式表内容</p>
</li>
<li><p>修改class属性</p>
</li>
<li><p>浏览器窗口变化（滚动或缩放）</p>
</li>
<li><p>伪类样式激活（:hover等）</p>
</li>
</ol>
<h3 id="4-浏览器如何优化渲染"><a href="#4-浏览器如何优化渲染" class="headerlink" title="4.浏览器如何优化渲染"></a>4.浏览器如何优化渲染</h3><p>浏览器本身会尽可能地减少其重绘或回流的次数，只更改必要的元素。例如一个position设置为absolute/fixed的元素的更改只会影响其本身和其子元素，而static的元素变化则会影响其之后的所有页面元素。</p>
<p>另外一项优化的技术则是在JavaScript代码运行时，浏览器会缓存所有的变化，然后只通过一次pass绘制操作来应用这些更改。例如下面这段代码只会触发一次重绘和回流：</p>
<pre><code>var $body = $(&apos;body&apos;);
$body.css(&apos;padding&apos;, &apos;1px&apos;); // 触发重绘与回流
$body.css(&apos;color&apos;, &apos;red&apos;); // 触发重绘
$body.css(&apos;margin&apos;, &apos;2px&apos;); // 触发重绘与回流
// 最终只有一次重绘和回流被触发
</code></pre><p>然而，根据我们之前提到过的，获取某个元素的属性将会触发强制回流。比如我们在刚才的代码中加上一句读取元素属性的操作：</p>
<pre><code>var $body = $(&apos;body&apos;);
$body.css(&apos;padding&apos;, &apos;1px&apos;);
$body.css(&apos;padding&apos;); // 此处触发强制回流
$body.css(&apos;color&apos;, &apos;red&apos;);
$body.css(&apos;margin&apos;, &apos;2px&apos;);
</code></pre><p>结果就会有两次回流发生。因此，我们应该尽量合并读取元素属性的操作来优化性能。</p>
<p>当然也有我们不得不触发强制回流的情况。比如说对同一个元素的margin-left属性进行两次操作——开始的时候赋值100px的距离，之后为了实现动画效果，再加上transition属性将距离改变到50px.</p>
<p>我们先定义一个CSS类：</p>
<pre><code>.has-transition {
   -webkit-transition: margin-left 1s ease-out;
      -moz-transition: margin-left 1s ease-out;
        -o-transition: margin-left 1s ease-out;
           transition: margin-left 1s ease-out;
}
</code></pre><p>之后再对页面元素进行操作：</p>
<pre><code>// 我们的元素开始默认含有 &quot;has-transition&quot; 的class属性
var $targetElem = $(&apos;#targetElemId&apos;);

// 移除默认的 &quot;has-transition&quot;
$targetElem.removeClass(&apos;has-transition&apos;);

// 此处的属性改变没有动画效果
$targetElem.css(&apos;margin-left&apos;, 100);

// 再加上原来的属性名
$targetElem.addClass(&apos;has-transition&apos;);

// 这次改变有动画效果
$targetElem.css(&apos;margin-left&apos;, 50);
</code></pre><p>但事实上这段代码并不会像注释描述的那样运作，每条语句的操作将被缓存，只有结果会在页面上显示，所以我们就需要手动进行一次强制回流：</p>
<pre><code>// 移除默认的 &quot;has-transition&quot;
$(this).removeClass(&apos;has-transition&apos;);

// 此处的属性改变没有动画效果
$(this).css(&apos;margin-left&apos;, 100);

// 触发强制回流，上述两条语句的效果会马上在页面中显示
$(this)[0].offsetHeight; // 只是举个例子，别的触发方法也可以

// 再加上原来的属性名
$(this).addClass(&apos;has-transition&apos;);

// 这次改变有动画效果
$(this).css(&apos;margin-left&apos;, 50);
</code></pre><h3 id="5-优化渲染效率的几条最佳实践"><a href="#5-优化渲染效率的几条最佳实践" class="headerlink" title="5.优化渲染效率的几条最佳实践"></a>5.优化渲染效率的几条最佳实践</h3><ol>
<li><p>合法地书写HTML和CSS，不要忘了文档编码类型。样式文件应当在 <head> 标签中，脚本文件在 </head><body> 结束前。</body></p>
</li>
<li><p>简化并优化你的CSS选择器（有些人可能CSS预处理器用习惯了从来不关注这一点）。将嵌套层减少到最小。CSS选择器根据其优先级具有不同的运行效率（从快到慢）：</p>
</li>
</ol>
<ul>
<li>ID选择器： #id</li>
</ul>
<ul>
<li>类选择器： .class</li>
</ul>
<ul>
<li>标签选择器： div</li>
</ul>
<ul>
<li>相邻选择器： a + i</li>
</ul>
<ul>
<li>子元素选择器： ul &gt; li</li>
</ul>
<ul>
<li>通用选择器： *</li>
</ul>
<ul>
<li>属性选择器： input[type=”text”]</li>
</ul>
<ul>
<li>伪类选择器： a:hover</li>
</ul>
<p>浏览器中CSS选择器是从右到左进行匹配的（为什么浏览器要从右到左匹配样式选择器），这也是为什么越短的选择器运行越快的原因（别提通用选择器，它会遍历所有元素）：</p>
<pre><code>div * {...} // ×
.list li {...} // ×
.list-item {...} // √
#list .list-item {...} // √
</code></pre><p>3.在你的脚本代码中，尽量减少DOM操作。缓存所有的内容，包括属性和对象（如果他们需要被复用的话）。尽量将元素缓存到本地之后再进行操作，最后再添加到DOM当中。</p>
<p>4.如果你使用jQuery进行DOM操作的话，最好遵循jQuery最佳实践。</p>
<p>5.修改元素样式时，更改其class属性是性能最高的方法。你的选择器越有针对性越好（这同样也有助于分离页面样式和逻辑）。</p>
<p>6.尽量只对 position 为 absolute/fixed 的元素设置动画。</p>
<p>7.在页面滚动时禁用 :hover 样式效果：</p>
<pre><code>.disable-hover {
  pointer-events: none;
}
var body = document.body,
    timer;

window.addEventListener(&apos;scroll&apos;, function() {
  clearTimeout(timer);
  if(!body.classList.contains(&apos;disable-hover&apos;)) {
    body.classList.add(&apos;disable-hover&apos;)
  }

  timer = setTimeout(function(){
    body.classList.remove(&apos;disable-hover&apos;)
  },500);
}, false);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/vuex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/vuex/" itemprop="url">vuex</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:18:08+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>vuex是一个专门为vue.js设计的集中式状态管理架构。状态？我把它理解为在data中的属性需要共享给其他vue组件使用的部分，就叫做状态。简单的说就是data中需要共用的属性。比如：我们有几个页面要显示用户名称和用户等级，或者显示用户的地理位置。如果我们不把这些属性设置为状态，那每个页面遇到后，都会到服务器进行查找计算，返回后再显示。在中大型项目中会有很多共用的数据，所以尤大神给我们提供了vuex。</p>
<h1 id="第1节：初出茅庐-来个小Demo"><a href="#第1节：初出茅庐-来个小Demo" class="headerlink" title="第1节：初出茅庐 来个小Demo"></a>第1节：初出茅庐 来个小Demo</h1><h2 id="引入vuex"><a href="#引入vuex" class="headerlink" title="引入vuex"></a>引入vuex</h2><p>1.利用npm包管理工具，进行安装 vuex。在控制命令行中输入下边的命令就可以了。</p>
<pre><code>npm install vuex --save
</code></pre><p>需要注意的是这里一定要加上 –save，因为你这个包我们在生产环境中是要使用的。</p>
<p>2.新建一个vuex文件夹（这个不是必须的），并在文件夹下新建store.js文件，文件中引入我们的vue和vuex。</p>
<pre><code>import Vue from &apos;vue&apos;;
import Vuex from &apos;vuex&apos;;
</code></pre><p>3.使用我们vuex，引入之后用Vue.use进行引用。</p>
<pre><code>Vue.use(Vuex);
</code></pre><h2 id="一个demo：加减按钮"><a href="#一个demo：加减按钮" class="headerlink" title="一个demo：加减按钮"></a>一个demo：加减按钮</h2><p>这次要用的是vuex来进行制作，并实现数据的共享。</p>
<p>1.现在我们store.js文件里增加一个常量对象。store.js文件就是我们在引入vuex时的那个文件。</p>
<pre><code>const state={
    count:1
}
</code></pre><p>2.用export default 封装代码，让外部可以引用。</p>
<pre><code>export default new Vuex.Store({
    state

})
</code></pre><p>3.新建一个vue的模板，位置在components文件夹下，名字叫count.vue。在模板中我们引入我们刚建的store.js文件，并在模板中用输出count 的值。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{msg}}&lt;/h2&gt;
        &lt;hr/&gt;
        &lt;h3&gt;{{$store.state.count}}&lt;/h3&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import store from &apos;@/vuex/store&apos;
    export default{
        data(){
            return{
                msg:&apos;Hello Vuex&apos;,

            }
        },
        store

    }
&lt;/script&gt;
</code></pre><p>4.在store.js文件中加入两个改变state的方法。</p>
<pre><code>const mutations={
    add(state){
        state.count++;
    },
    reduce(state){
        state.count--;
    }
}
</code></pre><p>这里的mutations是固定的写法，意思是改变的，我们到时候会用一节课专门讲这个mutations，所以你先不用着急，只知道我们要改变state的数值的方法，必须写在mutations里就可以了。</p>
<p>5.在count.vue模板中加入两个按钮，并调用mutations中的方法。</p>
<pre><code>&lt;div&gt;
    &lt;button @click=&quot;$store.commit(&apos;add&apos;)&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;$store.commit(&apos;reduce&apos;)&quot;&gt;-&lt;/button&gt;
&lt;/div&gt;
</code></pre><h1 id="第2节：state访问状态对象"><a href="#第2节：state访问状态对象" class="headerlink" title="第2节：state访问状态对象"></a>第2节：state访问状态对象</h1><p>在第1节我们已经写了一个 const state ，这个就是我们说的访问状态对象，它就是我们SPA（单页应用程序）中的共享值。今天我们主要学习状态对象赋值给内部对象，也就是把stroe.js中的值，赋值给我们模板里data中的值。我们有三种赋值方式，我们一个一个来学习一下。</p>
<h2 id="一、通过computed的计算属性直接赋值"><a href="#一、通过computed的计算属性直接赋值" class="headerlink" title="一、通过computed的计算属性直接赋值"></a>一、通过computed的计算属性直接赋值</h2><p>computed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。</p>
<pre><code>computed:{
    count(){
        return this.$store.state.count;
    }
}
</code></pre><p>这里需要注意的是return this.$store.state.count这一句，一定要写this，要不你会找不到$store的。这种写法很好理解，但是写起来是比较麻烦的，那我们来看看第二种写法。</p>
<h2 id="二、通过mapState的对象来赋值"><a href="#二、通过mapState的对象来赋值" class="headerlink" title="二、通过mapState的对象来赋值"></a>二、通过mapState的对象来赋值</h2><p>我们首先要用import引入mapState。</p>
<pre><code>import {mapState} from &apos;vuex&apos;;
</code></pre><p>然后还在computed计算属性里写如下代码：</p>
<pre><code>computed:mapState({
        count:state=&gt;state.count
 })
</code></pre><p>这里我们使用ES6的箭头函数来给count赋值。</p>
<h2 id="三、通过mapState的数组来赋值"><a href="#三、通过mapState的数组来赋值" class="headerlink" title="三、通过mapState的数组来赋值"></a>三、通过mapState的数组来赋值</h2><pre><code>computed:mapState([&quot;count&quot;])
</code></pre><p>这个算是最简单的写法了，在实际项目开发当中也经常这样使用。</p>
<p>这就是三种赋值方式，是不是很简单，虽然简单，但是在实际项目中经常使用，一定要自己动手练习两遍啊。</p>
<h1 id="第4节：getters计算过滤操作"><a href="#第4节：getters计算过滤操作" class="headerlink" title="第4节：getters计算过滤操作"></a>第4节：getters计算过滤操作</h1><p>getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工。你可以把它看作store.js的计算属性。</p>
<h2 id="getters基本用法："><a href="#getters基本用法：" class="headerlink" title="getters基本用法："></a>getters基本用法：</h2><p>比如我们现在要对store.js文件中的count进行一个计算属性的操作，就是在它输出前，给它加上100.</p>
<p>我们首先要在store.js里用const声明我们的getters属性。</p>
<pre><code>const getters = {
    count:function(state){
        return state.count +=100;
    }
}
</code></pre><p>写好了gettters之后，我们还需要在Vuex.Store()里引入，由于之前我们已经引入了state盒mutations，所以引入里有三个引入属性。代码如下，</p>
<pre><code>export default new Vuex.Store({
    state,mutations,getters
})
</code></pre><p>在store.js里的配置算是完成了，我们需要到模板页对computed进行配置。在vue 的构造器里边只能有一个computed属性，如果你写多个，只有最后一个computed属性可用，所以要对上节课写的computed属性进行一个改造。改造时我们使用ES6中的展开运算符”…”。</p>
<pre><code>computed:{
    ...mapState([&quot;count&quot;]),
    count(){
        return this.$store.getters.count;
    }
},
</code></pre><p>需要注意的是，你写了这个配置后，在每次count 的值发生变化的时候，都会进行加100的操作。</p>
<h2 id="用mapGetters简化模板写法："><a href="#用mapGetters简化模板写法：" class="headerlink" title="用mapGetters简化模板写法："></a>用mapGetters简化模板写法：</h2><p>我们都知道state和mutations都有map的引用方法把我们模板中的编码进行简化，我们的getters也是有的，我们来看一下代码。</p>
<p>首先用import引入我们的mapGetters</p>
<pre><code>import { mapState,mapMutations,mapGetters } from &apos;vuex&apos;;
</code></pre><p>在computed属性中加入mapGetters</p>
<pre><code>...mapGetters([&quot;count&quot;])
</code></pre><h1 id="第5节：actions异步修改状态"><a href="#第5节：actions异步修改状态" class="headerlink" title="第5节：actions异步修改状态"></a>第5节：actions异步修改状态</h1><p>actions和之前讲的Mutations功能基本一样，不同点是，actions是异步的改变state状态，而Mutations是同步改变状态。至于什么是异步什么是同步这里我就不做太多解释了，如果你不懂自己去百度查一下吧。（视频中有讲解）</p>
<h2 id="在store-js中声明actions"><a href="#在store-js中声明actions" class="headerlink" title="在store.js中声明actions"></a>在store.js中声明actions</h2><p>actions是可以调用Mutations里的方法的，我们还是继续在上节课的代码基础上进行学习，在actions里调用add和reduce两个方法。</p>
<pre><code>const actions ={
    addAction(context){
        context.commit(&apos;add&apos;,10)
    },
    reduceAction({commit}){
        commit(&apos;reduce&apos;)
    }
}
</code></pre><p>在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。细心的小伙伴会发现这两个方法传递的参数也不一样。</p>
<ul>
<li>context：上下文对象，这里你可以理解称store本身。</li>
</ul>
<ul>
<li>{commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。</li>
</ul>
<h2 id="模板中的使用"><a href="#模板中的使用" class="headerlink" title="模板中的使用"></a>模板中的使用</h2><p>我们需要在count.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的actions里的方法名，分别是：addAction和reduceAction。</p>
<pre><code>&lt;p&gt;
  &lt;button @click=&quot;addAction&quot;&gt;+&lt;/button&gt;
  &lt;button @click=&quot;reduceAction&quot;&gt;-&lt;/button&gt;
&lt;/p&gt;
</code></pre><p>改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。</p>
<pre><code>methods:{
    ...mapMutations([  
        &apos;add&apos;,&apos;reduce&apos;
    ]),
    ...mapActions([&apos;addAction&apos;,&apos;reduceAction&apos;])
},
</code></pre><p>你还要记得用import把我们的mapActions引入才可以使用。</p>
<h2 id="增加异步检验"><a href="#增加异步检验" class="headerlink" title="增加异步检验"></a>增加异步检验</h2><p>我们现在看的效果和我们用Mutations作的一模一样，肯定有的小伙伴会好奇，那actions有什么用，我们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用setTimeOut进行延迟执行。</p>
<pre><code>setTimeOut(()=&gt;{context.commit(reduce)},3000);
console.log(&apos;我比reduce提前执行&apos;);
</code></pre><p>我们可以看到在控制台先打印出了‘我比reduce提前执行’这句话。</p>
<h1 id="第6节：module模块组"><a href="#第6节：module模块组" class="headerlink" title="第6节：module模块组"></a>第6节：module模块组</h1><p>随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。那今天我们就学习一下module：状态管理器的模块组操作。</p>
<h2 id="声明模块组："><a href="#声明模块组：" class="headerlink" title="声明模块组："></a>声明模块组：</h2><p>在vuex/store.js中声明模块组，我们还是用我们的const常量的方法声明模块组。代码如下：</p>
<pre><code>const moduleA={
    state,mutations,getters,actions
}
</code></pre><p>声明好后，我们需要修改原来 Vuex.Stroe里的值：</p>
<pre><code>export default new Vuex.Store({
    modules:{a:moduleA}
})
</code></pre><h2 id="在模板中使用"><a href="#在模板中使用" class="headerlink" title="在模板中使用"></a>在模板中使用</h2><p>现在我们要在模板中使用count状态，要用插值的形式写入。</p>
<pre><code>&lt;h3&gt;{{$store.state.a.count}}&lt;/h3&gt;
</code></pre><p>如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。写法如下：</p>
<pre><code>computed:{
    count(){
        return this.$store.state.a.count;
    }
},
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/vue-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/vue-router/" itemprop="url">vue-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:17:13+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于Vue在开发时对路由支持的不足，后来官方补充了vue-router插件，它在Vue的生态环境中非常重要，在实际开发中只要编写一个页面就会操作vue-router。要学习vue-router就要先知道这里的路由是什么？这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是我们WebApp的链接路径管理系统。</p>
<p>有的小伙伴会有疑虑，为什么我们不能像原来一样直接用<a></a>标签编写链接哪？因为我们用Vue作的都是单页应用，就相当于只有一个主的index.html页面，所以你写的<a></a>标签是不起作用的，你必须使用vue-router来进行管理。</p>
<h1 id="第1节：Vue-router入门"><a href="#第1节：Vue-router入门" class="headerlink" title="第1节：Vue-router入门"></a>第1节：Vue-router入门</h1><h2 id="安装vue-router"><a href="#安装vue-router" class="headerlink" title="安装vue-router"></a>安装vue-router</h2><p>vue-router是一个插件包，所以我们还是需要用npm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。</p>
<pre><code>npm install vue-router --save-dev
</code></pre><p>如果你安装很慢，也可以用cnpm进行安装，如果你在使用vue-cli中已经选择安装了vue-router，那这里不需要重复安装了。</p>
<h2 id="解读router-index-js文件"><a href="#解读router-index-js文件" class="headerlink" title="解读router/index.js文件"></a>解读router/index.js文件</h2><p>我们用vue-cli生产了我们的项目结构，你可以在src/router/index.js文件，这个文件就是路由的核心文件，我们先解读一下它。</p>
<pre><code>import Vue from &apos;vue&apos;   //引入Vue
import Router from &apos;vue-router&apos;  //引入vue-router
import Hello from &apos;@/components/Hello&apos;  //引入根目录下的Hello.vue组件

Vue.use(Router)  //Vue全局使用Router

export default new Router({
  routes: [              //配置路由，这里是个数组
    {                    //每一个链接都是一个对象
      path: &apos;/&apos;,         //链接路径
      name: &apos;Hello&apos;,     //路由名称，
      component: Hello   //对应的组件模板
    }
  ]
})
</code></pre><p>上边的代码中已经对每行都进行了注释，其实在这个路由文件里只配置了一个功能，就是在进入项目时，显示Hello.vue里边的内容代码。</p>
<h2 id="增加一个Hi的路由和页面"><a href="#增加一个Hi的路由和页面" class="headerlink" title="增加一个Hi的路由和页面"></a>增加一个Hi的路由和页面</h2><ul>
<li>在src/components目录下，新建 Hi.vue 文件。</li>
</ul>
<ul>
<li><p>编写文件内容，和我们之前讲过的一样，文件要包括三个部分<template><script>和<style>。文件很简单，只是打印一句话。</p>
  <template><br>    <div class="hello"><br>      <h1></h1><br>    </div><br>  </template>

  <script>
  export default {
    name: 'hi',
    data () {
      return {
        msg: 'Hi, I am JSPang'
      }
    }
  }
  </script>


</template></p></li>
</ul>
<pre><code>&lt;style scoped&gt;

&lt;/style&gt;
</code></pre><ul>
<li>引入 Hi组件：我们在router/index.js文件的上边引入Hi组件</li>
</ul>
<ul>
<li><p>增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。</p>
<p>  {</p>
<pre><code>path:&apos;/hi&apos;,
name:&apos;Hi&apos;,
component:Hi
</code></pre><p>  }</p>
<p>  import Vue from ‘vue’   //引入Vue<br>  import Router from ‘vue-router’  //引入vue-router<br>  import Hello from ‘@/components/Hello’  //引入根目录下的Hello.vue组件<br>  import Hi from ‘@/components/Hi’ </p>
<p>  Vue.use(Router)  //Vue全局使用Router</p>
<p>  export default new Router({</p>
<pre><code>routes: [              //配置路由，这里是个数组
  {                    //每一个链接都是一个对象
    path: &apos;/&apos;,         //链接路径
    name: &apos;Hello&apos;,     //路由名称，
    component: Hello   //对应的组件模板
  },{
    path:&apos;/hi&apos;,
    name:&apos;Hi&apos;,
    component:Hi
  }
]
</code></pre><p>  })</p>
</li>
</ul>
<h2 id="router-link制作导航"><a href="#router-link制作导航" class="headerlink" title="router-link制作导航"></a>router-link制作导航</h2><p>现在通过在地址栏改变字符串地址，已经可以实现页面内容的变化了。这并不满足需求，我们需要的是在页面上有个像样的导航链接，我们只要点击就可以实现页面内容的变化。制作链接需要<router-link>标签，我们先来看一下它的语法。</router-link></p>
<pre><code>&lt;router-link to=&quot;/&quot;&gt;[显示字段]&lt;/router-link&gt;
</code></pre><ul>
<li>to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成  to=”/”  ，</li>
<li>[显示字段] ：就是我们要显示给用户的导航名称，比如首页  新闻页。</li>
</ul>
<p>明白了router-link的基本语法，我们在 src/App.vue文件中的template里加入下面代码，实现导航。</p>
<pre><code>&lt;p&gt;导航 ：
   &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;
   &lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt;
&lt;/p&gt;
</code></pre><h1 id="第2节：vue-router配置子路由"><a href="#第2节：vue-router配置子路由" class="headerlink" title="第2节：vue-router配置子路由"></a>第2节：vue-router配置子路由</h1><p>我们上节课初步了解Vue-router的初步知识，也学会了基本的跳转，那我们这节课学习一下子菜单的路由方式，也叫子路由。子路由的情况一般用在一个页面有他的基础模版，然后它下面的页面都隶属于这个模版，只是部分改变样式。我们接着第一节课的实例，在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。</p>
<h2 id="一、改造App-vue的导航代码"><a href="#一、改造App-vue的导航代码" class="headerlink" title="一、改造App.vue的导航代码"></a>一、改造App.vue的导航代码</h2><p>我们需要先改造app.vue的导航代码，来实现基本的导航功能。我们用<router-link>标签增加了两个新的导航链接。</router-link></p>
<h2 id="App-vue代码"><a href="#App-vue代码" class="headerlink" title="App.vue代码"></a>App.vue代码</h2><pre><code>&lt;p&gt;导航 ：
      &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; | 
      &lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt; |
      &lt;router-link to=&quot;/hi/hi1&quot;&gt;-Hi页面1&lt;/router-link&gt; |
      &lt;router-link to=&quot;/hi/hi2&quot;&gt;-Hi页面2&lt;/router-link&gt;
&lt;/p&gt;
</code></pre><h2 id="二、改写components-Hi-vue页面"><a href="#二、改写components-Hi-vue页面" class="headerlink" title="二、改写components/Hi.vue页面"></a>二、改写components/Hi.vue页面</h2><p>把Hi.vue改成一个通用的模板，加入<router-view>标签，给子模板提供插入位置。“Hi页面1”   和 “Hi页面2”  都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入<router-view>标签。</router-view></router-view></p>
<p>components/Hi.vue,就是第5行的代码，其他代码不变。</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;

    &lt;router-view class=&quot;aaa&quot;&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;hi&apos;,
  data () {
    return {
      msg: &apos;Hi, I am JSPang&apos;
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;

&lt;/style&gt;
</code></pre><h2 id="三、在components目录下新建两个组件模板-Hi1-vue-和-Hi2-vue"><a href="#三、在components目录下新建两个组件模板-Hi1-vue-和-Hi2-vue" class="headerlink" title="三、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue"></a>三、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue</h2><p>新建的模板和Hi.vue没有太多的差别，知识改变了data中message的值，也就是输出的结果不太一样了。</p>
<p>Hi1.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &apos;hi&apos;,
  data () {
    return {
      msg: &apos;Hi, I am Hi1!&apos;
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;

&lt;/style&gt;
</code></pre><p>Hi2.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &apos;hi&apos;,
  data () {
    return {
      msg: &apos;Hi, I am Hi2&apos;
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre><h2 id="四、修改router-index-js代码"><a href="#四、修改router-index-js代码" class="headerlink" title="四、修改router/index.js代码"></a>四、修改router/index.js代码</h2><p>我们现在导航有了，母模板和子模板也有了，只要改变我们的路由配置文件就可以了。子路由的写法是在原有的路由配置下加入children字段。</p>
<pre><code>children:[
{path:&apos;/&apos;,component:xxx},
{path:&apos;xx&apos;,component:xxx},
]
</code></pre><p>children字段后边跟的是个数组，数组里和其他配置路由基本相同，需要配置path和component。具体看一下这个子路由的配置写法。</p>
<pre><code>import Vue from &apos;vue&apos;   
import Router from &apos;vue-router&apos;  
import Hello from &apos;@/components/Hello&apos;  
import Hi from &apos;@/components/Hi&apos; 
import Hi1 from &apos;@/components/Hi1&apos; 
import Hi2 from &apos;@/components/Hi2&apos; 

Vue.use(Router) 

export default new Router({
  routes: [             
    {                    
      path: &apos;/&apos;,        
      name: &apos;Hello&apos;,     
      component: Hello   
    },{
      path:&apos;/hi&apos;,
      component:Hi,
      children:[
        {path:&apos;/&apos;,component:Hi},
        {path:&apos;hi1&apos;,component:Hi1},
        {path:&apos;hi2&apos;,component:Hi2},
      ]
    }
  ]
})
</code></pre><p>需要注意的是，在配置路由文件前，需要先用import引入Hi1和Hi2。</p>
<h1 id="第3节：vue-router如何参数传递"><a href="#第3节：vue-router如何参数传递" class="headerlink" title="第3节：vue-router如何参数传递"></a>第3节：vue-router如何参数传递</h1><p>开发中，参数的传递是个最基本的业务需求。通过URL地址来传递参数是一个形式，这节课我们就看看vue-router为我们提供了那些传递参数的功能。我们先想象一个基本需求，就是在我们点击导航菜单时，跳转页面上能显示出当前页面的路径，来告诉用户你想在所看的页面位置（类似于面包屑导航）。</p>
<h2 id="一、用name传递参数"><a href="#一、用name传递参数" class="headerlink" title="一、用name传递参数"></a>一、用name传递参数</h2><p>前两节课一直出现name的选项，但是我们都没有讲，这节课我们讲name的一种作用，传递参数。接着上节课的程序继续编写。</p>
<p>两步完成用name传值并显示在模板里：</p>
<ul>
<li><p>在路由文件src/router/index.js里配置name属性。</p>
<pre><code>routes: [
   {
     path: &apos;/&apos;,
     name: &apos;Hello&apos;,
     component: Hello
   }
]
</code></pre></li>
</ul>
<ul>
<li><p>模板里(src/App.vue)用$router.name的形势接收，比如直接在模板中显示：</p>
<pre><code>&lt;p&gt;{{ $route.name}}&lt;/p&gt;
</code></pre></li>
</ul>
<h2 id="二、通过-标签中的to传参"><a href="#二、通过-标签中的to传参" class="headerlink" title="二、通过 标签中的to传参"></a>二、通过<router-link> 标签中的to传参</router-link></h2><p>也许你也会觉的上边的传参很不正规，也不方便，其实我们多数传参是不用name进行传参的，我们用<router-link>标签中的to属性进行传参，需要您注意的是这里的to要进行一个绑定，写成:to。先来看一下这种传参方法的基本语法：</router-link></p>
<pre><code>&lt;router-link :to=&quot;{name:xxx,params:{key:value}}&quot;&gt;valueString&lt;/router-link&gt;
</code></pre><p>这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串.</p>
<ul>
<li>name：就是我们在路由配置文件中起的name值。</li>
</ul>
<ul>
<li>params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。</li>
<li>了解基本的语法后，我们改造一下我们的src/App.vue里的<router-link>标签,我们把hi1页面的<router-link>进行修改。</router-link></router-link></li>
</ul>
<pre><code>&lt;router-link :to=&quot;{name:&apos;hi1&apos;,params:{username:&apos;jspang&apos;}}&quot;&gt;Hi页面1&lt;/router-link&gt;
</code></pre><p>把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1.</p>
<pre><code>{path:&apos;/hi1&apos;,name:&apos;hi1&apos;,component:Hi1},
</code></pre><p>最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收.</p>
<pre><code>{{$route.params.username}}
</code></pre><h1 id="第4节：单页面多路由区域操作"><a href="#第4节：单页面多路由区域操作" class="headerlink" title="第4节：单页面多路由区域操作"></a>第4节：单页面多路由区域操作</h1><p>这节课我们讲“单页面多路由区域操作”，实际需求是这样的，在一个页面里我们有2个以上<router-view>区域，我们通过配置路由的js文件，来操作这些区域的内容。例如我们在src/App.vue里加上两个<router-view>标签。我们用vue-cli建立了新的项目，并打开了src目录下的App.vue文件，在<router-view>下面新写了两行<router-view>标签,并加入了些CSS样式。</router-view></router-view></router-view></router-view></p>
<pre><code>&lt;router-view &gt;&lt;/router-view&gt;
&lt;router-view name=&quot;left&quot; style=&quot;float:left;width:50%;background-color:#ccc;height:300px;&quot;&gt;&lt;/router-view&gt;
&lt;router-view name=&quot;right&quot; style=&quot;float:right;width:50%;background-color:#c0c;height:300px;&quot;&gt;&lt;/router-view&gt;
</code></pre><p>现在的页面中有了三个<router-view>标签，也就是说我们需要在路由里配置这三个区域，配置主要是在components字段里进行。</router-view></p>
<pre><code>import Vue from &apos;vue&apos;
import Router from &apos;vue-router&apos;
import Hello from &apos;@/components/Hello&apos;
import Hi1 from &apos;@/components/Hi1&apos;
import Hi2 from &apos;@/components/Hi2&apos;

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: &apos;/&apos;,
      components: {
        default:Hello,
        left:Hi1,
        right:Hi2
      }
    },{
      path: &apos;/Hi&apos;,
      components: {
        default:Hello,
        left:Hi2,
        right:Hi1
      }
    }

  ]
})
</code></pre><p>上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是’/Hi’.在两个路径下的components里面，我们对三个区域都定义了显示内容。</p>
<p>定义好后，我们需要在component文件夹下，新建Hi1.vue和Hi2.vue页面就可以了。</p>
<p>Hi1.vue</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{ msg }}&lt;/h2&gt; 
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;hi1&apos;,
  data () {
    return {
      msg: &apos;I am Hi1 page.&apos;
    }
  }
}
&lt;/script&gt;
</code></pre><p>Hi2.vue</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{ msg }}&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;hi2&apos;,
  data () {
    return {
      msg: &apos;I am Hi2 page.&apos;
    }
  }
}
&lt;/script&gt;
</code></pre><p>最后在App.vue中配置我们的<router-link>就可以了</router-link></p>
<pre><code>&lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; | 
&lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt; |
</code></pre><h1 id="第5节：vue-router-利用url传递参数"><a href="#第5节：vue-router-利用url传递参数" class="headerlink" title="第5节：vue-router 利用url传递参数"></a>第5节：vue-router 利用url传递参数</h1><p>我们在第3节虽然已经学会传递参数，但是我们这些老程序员的情怀还是利用url来传值，因为我们以前在前后端没有分开开发的时候，经常这样做。在实际开发也是有很多用URL传值的需求，比如我们在新闻列表中有很多新闻标题整齐的排列，我们需要点击每个新闻标题打开不同的新闻内容，这时在跳转路由时跟上新闻编号就十分实用。</p>
<h2 id="冒号的形式传递参数"><a href="#冒号的形式传递参数" class="headerlink" title=":冒号的形式传递参数"></a>:冒号的形式传递参数</h2><p>我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。</p>
<ul>
<li><p>在配置文件里以冒号的形式设置参数。我们在/src/router/index.js文件里配置路由。</p>
<pre><code>{
    path:&apos;/params/:newsId/:newsTitle&apos;,
     component:Params
}
</code></pre></li>
</ul>
<p>我们需要传递参数是新闻ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。</p>
<ul>
<li><p>在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{ msg }}&lt;/h2&gt;
        &lt;p&gt;新闻ID：{{ $route.params.newsId}}&lt;/p&gt;
        &lt;p&gt;新闻标题：{{ $route.params.newsTitle}}&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;params&apos;,
  data () {
    return {
      msg: &apos;params page&apos;
    }
  }
}
&lt;/script&gt;
</code></pre></li>
</ul>
<ul>
<li><p>在App.vue文件里加入我们的<router-view>标签。这时候我们可以直接利用url传值了。</router-view></p>
<pre><code>&lt;router-link to=&quot;/params/198/jspang website is very good&quot;&gt;params&lt;/router-link&gt; |
</code></pre></li>
</ul>
<p>我们已经实现了以url方式进行传值，这在实际开发中经常使用，必须完全了解。我希望你看完视频后或者学完文章后能多练习两边，并在实际项目中充分使用。</p>
<h2 id="正则表达式在URL传值中的应用"><a href="#正则表达式在URL传值中的应用" class="headerlink" title="正则表达式在URL传值中的应用"></a>正则表达式在URL传值中的应用</h2><p>上边的例子，我们传递了新闻编号，现在需求升级了，我们希望我们传递的新闻ID只能是数字的形式，这时候我们就需要在传递时有个基本的类型判断，vue是支持正则的。</p>
<p>加入正则需要在路由配置文件里（/src/router/index.js）以圆括号的形式加入。</p>
<pre><code>path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;,
</code></pre><p>加入了正则，我们再传递数字之外的其他参数，params.vue组件就没有办法接收到。</p>
<p>#第6节 ：vue-router 的重定向-redirect</p>
<p>开发中有时候我们虽然设置的路径不一致，但是我们希望跳转到同一个页面，或者说是打开同一个组件。这时候我们就用到了路由的重新定向redirect参数。</p>
<h2 id="redirect基本重定向"><a href="#redirect基本重定向" class="headerlink" title="redirect基本重定向"></a>redirect基本重定向</h2><p>我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。</p>
<pre><code>export default new Router({
  routes: [
    {
      path: &apos;/&apos;,
      component: Hello
    },{
      path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;,
      component:Params
    },{
      path:&apos;/goback&apos;,
      redirect:&apos;/&apos;
    }

  ]
})
</code></pre><p>这里我们设置了goback路由，但是它并没有配置任何component（组件），而是直接redirect到path:’/’下了，这就是一个简单的重新定向。</p>
<h2 id="重定向时传递参数"><a href="#重定向时传递参数" class="headerlink" title="重定向时传递参数"></a>重定向时传递参数</h2><p>我们已经学会了通过url来传递参数，那我们重定向时如果也需要传递参数怎么办？其实vue也已经为我们设置好了，我们只需要在ridirect后边的参数里复制重定向路径的path参数就可以了。可能你看的有点晕，我们来看一段代码：</p>
<pre><code>{
  path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;,
  component:Params
},{
  path:&apos;/goParams/:newsId(\\d+)/:newsTitle&apos;,
  redirect:&apos;/params/:newsId(\\d+)/:newsTitle&apos;
}
</code></pre><p>已经有了一个params路由配置，我们在设置一个goParams的路由重定向，并传递了参数。这时候我们的路由参数就可以传递给params.vue组件了。参数接收方法和正常的路由接收方法一样。</p>
<h1 id="第7节：alias别名的使用"><a href="#第7节：alias别名的使用" class="headerlink" title="第7节：alias别名的使用"></a>第7节：alias别名的使用</h1><p>上节学习了路由的重定向，我相信大家已经可以熟练使用redirect进行重定向了。使用alias别名的形式，我们也可以实现类似重定向的效果。</p>
<ul>
<li>1.首先我们在路由配置文件里（/src/router/index.js），给上节课的Home路径起一个别名，jspang。</li>
</ul>
<pre><code>{
    path: &apos;/hi1&apos;,
    component: Hi1,
    alias:&apos;/jspang&apos;
 }
</code></pre><ul>
<li>2.配置我们的<router-link>，起过别名之后，可以直接使用<router-link>标签里的to属性，进行重新定向。</router-link></router-link></li>
</ul>
<pre><code>&lt;router-link to=&quot;/jspang&quot;&gt;jspang&lt;/router-link&gt;
</code></pre><p><strong>redirect和alias的区别</strong></p>
<p>redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。</p>
<p>alias：URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了<router-view>中的内容。</router-view></p>
<h3 id="填个小坑："><a href="#填个小坑：" class="headerlink" title="填个小坑："></a>填个小坑：</h3><p>别名请不要用在path为’/’中，如下代码的别名是不起作用的。</p>
<pre><code>{
  path: &apos;/&apos;,
  component: Hello,
  alias:&apos;/home&apos;
}
</code></pre><p>在实际项目中我们遇到了这样的坑，开始以为是自己的代码写的有问题，找了两个小时作用。后来发现不是代码问题，只是vue不支持这样使用。我们犯过错误，踩过了坑，希望大家就不要踩了。</p>
<h1 id="第8节：路由的过渡动画"><a href="#第8节：路由的过渡动画" class="headerlink" title="第8节：路由的过渡动画"></a>第8节：路由的过渡动画</h1><p>在开发中有一种需求叫高端、大气、上档次。所以作为一个大前端有责任让你的程序开起来更酷炫。可以在页面切换时我们加入一些动画效果，提升我们程序的动效设计。这节课我们就学习一下路由的过渡动画效果制作</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a><transition>标签</transition></h2><p>想让路由有过渡动画，需要在<router-view>标签的外部添加<transition>标签，标签还需要一个name属性。</transition></router-view></p>
<pre><code>&lt;transition name=&quot;fade&quot;&gt;
  &lt;router-view &gt;&lt;/router-view&gt;
&lt;/transition&gt;
</code></pre><p>我们在/src/App.vue文件里添加了<transition>标签，并给标签起了一个名字叫fade。</transition></p>
<h2 id="css过渡类名："><a href="#css过渡类名：" class="headerlink" title="css过渡类名："></a>css过渡类名：</h2><p>组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名：</p>
<ul>
<li>fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。</li>
</ul>
<ul>
<li>fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。</li>
</ul>
<ul>
<li>fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。</li>
</ul>
<ul>
<li>fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。</li>
</ul>
<p>从上面四个类名可以看出，fade-enter-active和<br>fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。</p>
<p>那我们就在App.vue页面里加入四种CSS样式效果，并利用CSS3的transition属性控制动画的具体效果。代码如下：</p>
<pre><code>.fade-enter {
  opacity:0;
}
.fade-leave{
  opacity:1;
}
.fade-enter-active{
  transition:opacity .5s;
}
.fade-leave-active{
  opacity:0;
  transition:opacity .5s;
}
</code></pre><p>上边的代码设置了改变透明度的动画过渡效果，但是默认的mode模式in-out模式，这并不是我们想要的。下面我们学一下mode模式。</p>
<h2 id="过渡模式mode："><a href="#过渡模式mode：" class="headerlink" title="过渡模式mode："></a>过渡模式mode：</h2><ul>
<li>in-out:新元素先进入过渡，完成之后当前元素过渡离开。</li>
</ul>
<ul>
<li>out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。</li>
</ul>
<p>这节课只能算是一个简单的过渡入门，教会大家原理，如果想做出实用酷炫的过渡效果，你需要有较强的动画制作能力，我们下节课继续学习动画的知识。</p>
<h1 id="第9节：mode的设置和404页面的处理"><a href="#第9节：mode的设置和404页面的处理" class="headerlink" title="第9节：mode的设置和404页面的处理"></a>第9节：mode的设置和404页面的处理</h1><p>在学习过渡效果的时候，我们学了mode的设置，但是在路由的属性中还有一个mode。这节课我们就学习一下另一个mode模式和404页面的设置。</p>
<h2 id="mode的两个值"><a href="#mode的两个值" class="headerlink" title="mode的两个值"></a>mode的两个值</h2><ul>
<li>histroy:当你使用 history 模式时，URL 就像正常的 url，例如 <a href="http://jsapng.com/lms/，也好看！" target="_blank" rel="external">http://jsapng.com/lms/，也好看！</a></li>
</ul>
<ul>
<li>hash:默认’hash’值，但是hash看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。</li>
</ul>
<p>具体的效果我在视频中会有所掩饰，不理解的小伙伴可以到视频中进行查看。</p>
<h2 id="404页面的设置："><a href="#404页面的设置：" class="headerlink" title="404页面的设置："></a>404页面的设置：</h2><p>用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。vue-router也为我们提供了这样的机制.</p>
<ul>
<li>1.设置我们的路由配置文件（/src/router/index.js）：</li>
</ul>
<pre><code>{
   path:&apos;*&apos;,
   component:Error
}
</code></pre><p>这里的path:’*’就是找不到页面时的配置，component是我们新建的一个Error.vue的文件。</p>
<ul>
<li>2.新建404页面：</li>
</ul>
<p>在/src/components/文件夹下新建一个Error.vue的文件。简单输入一些有关错误页面的内容。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{ msg }}&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data () {
    return {
      msg: &apos;Error:404&apos;
    }
  }
}
&lt;/script&gt;
</code></pre><ul>
<li>3.我们在用<router-link>瞎写一个标签的路径。</router-link></li>
</ul>
<pre><code>&lt;router-link to=&quot;/bbbbbb&quot;&gt;我是瞎写的&lt;/router-link&gt; |
</code></pre><p>预览一下我们现在的结果，就已经实现404页面的效果。</p>
<h1 id="第10节：路由中的钩子"><a href="#第10节：路由中的钩子" class="headerlink" title="第10节：路由中的钩子"></a>第10节：路由中的钩子</h1><p>我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节课就介绍这两种钩子函数的写法。</p>
<h2 id="路由配置文件中的钩子函数"><a href="#路由配置文件中的钩子函数" class="headerlink" title="路由配置文件中的钩子函数"></a>路由配置文件中的钩子函数</h2><p>我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节课就介绍这两种钩子函数的写法。</p>
<h2 id="路由配置文件中的钩子函数-1"><a href="#路由配置文件中的钩子函数-1" class="headerlink" title="路由配置文件中的钩子函数"></a>路由配置文件中的钩子函数</h2><p>我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。先来看一段具体的代码：</p>
<pre><code>{
      path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;,
      component:Params,
      beforeEnter:(to,from,next)=&gt;{
        console.log(&apos;我进入了params模板&apos;);
        console.log(to);
        console.log(from);
        next();
},
</code></pre><p>我们在params路由里配置了bdforeEnter得钩子函数，函数我们采用了ES6的箭头函数，需要传递三个参数。我们并在箭头函数中打印了to和from函数。具体打印内容可以在控制台查看object。</p>
<p>三个参数：</p>
<ul>
<li>to:路由将要跳转的路径信息，信息是包含在对像里边的。</li>
</ul>
<ul>
<li>from:路径跳转前的路径信息，也是一个对象的形式。</li>
</ul>
<ul>
<li>next:路由的控制参数，常用的有next(true)和next(false)。</li>
</ul>
<h2 id="写在模板中的钩子函数"><a href="#写在模板中的钩子函数" class="headerlink" title="写在模板中的钩子函数"></a>写在模板中的钩子函数</h2><p>在配置文件中的钩子函数，只有一个钩子-beforeEnter，如果我们写在模板中就可以有两个钩子函数可以使用：</p>
<ul>
<li>beforeRouteEnter：在路由进入前的钩子函数。</li>
</ul>
<ul>
<li><p>beforeRouteLeave：在路由离开前的钩子函数。</p>
<pre><code>export default {
  name: &apos;params&apos;,
  data () {
    return {
      msg: &apos;params page&apos;
    }
  },
  beforeRouteEnter:(to,from,next)=&gt;{
    console.log(&quot;准备进入路由模板&quot;);
    next();
  },
  beforeRouteLeave: (to, from, next) =&gt; {
    console.log(&quot;准备离开路由模板&quot;);
    next();
  }
}
&lt;/script&gt;
</code></pre></li>
</ul>
<p>这是我们写在params.vue模板里的路由钩子函数。它可以监控到路由的进入和路由的离开，也可以轻易的读出to和from的值。</p>
<h1 id="第11节：编程式导航"><a href="#第11节：编程式导航" class="headerlink" title="第11节：编程式导航"></a>第11节：编程式导航</h1><p>这是这篇文章的最后一节，前10节课的导航都是用<router-link>标签或者直接操作地址栏的形式完成的，那如果在业务逻辑代码中需要跳转页面我们如何操作？这就是我们要说的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。</router-link></p>
<h2 id="this-router-go-1-和-this-router-go-1"><a href="#this-router-go-1-和-this-router-go-1" class="headerlink" title="this.$router.go(-1) 和 this.$router.go(1)"></a>this.$router.go(-1) 和 this.$router.go(1)</h2><p>这两个编程式导航的意思是后退和前进，功能跟我们浏览器上的后退和前进按钮一样，这在业务逻辑中经常用到。比如条件不满足时，我们需要后退。</p>
<p>router.go(-1)代表着后退，我们可以让我们的导航进行后退，并且我们的地址栏也是有所变化的。</p>
<ul>
<li><p>1.我们先在app.vue文件里加入一个按钮，按钮并绑定一个goback( )方法。</p>
<pre><code>&lt;button @click=&quot;goback&quot;&gt;后退&lt;/button&gt;
</code></pre></li>
<li><p>2.在我们的script模块中写入goback()方法，并使用this.$router.go(-1),进行后退操作。</p>
<pre><code>&lt;script&gt;
export default {
  name: &apos;app&apos;,
  methods:{
    goback(){
      this.$router.go(-1);
    }
  }
}
&lt;/script&gt;
</code></pre></li>
</ul>
<p>打开浏览器进行预览，这时我们的后退按钮就可以向以前的网页一样后退了。</p>
<p>router.go(1):代表着前进，用法和后退一样，我在这里就不重复码字了（码字辛苦希望大家理解）。</p>
<h2 id="this-router-push-‘-xxx-‘"><a href="#this-router-push-‘-xxx-‘" class="headerlink" title="this.$router.push(‘/xxx ‘)"></a>this.$router.push(‘/xxx ‘)</h2><p>这个编程式导航都作用就是跳转，比如我们判断用户名和密码正确时，需要跳转到用户中心页面或者首页，都用到这个编程的方法来操作路由。</p>
<p>我们设置一个按钮，点击按钮后回到站点首页。</p>
<ul>
<li><p>1.先编写一个按钮，在按钮上绑定goHome( )方法。</p>
<pre><code>&lt;button @click=&quot;goHome&quot;&gt;回到首页&lt;/button&gt;
</code></pre></li>
</ul>
<ul>
<li><p>2.在<script>模块里加入goHome方法，并用this.$router.push(‘/’)导航到首页</p>
<pre><code>export default {
  name: &apos;app&apos;,
  methods:{
    goback(){
      this.$router.go(-1);
    },
    goHome(){
      this.$router.push(&apos;/&apos;);
    }
  }
}
</code></pre></li>
</ul>
</script></p></li></ul>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/vue-cli/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/vue-cli/" itemprop="url">vue-cli</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:16:28+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、Vue-cli，开始吧骚年"><a href="#一、Vue-cli，开始吧骚年" class="headerlink" title="一、Vue-cli，开始吧骚年"></a>一、Vue-cli，开始吧骚年</h1><h3 id="一、安装vue-cli"><a href="#一、安装vue-cli" class="headerlink" title="一、安装vue-cli"></a>一、安装vue-cli</h3><p>安装vue-cli的前提是你已经安装了npm，安装npm你可以直接下载node的安装包进行安装。你可以在命令行工具里输入npm -v  检测你是否安装了npm和版本情况。出现版本号说明你已经安装了npm和node，我这里的npm版本为3.10.10。如果该命令不可以使用，需要安装node软件包，根据你的系统版本选择下载安装就可以了。</p>
<p>下载地址：<a href="http://nodejs.cn/download/" target="_blank" rel="external">http://nodejs.cn/download/</a></p>
<p>npm没有问题，接下来我们可以用npm 命令安装vue-cli了，在命令行输入下面的命令：</p>
<pre><code>npm install vue-cli -g
</code></pre><p>-g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue -V来进行查看 vue-cli的版本号。注意这里的V是大写的。我这里版本号是2.8.1.</p>
<p>如果vue -V的命令管用了，说明已经顺利的把vue-cli安装到我们的计算机里了。</p>
<h3 id="二、初始化项目"><a href="#二、初始化项目" class="headerlink" title="二、初始化项目"></a>二、初始化项目</h3><p>我们用vue init命令来初始化项目，具体看一下这条命令的使用方法。</p>
<pre><code>$ vue init &lt;template-name&gt; &lt;project-name&gt;
</code></pre><p>init：表示我要用vue-cli来初始化项目</p>
<template-name>：表示模板名称，vue-cli官方为我们提供了5种模板，<br><br><br><br>- webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。<br><br><br><br>- webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。<br><br><br><br>- browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。<br><br><br><br>- browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。<br><br>simple-一个最简单的单页应用模板。<br><br><project-name>：标识项目名称，这个你可以根据自己的项目来起名字。<br><br>在实际开发中，一般我们都会使用webpack这个模板，那我们这里也安装这个模板，在命令行输入以下命令：<br><br><br>    vue init webpack vuecliTest<br><br>输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。<br><br><br><br>- Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitest<br><br><br>- Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。<br><br><br>- Author：作者，如果你有配置git的作者，他会读取。<br><br><br>- Install  vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y<br><br><br>- Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。<br><br><br>- setup unit tests with  Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。<br><br><br>- Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。<br><br><br>命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。<br><br><br><br>- 1、cd vuecliTest  进入我们的vue项目目录。<br><br><br><br>- 2、npm install  安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。<br><br><br><br>- 3、npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。<br><br># 二、Vue-cli项目结构讲解<br><br>vue-cli脚手架工具就是为我们搭建了开发所需要的环境，为我们省去了很多精力。有必要对这个环境进行熟悉，我们就从项目的结构讲起。<br><br>Ps：由于版本实时更新和你选择安装的不同（这里列出的是模板为webpack的目录结构），所以你看到的有可能和下边的有所差别。<br><br><br>    .<br>    |– build                            // 项目构建(webpack)相关代码<br>    |   |– build.js                     // 生产环境构建代码<br>    |   |– check-version.js             // 检查node、npm等版本<br>    |   |– dev-client.js                // 热重载相关<br>    |   |– dev-server.js                // 构建本地服务器<br>    |   |– utils.js                     // 构建工具相关<br>    |   |– webpack.base.conf.js         // webpack基础配置<br>    |   |– webpack.dev.conf.js          // webpack开发环境配置<br>    |   |– webpack.prod.conf.js         // webpack生产环境配置<br>    |– config                           // 项目开发环境配置<br>    |   |– dev.env.js                   // 开发环境变量<br>    |   |– index.js                     // 项目一些配置变量<br>    |   |– prod.env.js                  // 生产环境变量<br>    |   |– test.env.js                  // 测试环境变量<br>    |– src                              // 源码目录<br>    |   |– components                     // vue公共组件<br>    |   |– store                          // vuex的状态管理<br>    |   |– App.vue                        // 页面入口文件<br>    |   |– main.js                        // 程序入口文件，加载各种公共组件<br>    |– static                           // 静态文件，比如一些图片，json数据等<br>    |   |– data                           // 群聊分析得到的数据用于数据可视化<br>    |– .babelrc                         // ES6语法编译配置<br>    |– .editorconfig                    // 定义代码格式<br>    |– .gitignore                       // git上传需要忽略的文件格式<br>    |– README.md                        // 项目说明<br>    |– favicon.ico<br>    |– index.html                       // 入口页面<br>    |– package.json                     // 项目基本信息<br>    .<br><br><strong>重要文件讲解：</strong><br><br>## package.json<br>package.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。<br><br>package.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js  .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。<br><br>      “scripts”: {<br>        “dev”: “node build/dev-server.js”,<br>        “build”: “node build/build.js”<br>      },<br><br>dependencies字段和devDependencies字段<br><br>dependencies字段指项目运行时所依赖的模块；<br>devDependencies字段指定了项目开发时所依赖的模块；<br>在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。package.json还有很多相关配置，如果你想全面了解，可以专门去百度学习一下。<br><br>## webpack配置相关<br><br>我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。<br><br>## dev-server.js<br><br>    // 检查 Node 和 npm 版本<br>    require(‘./check-versions’)()<br><br>    // 获取 config/index.js 的默认配置<br>    var config = require(‘../config’)<br><br>    // 如果 Node 的环境无法判断当前是 dev / product 环境<br>    // 使用 config.dev.env.NODE_ENV 作为当前的环境<br><br>    if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)<br><br>    // 使用 NodeJS 自带的文件路径工具<br>    var path = require(‘path’)<br><br>    // 使用 express<br>    var express = require(‘express’)<br><br>    // 使用 webpack<br>    var webpack = require(‘webpack’)<br><br>    // 一个可以强制打开浏览器并跳转到指定 url 的插件<br>    var opn = require(‘opn’)<br><br>    // 使用 proxyTable<br>    var proxyMiddleware = require(‘http-proxy-middleware’)<br><br>    // 使用 dev 环境的 webpack 配置<br>    var webpackConfig = require(‘./webpack.dev.conf’)<br><br>    // default port where dev server listens for incoming traffic<br><br>    // 如果没有指定运行端口，使用 config.dev.port 作为运行端口<br>    var port = process.env.PORT || config.dev.port<br><br>    // Define HTTP proxies to your custom API backend<br>    // <a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="external">https://github.com/chimurai/http-proxy-middleware</a><br><br>    // 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置<br>    var proxyTable = config.dev.proxyTable<br><br>    // 使用 express 启动一个服务<br>    var app = express()<br><br>    // 启动 webpack 进行编译<br>    var compiler = webpack(webpackConfig)<br><br>    // 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中<br>    var devMiddleware = require(‘webpack-dev-middleware’)(compiler, {<br>      publicPath: webpackConfig.output.publicPath,<br>      stats: {<br>        colors: true,<br>        chunks: false<br>      }<br>    })<br><br>    // 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload<br>    var hotMiddleware = require(‘webpack-hot-middleware’)(compiler)<br>    // force page reload when html-webpack-plugin template changes<br>    compiler.plugin(‘compilation’, function (compilation) {<br>      compilation.plugin(‘html-webpack-plugin-after-emit’, function (data, cb) {<br>        hotMiddleware.publish({ action: ‘reload’ })<br>        cb()<br>      })<br>    })<br><br>    // proxy api requests<br>    // 将 proxyTable 中的请求配置挂在到启动的 express 服务上<br>    Object.keys(proxyTable).forEach(function (context) {<br>      var options = proxyTable[context]<br>      if (typeof options === ‘string’) {<br>        options = { target: options }<br>      }<br>      app.use(proxyMiddleware(context, options))<br>    })<br><br>    // handle fallback for HTML5 history API<br>    // 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址<br>    app.use(require(‘connect-history-api-fallback’)())<br><br>    // serve webpack bundle output<br>    // 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上<br>    app.use(devMiddleware)<br><br>    // enable hot-reload and state-preserving<br>    // compilation error display<br>    // 将 Hot-reload 挂在到 express 服务上<br>    app.use(hotMiddleware)<br><br>    // serve pure static assets<br>    // 拼接 static 文件夹的静态资源路径<br>    var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)<br>    // 为静态资源提供响应服务<br>    app.use(staticPath, express.static(‘./static’))<br><br>    // 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露<br>    module.exports = app.listen(port, function (err) {<br>      if (err) {<br>        console.log(err)<br>        return<br>      }<br>      var uri = ‘<a href="http://localhost" target="_blank" rel="external">http://localhost</a>:’ + port<br>      console.log(‘Listening at ‘ + uri + ‘\n’)<br><br>      // when env is testing, don’t need open it<br>      // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址<br>      if (process.env.NODE_ENV !== ‘testing’) {<br>        opn(uri)<br>      }<br>    })<br><br>## webpack.base.confg.js   webpack的基础配置文件<br><br>    …<br>    …<br>    module.export = {<br>        // 编译入口文件<br>        entry: {},<br>        // 编译输出路径<br>        output: {},<br>        // 一些解决方案配置<br>        resolve: {},<br>        resolveLoader: {},<br>        module: {<br>            // 各种不同类型文件加载器配置<br>            loaders: {<br>            …<br>            …<br>            // js文件用babel转码<br>            {<br>                test: /.js$/,<br>                loader: ‘babel’,<br>                include: projectRoot,<br>                // 哪些文件不需要转码<br>                exclude: /node_modules/<br>            },<br>            …<br>            …<br>            }<br>        },<br>        // vue文件一些相关配置<br>        vue: {}<br>    }<br><br>## .babelrc<br>Babel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。<br><br>    {<br>      //设定转码规则<br>      “presets”: [<br>        [“env”, { “modules”: false }],<br>        “stage-2”<br>      ],<br>      //转码用的插件<br>      “plugins”: [“transform-runtime”],<br>      “comments”: false,<br>      //对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作<br>      “env”: {<br>        “test”: {<br>          “presets”: [“env”, “stage-2”],<br>          “plugins”: [ “istanbul” ]<br>        }<br>      }<br>    }<br><br>## .editorconfig<br><br>该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。<br><br>root = true<br><br>[<em>]    // 对所有文件应用下面的规则<br>charset = utf-8                    // 编码规则用utf-8<br>indent_style = space               // 缩进用空格<br>indent_size = 2                    // 缩进数量为2个空格<br>end_of_line = lf                   // 换行符格式<br>insert_final_newline = true        // 是否在文件的最后插入一个空行<br>trim_trailing_whitespace = true    // 是否删除行尾的空格<br><br># 三、解读Vue-cli的模板<br><br>### 一、npm run build 命令<br><br>有小伙伴问我，如何把写好的Vue网页放到服务器上，那我就在这里讲解一下，主要的命令就是要用到npm run build 命令。我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。<br><br><strong>package.json的scripts 字段：</strong><br><br><br>      “scripts”: {<br>        “dev”: “node build/dev-server.js”,<br>        “build”: “node build/build.js”<br>      },<br><br>在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。<br><br>dist文件夹下目录包括：<br><br><br><br>- index.html 主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。<br><br><br>- static 静态资源文件夹：里边js、CSS和一些图片。<br><br>### 二、main.js文件解读<br><br>main.js是整个项目的入口文件,在src文件夹下：<br><br><br>    import Vue from ‘vue’<br>    import App from ‘./App’<br>    import router from ‘./router’<br><br>    Vue.config.productionTip = false   //生产环境提示，这里设置成了false<br><br>    /</em> eslint-disable no-new */<br>    new Vue({<br>      el: ‘#app’,<br>      router,<br>      template: ‘<app>‘,<br>      components: { App }<br>    })<br><br>通过代码可以看出这里引进了App的组件和<app>的模板，它是通过 import App from ‘./App’这句代码引入的。  我们找到App.vue文件，打开查看。<br><br>### 三、App.vue文件:<br><br><br>    <template><br>      <div id="app"><br>        <img src="./assets/logo.png"><br>        <router-view></router-view><br>      </div><br>    </template>

<pre><code>&lt;script&gt;
export default {
  name: &apos;app&apos;
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
&lt;/style&gt;
</code></pre><p><strong>app.vue文件我们可以分成三部分解读，</strong></p>
<template></template>标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和<router-view></router-view>标签，<router-view>标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲Vue-router。<br><br><script></script>标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。<br><br><style></style>标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用<style scoped></style>来声明这些css样式只在本模板中起作用。<br><br>### 四、router/index.js 路由文件<br><br>引文在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。下篇文章我们就开始讲Vue-router。<br><br>    import Vue from ‘vue’<br>    import Router from ‘vue-router’<br>    import Hello from ‘@/components/Hello’<br><br>    Vue.use(Router)<br><br>    export default new Router({<br>      routes: [<br>        {<br>          path: ‘/‘,<br>          name: ‘Hello’,<br>          component: Hello<br>        }<br>      ]<br>    })<br><br>我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。<br><br>### 五、Hello.vue文件解读：<br><br>这个文件就是我们在第一节课看到的页面文件了。也是分为<template><script><style>三个部分，以后我们大部分的工作都是写这些.vue结尾的文件。现在我们可以试着改一些内容，然后预览一下。<br><br>    <template><br>      <div class="hello"><br>        <h1></h1><br>        <h2>Essential Links</h2><br>        <ul><br>          <li><a href="https://vuejs.org" target="_blank">Core Docs</a></li><br>          <li><a href="https://forum.vuejs.org" target="_blank">Forum</a></li><br>          <li><a href="https://gitter.im/vuejs/vue" target="_blank">Gitter Chat</a></li><br>          <li><a href="https://twitter.com/vuejs" target="_blank">Twitter</a></li><br>          <br><br>          <li><a href="http://vuejs-templates.github.io/webpack/" target="_blank">Docs for This Template</a></li><br>        </ul><br>        <h2>Ecosystem</h2><br>        <ul><br>          <li><a href="http://router.vuejs.org/" target="_blank">vue-router</a></li><br>          <li><a href="http://vuex.vuejs.org/" target="_blank">vuex</a></li><br>          <li><a href="http://vue-loader.vuejs.org/" target="_blank">vue-loader</a></li><br>          <li><a href="https://github.com/vuejs/awesome-vue" target="_blank">awesome-vue</a></li><br>        </ul><br>      </div><br>    </template>

<pre><code>&lt;script&gt;
export default {
  name: &apos;hello&apos;,
  data () {
    return {
      msg: &apos;Welcome to Your Vue.js App&apos;
    }
  }
}
&lt;/script&gt;

&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;
&lt;style scoped&gt;
h1, h2 {
  font-weight: normal;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  display: inline-block;
  margin: 0 10px;
}

a {
  color: #42b983;
}
&lt;/style&gt;
</code></pre></script></template></router-view></app></app></project-name></template-name>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/vue-4-实例和内置组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/vue-4-实例和内置组件/" itemprop="url">vue(4) 实例和内置组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:14:34+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>实例就是在构造器外部操作构造器内部的属性选项或者方法，就叫做实例？实例的作用就是给原生的或者其他javascript框架一个融合的接口或者说是机会，让Vue和其他框架一起使用。</p>
<h1 id="1-实例入门-实例属性"><a href="#1-实例入门-实例属性" class="headerlink" title="1.实例入门-实例属性"></a>1.实例入门-实例属性</h1><h1 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2.实例方法"></a>2.实例方法</h1><h3 id="1-mount方法"><a href="#1-mount方法" class="headerlink" title="1.$mount方法"></a>1.$mount方法</h3><p>$mount方法是用来挂载我们的扩展的</p>
<h3 id="2-destroy-卸载方法"><a href="#2-destroy-卸载方法" class="headerlink" title="2.$destroy() 卸载方法"></a>2.$destroy() 卸载方法</h3><p>用$destroy()进行卸载。</p>
<h3 id="3-forceUpdate-更新方法"><a href="#3-forceUpdate-更新方法" class="headerlink" title="3.$forceUpdate() 更新方法"></a>3.$forceUpdate() 更新方法</h3><h3 id="4-nextTick-数据修改方法"><a href="#4-nextTick-数据修改方法" class="headerlink" title="4.$nextTick() 数据修改方法"></a>4.$nextTick() 数据修改方法</h3><p>当Vue构造器里的data值被修改完成后会调用这个方法，也相当于一个钩子函数吧，和构造器里的updated生命周期很像。</p>
<h1 id="3-实例事件"><a href="#3-实例事件" class="headerlink" title="3.实例事件"></a>3.实例事件</h1><p>实例事件就是在构造器外部写一个调用构造器内部的方法。这样写的好处是可以通过这种写法在构造器外部调用构造器内部的数据。</p>
<h3 id="1-on-在构造器外部添加事件。"><a href="#1-on-在构造器外部添加事件。" class="headerlink" title="1.$on  在构造器外部添加事件。"></a>1.$on  在构造器外部添加事件。</h3><h3 id="2-once执行一次的事件"><a href="#2-once执行一次的事件" class="headerlink" title="2.$once执行一次的事件"></a>2.$once执行一次的事件</h3><h3 id="3-off关闭事件"><a href="#3-off关闭事件" class="headerlink" title="3.$off关闭事件"></a>3.$off关闭事件</h3><h1 id="4-内置组件-slot讲解"><a href="#4-内置组件-slot讲解" class="headerlink" title="4.内置组件 -slot讲解"></a>4.内置组件 -slot讲解</h1><p>slot是标签的内容扩展，也就是说你用slot就可以在自定义组件时传递给组件内容，组件接收内容并输出。</p>
<h3 id="slot的使用需要两步："><a href="#slot的使用需要两步：" class="headerlink" title="slot的使用需要两步："></a>slot的使用需要两步：</h3><ol>
<li>在HTML的组件中用slot属性传递值。</li>
<li>在组件模板中用<slot></slot>标签接收值。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/vue-3-构造器里的选项/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/vue-3-构造器里的选项/" itemprop="url">vue(3) 构造器里的选项</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:14:13+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-propsData-Option-全局扩展的数据传递"><a href="#1-propsData-Option-全局扩展的数据传递" class="headerlink" title="1.propsData Option  全局扩展的数据传递"></a>1.propsData Option  全局扩展的数据传递</h1><p>他用在全局扩展时进行传递数据。</p>
<p>总结：propsData在实际开发中我们使用的并不多，我们在后边会学到Vuex的应用，他的作用就是在单页应用中保持状态和数据的。</p>
<h1 id="2-computed-Option-计算选项"><a href="#2-computed-Option-计算选项" class="headerlink" title="2.computed Option  计算选项"></a>2.computed Option  计算选项</h1><p>computed 的作用主要是对原数据进行改造输出。改造输出：包括格式的编辑，大小写转换，顺序重排，添加符号。。。</p>
<h1 id="3-Methods-Option-方法选项"><a href="#3-Methods-Option-方法选项" class="headerlink" title="3.Methods Option  方法选项"></a>3.Methods Option  方法选项</h1><h3 id="1-methods中参数的传递"><a href="#1-methods中参数的传递" class="headerlink" title="1.methods中参数的传递"></a>1.methods中参数的传递</h3><h3 id="2-methods中的-event参数"><a href="#2-methods中的-event参数" class="headerlink" title="2.methods中的$event参数"></a>2.methods中的$event参数</h3><p>传递的$event参数都是关于你点击鼠标的一些事件和属性。</p>
<h3 id="3-native-给组件绑定构造器里的原生事件。"><a href="#3-native-给组件绑定构造器里的原生事件。" class="headerlink" title="3.native  给组件绑定构造器里的原生事件。"></a>3.native  给组件绑定构造器里的原生事件。</h3><p>在实际开发中经常需要把某个按钮封装成组件，然后反复使用，如何让组件调用构造器里的方法，而不是组件里的方法。就需要用到我们的.native修饰器了。</p>
<h3 id="4-作用域外部调用构造器里的方法"><a href="#4-作用域外部调用构造器里的方法" class="headerlink" title="4.作用域外部调用构造器里的方法"></a>4.作用域外部调用构造器里的方法</h3><p>这种不经常使用，如果你出现了这种情况，说明你的代码组织不够好。</p>
<h1 id="4-Watch-选项-监控数据"><a href="#4-Watch-选项-监控数据" class="headerlink" title="4.Watch 选项 监控数据"></a>4.Watch 选项 监控数据</h1><p>数据变化的监控经常使用</p>
<h1 id="5-Mixins-混入选项操作"><a href="#5-Mixins-混入选项操作" class="headerlink" title="5.Mixins 混入选项操作"></a>5.Mixins 混入选项操作</h1><p>Mixins一般有两种用途：</p>
<p>1、在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。</p>
<p>2、很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。</p>
<h3 id="1-mixins的调用顺序"><a href="#1-mixins的调用顺序" class="headerlink" title="1.mixins的调用顺序"></a>1.mixins的调用顺序</h3><p>从执行的先后顺序来说，都是混入的先执行，然后构造器里的再执行，需要注意的是，这并不是方法的覆盖，而是被执行了两边。</p>
<p>PS：当混入方法和构造器的方法重名时，混入的方法无法展现，也就是不起作用。</p>
<h3 id="2-全局API混入方式"><a href="#2-全局API混入方式" class="headerlink" title="2.全局API混入方式"></a>2.全局API混入方式</h3><p>我们也可以定义全局的混入，这样在需要这段代码的地方直接引入js，就可以拥有这个功能了。</p>
<p>PS：全局混入的执行顺序要前于混入和构造器里的方法。</p>
<h1 id="6-Extends-Option-扩展选项"><a href="#6-Extends-Option-扩展选项" class="headerlink" title="6.Extends Option  扩展选项"></a>6.Extends Option  扩展选项</h1><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>通过外部增加对象的形式，对构造器进行扩展。它和我们上节课讲的混入非常的类似。</p>
<h3 id="2-delimiters-选项"><a href="#2-delimiters-选项" class="headerlink" title="2.delimiters 选项"></a>2.delimiters 选项</h3><p>elimiters的作用是改变我们插值的符号。Vue默认的插值是双大括号。但有时我们会有需求更改这个插值的形式。</p>
<pre><code>delimiters:[&apos;${&apos;,&apos;}&apos;]
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/vue-2-全局API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/vue-2-全局API/" itemprop="url">vue(2) 全局API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:13:56+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Vue-directive-自定义指令"><a href="#1-Vue-directive-自定义指令" class="headerlink" title="1.Vue.directive 自定义指令"></a>1.Vue.directive 自定义指令</h1><h3 id="什么是全局API？"><a href="#什么是全局API？" class="headerlink" title="什么是全局API？"></a>什么是全局API？</h3><p>在构造器外部用Vue提供给我们的API函数来定义新的功能。</p>
<h3 id="自定义指令中传递的三个参数"><a href="#自定义指令中传递的三个参数" class="headerlink" title="自定义指令中传递的三个参数"></a>自定义指令中传递的三个参数</h3><p>el: 指令所绑定的元素，可以用来直接操作DOM。</p>
<p>binding:  一个对象，包含指令的很多信息。</p>
<p>vnode: Vue编译生成的虚拟节点。</p>
<h3 id="自定义指令的生命周期"><a href="#自定义指令的生命周期" class="headerlink" title="自定义指令的生命周期"></a>自定义指令的生命周期</h3><p>自定义指令有五个生命周期（也叫钩子函数），分别是 bind,inserted,update,componentUpdated,unbind</p>
<ol>
<li>bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。</li>
<li>inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。</li>
<li>update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</li>
<li>componentUpdated:被绑定元素所在模板完成一次更新周期时调用。<br>unbind:只调用一次，指令与元素解绑时调用。</li>
</ol>
<h1 id="2-Vue-extend构造器的延伸"><a href="#2-Vue-extend构造器的延伸" class="headerlink" title="2.Vue.extend构造器的延伸"></a>2.Vue.extend构造器的延伸</h1><h3 id="什么是Vue-extend？"><a href="#什么是Vue-extend？" class="headerlink" title="什么是Vue.extend？"></a>什么是Vue.extend？</h3><p>以简单理解为当在模板中遇到该组件名称作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂载到自定义元素上。</p>
<h1 id="3-Vue-set全局操作"><a href="#3-Vue-set全局操作" class="headerlink" title="3.Vue.set全局操作"></a>3.Vue.set全局操作</h1><p>就是在构造器外部操作构造器内部的数据、属性或者方法。</p>
<h3 id="引用构造器外部数据"><a href="#引用构造器外部数据" class="headerlink" title="引用构造器外部数据"></a>引用构造器外部数据</h3><p>什么是外部数据，就是不在Vue构造器里里的data处声明，而是在构造器外部声明，然后在data处引用就可以了。</p>
<h3 id="为什么要有Vue-set的存在"><a href="#为什么要有Vue-set的存在" class="headerlink" title="为什么要有Vue.set的存在?"></a>为什么要有Vue.set的存在?</h3><p>由于Javascript的限制，Vue不能自动检测以下变动的数组。</p>
<p>*当你利用索引直接设置一个项时，vue不会为我们自动更新。</p>
<p>*当你修改数组的长度时，vue不会为我们自动更新。</p>
<h1 id="4-Vue的生命周期（钩子函数）"><a href="#4-Vue的生命周期（钩子函数）" class="headerlink" title="4.Vue的生命周期（钩子函数）"></a>4.Vue的生命周期（钩子函数）</h1><p><img src="http://oncweb6po.bkt.clouddn.com/vue-lifecycle.png" alt=""></p>
<h1 id="5-Template-制作模版"><a href="#5-Template-制作模版" class="headerlink" title="5.Template 制作模版"></a>5.Template 制作模版</h1><h3 id="1-直接写在选项里的模板"><a href="#1-直接写在选项里的模板" class="headerlink" title="1.直接写在选项里的模板"></a>1.直接写在选项里的模板</h3><p>直接在构造器里的template选项后边编写。这种写法比较直观，但是如果模板html代码太多，不建议这么写。</p>
<pre><code> var app=new Vue({
     el:&apos;#app&apos;,
     data:{
         message:&apos;hello Vue!&apos;
      },
     template:`
        &lt;h1 style=&quot;color:red&quot;&gt;我是选项模板&lt;/h1&gt;
     `
})
</code></pre><h3 id="2-写在标签里的模板"><a href="#2-写在标签里的模板" class="headerlink" title="2.写在标签里的模板"></a>2.写在<template>标签里的模板</template></h3><p>这种写法更像是在写HTML代码，就算不会写Vue的人，也可以制作页面</p>
<pre><code>&lt;template id=&quot;demo2&quot;&gt;
         &lt;h2 style=&quot;color:red&quot;&gt;我是template标签模板&lt;/h2&gt;
&lt;/template&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
        el:&apos;#app&apos;,
        data:{
            message:&apos;hello Vue!&apos;
        },
        template:&apos;#demo2&apos;
    })
&lt;/script&gt;
</code></pre><h3 id="3-写在标签里的模板"><a href="#3-写在标签里的模板" class="headerlink" title="3.写在标签里的模板"></a>3.写在<script\>标签里的模板</script\></h3><p>这种写模板的方法，可以让模板文件从外部引入。</p>
<pre><code>&lt;script type=&quot;x-template&quot; id=&quot;demo3&quot;&gt;
    &lt;h2 style=&quot;color:red&quot;&gt;我是script标签模板&lt;/h2&gt;
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
        el:&apos;#app&apos;,
        data:{
            message:&apos;hello Vue!&apos;
        },
        template:&apos;#demo3&apos;
    })
&lt;/script&gt;
</code></pre><h1 id="6-Component-初识组件"><a href="#6-Component-初识组件" class="headerlink" title="6.Component 初识组件"></a>6.Component 初识组件</h1><p>组件就是制作自定义的标签，这些标签在HTML中是没有的。</p>
<h3 id="1-全局化注册组件"><a href="#1-全局化注册组件" class="headerlink" title="1.全局化注册组件"></a>1.全局化注册组件</h3><p>全局化就是在构造器的外部用Vue.component来注册</p>
<h3 id="2-局部注册组件"><a href="#2-局部注册组件" class="headerlink" title="2.局部注册组件"></a>2.局部注册组件</h3><p>部注册组件和全局注册组件是向对应的，局部注册的组件只能在组件注册的作用域里进行使用，其他作用域使用无效。</p>
<p>但是你需要注意的是，构造器里的components 是加s的，而全局注册是不加s的。</p>
<h3 id="3-组件和指令的区别"><a href="#3-组件和指令的区别" class="headerlink" title="3.组件和指令的区别"></a>3.组件和指令的区别</h3><p>组件注册的是一个标签，而指令注册的是已有标签里的一个属性。</p>
<h1 id="7-Component-组件props-属性设置"><a href="#7-Component-组件props-属性设置" class="headerlink" title="7.Component 组件props 属性设置"></a>7.Component 组件props 属性设置</h1><p>props选项就是设置和获取标签上的属性值的</p>
<h3 id="1-定义属性并获取属性值"><a href="#1-定义属性并获取属性值" class="headerlink" title="1.定义属性并获取属性值"></a>1.定义属性并获取属性值</h3><p>定义属性我们需要用props选项，加上数组形式的属性名称，例如：props:[‘here’]。在组件的模板里读出属性值只需要用插值的形式，例如.</p>
<h3 id="2-属性中带’-‘的处理方式"><a href="#2-属性中带’-‘的处理方式" class="headerlink" title="2.属性中带’-‘的处理方式"></a>2.属性中带’-‘的处理方式</h3><p>小驼峰式写法</p>
<h3 id="3-在构造器里向组件中传值"><a href="#3-在构造器里向组件中传值" class="headerlink" title="3.在构造器里向组件中传值"></a>3.在构造器里向组件中传值</h3><p>把构造器中data的值传递给组件，我们只要进行绑定就可以了。</p>
<h1 id="8-Component-父子组件关系"><a href="#8-Component-父子组件关系" class="headerlink" title="8.Component 父子组件关系"></a>8.Component 父子组件关系</h1><p>在实际开发中我们经常会遇到在一个自定义组件中要使用其他自定义组件，这就需要一个父子组件关系。</p>
<h3 id="1-构造器外部写局部注册组件"><a href="#1-构造器外部写局部注册组件" class="headerlink" title="1.构造器外部写局部注册组件"></a>1.构造器外部写局部注册组件</h3><h3 id="2-父子组件的嵌套"><a href="#2-父子组件的嵌套" class="headerlink" title="2.父子组件的嵌套"></a>2.父子组件的嵌套</h3><h1 id="9-Component-标签"><a href="#9-Component-标签" class="headerlink" title="9.Component 标签"></a>9.Component 标签</h1><p><component></component>标签是Vue框架自定义的标签，它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/person.jpg"
               alt="ZhangWei2222" />
          <p class="site-author-name" itemprop="name">ZhangWei2222</p>
           
              <p class="site-description motion-element" itemprop="description">Dream high</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangWei2222</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
