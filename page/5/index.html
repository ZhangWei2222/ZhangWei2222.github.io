<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="Dream high">
<meta property="og:type" content="website">
<meta property="og:title" content="ZhangWei2222">
<meta property="og:url" content="http://super-wei.xyz/page/5/index.html">
<meta property="og:site_name" content="ZhangWei2222">
<meta property="og:description" content="Dream high">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhangWei2222">
<meta name="twitter:description" content="Dream high">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://super-wei.xyz/page/5/"/>





  <title>ZhangWei2222</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhangWei2222</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/jquery-三-事件篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/jquery-三-事件篇/" itemprop="url">jquery(三)事件篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:26:18+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-jQuery鼠标事件之click与dblclick事件"><a href="#1-jQuery鼠标事件之click与dblclick事件" class="headerlink" title="1.jQuery鼠标事件之click与dblclick事件"></a>1.jQuery鼠标事件之click与dblclick事件</h1><p>前者单击，后者双击</p>
<h1 id="2-jQuery鼠标事件之mousedown与mouseup事件"><a href="#2-jQuery鼠标事件之mousedown与mouseup事件" class="headerlink" title="2.jQuery鼠标事件之mousedown与mouseup事件"></a>2.jQuery鼠标事件之mousedown与mouseup事件</h1><h1 id="3-jQuery鼠标事件之mousemove事件"><a href="#3-jQuery鼠标事件之mousemove事件" class="headerlink" title="3.jQuery鼠标事件之mousemove事件"></a>3.jQuery鼠标事件之mousemove事件</h1><p>移动事件</p>
<h1 id="4-jQuery鼠标事件之mouseover与mouseout事件"><a href="#4-jQuery鼠标事件之mouseover与mouseout事件" class="headerlink" title="4.jQuery鼠标事件之mouseover与mouseout事件"></a>4.jQuery鼠标事件之mouseover与mouseout事件</h1><h1 id="5-jQuery鼠标事件之mouseenter与mouseleave事件"><a href="#5-jQuery鼠标事件之mouseenter与mouseleave事件" class="headerlink" title="5.jQuery鼠标事件之mouseenter与mouseleave事件"></a>5.jQuery鼠标事件之mouseenter与mouseleave事件</h1><p>mouseenter事件只会在绑定它的元素上被调用，而不会在后代节点上被触发</p>
<h1 id="6-jQuery鼠标事件之hover事件"><a href="#6-jQuery鼠标事件之hover事件" class="headerlink" title="6.jQuery鼠标事件之hover事件"></a>6.jQuery鼠标事件之hover事件</h1><pre><code>(selector).hover(handlerIn, handlerOut)
</code></pre><ul>
<li>handlerIn(eventObject)：当鼠标指针进入元素时触发执行的事件函数</li>
</ul>
<ul>
<li>handlerOut(eventObject)：当鼠标指针离开元素时触发执行的事件函数</li>
</ul>
<h1 id="7-jQuery鼠标事件之focusin事件"><a href="#7-jQuery鼠标事件之focusin事件" class="headerlink" title="7.jQuery鼠标事件之focusin事件"></a>7.jQuery鼠标事件之focusin事件</h1><p>当一个元素，或者其内部任何一个元素获得焦点的时候，例如：input元素，用户在点击聚焦的时候，如果开发者需要捕获这个动作的时候，jQuery提供了一个focusin事件</p>
<h1 id="8-jQuery鼠标事件之focusout事件"><a href="#8-jQuery鼠标事件之focusout事件" class="headerlink" title="8.jQuery鼠标事件之focusout事件"></a>8.jQuery鼠标事件之focusout事件</h1><p>当一个元素，或者其内部任何一个元素失去焦点的时候，比如input元素，用户在点击失去焦的时候，如果开发者需要捕获这个动作，jQuery提供了一个focusout事件</p>
<h1 id="9-jQuery表单事件之blur与focus事件"><a href="#9-jQuery表单事件之blur与focus事件" class="headerlink" title="9.jQuery表单事件之blur与focus事件"></a>9.jQuery表单事件之blur与focus事件</h1><p>focus与blur事件：不支持冒泡，focusin与focusout支持冒泡</p>
<h1 id="10-jQuery表单事件之change事件"><a href="#10-jQuery表单事件之change事件" class="headerlink" title="10.jQuery表单事件之change事件"></a>10.jQuery表单事件之change事件</h1><p><input\>元素，<textarea\>和<select\>元素的值都是可以发生改变的，开发者可以通过change事件去监听这些改变的动作</select\></textarea\></input\></p>
<h3 id="1-input元素"><a href="#1-input元素" class="headerlink" title="(1).input元素"></a>(1).input元素</h3><p>监听value值的变化，当有改变时，失去焦点后触发change事件。对于单选按钮和复选框，当用户用鼠标做出选择时，该事件立即触发。</p>
<h3 id="2-select元素"><a href="#2-select元素" class="headerlink" title="(2).select元素"></a>(2).select元素</h3><p>对于下拉选择框，当用户用鼠标作出选择时，该事件立即触发</p>
<h3 id="3-textarea元素"><a href="#3-textarea元素" class="headerlink" title="(3).textarea元素"></a>(3).textarea元素</h3><p>多行文本输入框，当有改变时，失去焦点后触发change事件</p>
<h1 id="11-jQuery表单事件之select事件"><a href="#11-jQuery表单事件之select事件" class="headerlink" title="11.jQuery表单事件之select事件"></a>11.jQuery表单事件之select事件</h1><p>当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。</p>
<pre><code>select事件只能用于&lt;input&gt;元素与&lt;textarea&gt;元素
</code></pre><h1 id="12-jQuery表单事件之submit事件"><a href="#12-jQuery表单事件之submit事件" class="headerlink" title="12.jQuery表单事件之submit事件"></a>12.jQuery表单事件之submit事件</h1><h3 id="1-具体能触发submit事件的行为："><a href="#1-具体能触发submit事件的行为：" class="headerlink" title="(1).具体能触发submit事件的行为："></a>(1).具体能触发submit事件的行为：</h3><ol>
<li><input type="submit" \="">


</li>
</ol>
<ol>
<li><input type="image" \="">


</li>
</ol>
<ol>
<li><button type="submit" \="">


</button></li>
</ol>
<ol>
<li>当某些表单元素获取焦点时，敲击Enter（回车键）</li>
</ol>
<h3 id="2-这里需要特别注意："><a href="#2-这里需要特别注意：" class="headerlink" title="(2).这里需要特别注意："></a>(2).这里需要特别注意：</h3><blockquote>
<p>form元素是有默认提交表单的行为，如果通过submit处理的话，需要禁止浏览器的这个默认行为<br>传统的方式是调用事件对象  e.preventDefault() 来处理， jQuery中可以直接在函数中最后结尾return false即可</p>
</blockquote>
<pre><code>$(&quot;#target&quot;).submit(function(data) { 
   return false; //阻止默认行为，提交表单
});
</code></pre><h1 id="13-jQuery键盘事件之keydown-与keyup-事件"><a href="#13-jQuery键盘事件之keydown-与keyup-事件" class="headerlink" title="13.jQuery键盘事件之keydown()与keyup()事件"></a>13.jQuery键盘事件之keydown()与keyup()事件</h1><h1 id="14-jQuery键盘事件之keypress-事件"><a href="#14-jQuery键盘事件之keypress-事件" class="headerlink" title="14.jQuery键盘事件之keypress()事件"></a>14.jQuery键盘事件之keypress()事件</h1><p>在input元素上绑定keydown事件会发现一个问题：<br>每次获取的内容都是之前输入的，当前输入的获取不到</p>
<p>keypress()可以捕获当前的值，但是中文不可以，e.target.value返回之前所有的输入字符，这个时候中文 就会被提取并打印出来！</p>
<h1 id="15-on-的多事件绑定"><a href="#15-on-的多事件绑定" class="headerlink" title="15.on()的多事件绑定"></a>15.on()的多事件绑定</h1><h3 id="1-基本用法：-on-events-selector-data"><a href="#1-基本用法：-on-events-selector-data" class="headerlink" title="(1).基本用法：.on( events ,[ selector ] ,[ data ] )"></a>(1).基本用法：.on( events ,[ selector ] ,[ data ] )</h3><pre><code>$(&quot;#elem&quot;).click(function(){})  //快捷方式
$(&quot;#elem&quot;).on(&apos;click&apos;,function(){}) //on方式
最大的不同点就是on是可以自定义事件名
</code></pre><h3 id="2-多个事件绑定同一个函数"><a href="#2-多个事件绑定同一个函数" class="headerlink" title="(2).多个事件绑定同一个函数"></a>(2).多个事件绑定同一个函数</h3><pre><code>$(&quot;#elem&quot;).on(&quot;mouseover mouseout&quot;,function(){ });
</code></pre><h3 id="3-多个事件绑定不同函数"><a href="#3-多个事件绑定不同函数" class="headerlink" title="(3).多个事件绑定不同函数"></a>(3).多个事件绑定不同函数</h3><pre><code>$(&quot;#elem&quot;).on({
    mouseover:function(){},  
    mouseout:function(){}
});
</code></pre><h3 id="4-将数据传递到处理程序"><a href="#4-将数据传递到处理程序" class="headerlink" title="(4).将数据传递到处理程序"></a>(4).将数据传递到处理程序</h3><pre><code>function greet( event ) {
  alert( &quot;Hello &quot; + event.data.name ); //Hello 慕课网
}
$( &quot;button&quot; ).on( &quot;click&quot;, {
  name: &quot;慕课网&quot;
}, greet );
</code></pre><p>可以通过第二参数（对象），当一个事件被触发时，要传递给事件处理函数的</p>
<h1 id="16-on-的高级用法"><a href="#16-on-的高级用法" class="headerlink" title="16.on()的高级用法"></a>16.on()的高级用法</h1><p>事件绑定在最上层div元素上，当用户触发在a元素上，事件将往上冒泡，一直会冒泡在div元素上。如果提供了第二参数，那么事件在往上冒泡的过程中遇到了选择器匹配的元素，将会触发事件回调函数</p>
<pre><code>&lt;div class=&quot;left&quot;&gt;
    &lt;p class=&quot;aaron&quot;&gt;
        &lt;a&gt;目标节点&lt;/a&gt; //点击在这个元素上
    &lt;/p&gt;
&lt;/div&gt;

$(&quot;div&quot;).on(&quot;click&quot;,&quot;a&quot;,fn)
</code></pre><h1 id="17-卸载事件off-方法"><a href="#17-卸载事件off-方法" class="headerlink" title="17.卸载事件off()方法"></a>17.卸载事件off()方法</h1><h3 id="1-绑定2个事件"><a href="#1-绑定2个事件" class="headerlink" title="(1).绑定2个事件"></a>(1).绑定2个事件</h3><pre><code>$(&quot;elem&quot;).on(&quot;mousedown mouseup&quot;,fn)
</code></pre><h3 id="2-删除一个事件"><a href="#2-删除一个事件" class="headerlink" title="(2).删除一个事件"></a>(2).删除一个事件</h3><pre><code>$(&quot;elem&quot;).off(&quot;mousedown&quot;)
</code></pre><h3 id="3-删除所有事件"><a href="#3-删除所有事件" class="headerlink" title="(3).删除所有事件"></a>(3).删除所有事件</h3><pre><code>$(&quot;elem&quot;).off(&quot;mousedown mouseup&quot;)
</code></pre><p>快捷方式删除所有事件，这里不需要传递事件名了，节点上绑定的所有事件讲全部销毁</p>
<pre><code>$(&quot;elem&quot;).off()
</code></pre><h1 id="18-jQuery事件对象的作用"><a href="#18-jQuery事件对象的作用" class="headerlink" title="18.jQuery事件对象的作用"></a>18.jQuery事件对象的作用</h1><pre><code>&lt;ul&gt;
    &lt;li class=&quot;even1&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;even2&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;even2&quot;&gt;&lt;/li&gt;
    .........
&lt;/ul&gt;
</code></pre><p>ul有N个子元素li(这里只写了3个)，如果我要响应每一个li的事件，那么常规的方法就是需要给所有的li都单独绑定一个事件监听，这样写法很符合逻辑，但是同时有显得繁琐</p>
<p>因为li都有一个共同的父元素，而且所有的事件都是一致的，这里我们可以采用要一个技巧来处理，也是常说的”事件委托”</p>
<p>事件没直接和li元素发生关系，而且绑定父元素了。由于浏览器有事件冒泡的这个特性，我们可以在触发li的时候把这个事件往上冒泡到ul上，因为ul上绑定事件响应所以就能够触发这个动作了。唯一的问题怎么才知道触发的li元素是哪个一个？</p>
<p>这里就引出了事件对象了</p>
<blockquote>
<p>事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁</p>
</blockquote>
<p><strong>event.target代表当前触发事件的元素，可以通过当前元素对象的一系列属性来判断是不是我们想要的元素</strong></p>
<h1 id="19-jQuery事件对象的属性和方法"><a href="#19-jQuery事件对象的属性和方法" class="headerlink" title="19.jQuery事件对象的属性和方法"></a>19.jQuery事件对象的属性和方法</h1><p>事件对象的属于与方法有很多，但是我们经常用的只有那么几个，这里我主要说下作用与区别</p>
<h3 id="1-event-type：获取事件的类型"><a href="#1-event-type：获取事件的类型" class="headerlink" title="(1).event.type：获取事件的类型"></a>(1).event.type：获取事件的类型</h3><p>触发元素的事件类型</p>
<pre><code>$(&quot;a&quot;).click(function(event) {
  alert(event.type); // &quot;click&quot;事件
});
</code></pre><h3 id="2-event-pageX-和-event-pageY：获取鼠标当前相对于页面的坐标"><a href="#2-event-pageX-和-event-pageY：获取鼠标当前相对于页面的坐标" class="headerlink" title="(2).event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标"></a>(2).event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标</h3><p>通过这2个属性，可以确定元素在当前页面的坐标值，鼠标相对于文档的左边缘的位置（左边）与 （顶边）的距离，简单来说是从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化</p>
<h3 id="3-event-preventDefault-方法：阻止默认行为"><a href="#3-event-preventDefault-方法：阻止默认行为" class="headerlink" title="(3).event.preventDefault() 方法：阻止默认行为"></a>(3).event.preventDefault() 方法：阻止默认行为</h3><p>这个用的特别多，在执行这个方法后，如果点击一个链接（a标签），浏览器不会跳转到新的 URL 去了。我们可以用 event.isDefaultPrevented() 来确定这个方法是否(在那个事件对象上)被调用过了</p>
<h3 id="4-event-stopPropagation-方法：阻止事件冒泡"><a href="#4-event-stopPropagation-方法：阻止事件冒泡" class="headerlink" title="(4).event.stopPropagation() 方法：阻止事件冒泡"></a>(4).event.stopPropagation() 方法：阻止事件冒泡</h3><p>事件是可以冒泡的，为防止事件冒泡到DOM树上，也就是不触发的任何前辈元素上的事件处理函数</p>
<h3 id="5-event-which：获取在鼠标单击时，单击的是鼠标的哪个键"><a href="#5-event-which：获取在鼠标单击时，单击的是鼠标的哪个键" class="headerlink" title="(5).event.which：获取在鼠标单击时，单击的是鼠标的哪个键"></a>(5).event.which：获取在鼠标单击时，单击的是鼠标的哪个键</h3><p>event.which 将 event.keyCode 和 event.charCode 标准化了。event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3</p>
<h3 id="6-event-currentTarget-在事件冒泡过程中的当前DOM元素"><a href="#6-event-currentTarget-在事件冒泡过程中的当前DOM元素" class="headerlink" title="(6).event.currentTarget : 在事件冒泡过程中的当前DOM元素"></a>(6).event.currentTarget : 在事件冒泡过程中的当前DOM元素</h3><p>冒泡前的当前触发事件的DOM对象, 等同于this.</p>
<h3 id="7-this和event-target的区别："><a href="#7-this和event-target的区别：" class="headerlink" title="(7).this和event.target的区别："></a>(7).this和event.target的区别：</h3><p>js中事件是会冒泡的，所以this是可以变化的，但event.target不会变化，它永远是直接接受事件的目标DOM元素；</p>
<h3 id="8-this和event-target都是dom对象"><a href="#8-this和event-target都是dom对象" class="headerlink" title="(8).this和event.target都是dom对象"></a>(8).this和event.target都是dom对象</h3><p>如果要使用jquey中的方法可以将他们转换为jquery对象。比如this和$(this)的使用、event.target和$(event.target)的使用；</p>
<h1 id="20-jQuery自定义事件之trigger事件"><a href="#20-jQuery自定义事件之trigger事件" class="headerlink" title="20.jQuery自定义事件之trigger事件"></a>20.jQuery自定义事件之trigger事件</h1><p>trigger() 方法触发被选元素的指定事件类型。</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
  $(&quot;input&quot;).select(function(){
    $(&quot;input&quot;).after(&quot;文本被选中！&quot;);
  });
  $(&quot;button&quot;).click(function(){
    $(&quot;input&quot;).trigger(&quot;select&quot;);
  });
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;FirstName&quot; value=&quot;Hello World&quot; /&gt;
&lt;br /&gt;
&lt;button&gt;激活 input 域的 select 事件&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="21-jQuery自定义事件之triggerHandler事件"><a href="#21-jQuery自定义事件之triggerHandler事件" class="headerlink" title="21.jQuery自定义事件之triggerHandler事件"></a>21.jQuery自定义事件之triggerHandler事件</h1><p>triggerHandler() 方法触发被选元素的指定事件类型。但不会执行浏览器默认动作，也不会产生事件冒泡。</p>
<p>triggerHandler() 方法与 trigger() 方法类似。不同的是它不会触发事件（比如表单提交）的默认行为，而且只影响第一个匹配元素。</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
  $(&quot;input&quot;).select(function(){
    $(&quot;input&quot;).after(&quot;发生 Input select 事件！&quot;);
  });
  $(&quot;button&quot;).click(function(){
    $(&quot;input&quot;).triggerHandler(&quot;select&quot;);
  });
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;FirstName&quot; value=&quot;Hello World&quot; /&gt;
&lt;br /&gt;
&lt;button&gt;激活 input 域的 select 事件&lt;/button&gt;
&lt;p&gt;请注意，与 trigger() 方法不同，triggerHandler() 方法不会引起所发生事件的默认行为（文本不会被选中）。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/jquery-二-DOM篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/jquery-二-DOM篇/" itemprop="url">jquery(二)DOM篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:25:59+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-jQuery节点创建与属性的处理"><a href="#1-jQuery节点创建与属性的处理" class="headerlink" title="1.jQuery节点创建与属性的处理"></a>1.jQuery节点创建与属性的处理</h1><h3 id="1-创建元素节点："><a href="#1-创建元素节点：" class="headerlink" title="(1).创建元素节点："></a>(1).创建元素节点：</h3><p>可以有几种方式，后面会慢慢接触。常见的就是直接把这个节点的结构给通过HTML标记字符串描述出来，通过$()函数处理，$(“html结构”)</p>
<pre><code>$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)
</code></pre><h3 id="2-创建为本节点："><a href="#2-创建为本节点：" class="headerlink" title="(2).创建为本节点："></a>(2).创建为本节点：</h3><p>与创建元素节点类似，可以直接把文本内容一并描述</p>
<pre><code>$(&quot;&lt;div&gt;我是文本节点&lt;/div&gt;&quot;)
</code></pre><h3 id="3-创建为属性节点："><a href="#3-创建为属性节点：" class="headerlink" title="(3).创建为属性节点："></a>(3).创建为属性节点：</h3><p>与创建元素节点同样的方式</p>
<pre><code>$(&quot;&lt;div id=&apos;test&apos; class=&apos;aaron&apos;&gt;我是文本节点&lt;/div&gt;&quot;)
</code></pre><hr>
<pre><code>$(&quot;&lt;div class=&apos;right&apos;&gt;&lt;div class=&apos;aaron&apos;&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;&quot;)
</code></pre><h1 id="2-DOM内部插入append-与appendTo"><a href="#2-DOM内部插入append-与appendTo" class="headerlink" title="2.DOM内部插入append()与appendTo()"></a>2.DOM内部插入append()与appendTo()</h1><p><img src="http://oncweb6po.bkt.clouddn.com/56cc12f800017b4104480146.jpg" alt=""></p>
<p>append()前面是被插入的对象，后面是要在对象内插入的元素内容</p>
<p>appendTo()前面是要插入的元素内容，而后面是被插入的对象</p>
<h1 id="3-DOM外部插入after-与before"><a href="#3-DOM外部插入after-与before" class="headerlink" title="3.DOM外部插入after()与before()"></a>3.DOM外部插入after()与before()</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57481b6b00018e3405210197.jpg" alt=""></p>
<ol>
<li>before与after都是用来对相对选中元素外部增加相邻的兄弟节点</li>
</ol>
<ol>
<li>2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面</li>
</ol>
<ol>
<li>2个方法都支持多个参数传递after(div1,div2,….) 可以参考右边案例代码</li>
</ol>
<p><strong>注意点：</strong></p>
<ol>
<li>after向元素的后边添加html代码，如果元素后面有元素了，那将后面的元素后移，然后将html代码插入</li>
</ol>
<ol>
<li>before向元素的前边添加html代码，如果元素前面有元素了，那将前面的元素前移，然后将html代码插</li>
</ol>
<h1 id="4-DOM内部插入prepend-与prependTo"><a href="#4-DOM内部插入prepend-与prependTo" class="headerlink" title="4.DOM内部插入prepend()与prependTo()"></a>4.DOM内部插入prepend()与prependTo()</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57481c3900013c6e05000193.jpg" alt=""></p>
<ol>
<li>append()向每个匹配的元素内部追加内容</li>
</ol>
<ol>
<li>prepend()向每个匹配的元素内部前置内容</li>
</ol>
<ol>
<li>appendTo()把所有匹配的元素追加到另一个指定元素的集合中</li>
</ol>
<ol>
<li>prependTo()把所有匹配的元素前置到另一个指定的元素集合中</li>
</ol>
<h1 id="5-DOM外部插入insertAfter-与insertBefore"><a href="#5-DOM外部插入insertAfter-与insertBefore" class="headerlink" title="5.DOM外部插入insertAfter()与insertBefore()"></a>5.DOM外部插入insertAfter()与insertBefore()</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57481d230001b0f305170241.jpg" alt=""></p>
<ol>
<li>before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。 对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面</li>
</ol>
<ol>
<li>.after()和.insertAfter() 实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面</li>
</ol>
<ol>
<li>before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理</li>
</ol>
<p><strong>注意事项：</strong></p>
<ol>
<li>insertAfter将JQuery封装好的元素插入到指定元素的后面，如果元素后面有元素了，那将后面的元素后移，然后将JQuery对象插入；</li>
</ol>
<ol>
<li>insertBefore将JQuery封装好的元素插入到指定元素的前面，如果元素前面有元素了，那将前面的元素前移，然后将JQuery对象插入；</li>
</ol>
<h1 id="6-DOM节点删除之empty-的基本用法"><a href="#6-DOM节点删除之empty-的基本用法" class="headerlink" title="6.DOM节点删除之empty()的基本用法"></a>6.DOM节点删除之empty()的基本用法</h1><p>empty 顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了 指定元素中的所有子节点。</p>
<p>这个方法不仅移除子元素（和其他后代元素），同样移除元素里的文本。因为，根据说明，元素里任何文本字符串都被看做是该元素的子节点。请看下面的HTML：</p>
<pre><code>&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt;
</code></pre><p>如果我们通过empty方法移除里面div的所有元素，它只是清空内部的html代码，但是标记仍然留在DOM中</p>
<pre><code>//通过empty处理
$(&apos;.hello&apos;).empty()

//结果：&lt;p&gt;慕课网&lt;/p&gt;被移除
&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;
</code></pre><h1 id="7-DOM节点删除之remove-的有参用法和无参用法"><a href="#7-DOM节点删除之remove-的有参用法和无参用法" class="headerlink" title="7.DOM节点删除之remove()的有参用法和无参用法"></a>7.DOM节点删除之remove()的有参用法和无参用法</h1><p>remove与empty一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。</p>
<pre><code>&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt;
$(&apos;.hello&apos;).on(&quot;click&quot;,fn)
</code></pre><p>如果不通过remove方法删除这个节点其实也很简单，但是同时需要把事件给销毁掉，这里是为了防止”内存泄漏”，所以前端开发者一定要注意，绑了多少事件，不用的时候一定要记得销毁</p>
<p>通过remove方法移除div及其内部所有元素，remove内部会自动操作事件销毁方法，所以使用使用起来非常简单</p>
<pre><code>//通过remove处理
$(&apos;.hello&apos;).remove()
//结果：&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt; 全部被移除
//节点不存在了,同事事件也会被销毁
</code></pre><p><strong>remove表达式参数：</strong></p>
<p>remove比empty好用的地方就是可以传递一个选择器表达式用来过滤将被移除的匹配元素集合，可以选择性的删除指定的节点</p>
<p>我们可以通过$()选择一组相同的元素，然后通过remove（）传递筛选的规则，从而这样处理</p>
<pre><code>$(&quot;p&quot;).filter(&quot;:contains(&apos;3&apos;)&quot;).remove()
</code></pre><h1 id="8-DOM节点删除之empty和remove区别"><a href="#8-DOM节点删除之empty和remove区别" class="headerlink" title="8.DOM节点删除之empty和remove区别"></a>8.DOM节点删除之empty和remove区别</h1><h3 id="1-empty方法"><a href="#1-empty方法" class="headerlink" title="(1).empty方法"></a>(1).empty方法</h3><ol>
<li>严格地讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点</li>
</ol>
<ol>
<li>empty不能删除自己本身这个节点<h3 id="2-remove方法"><a href="#2-remove方法" class="headerlink" title="(2).remove方法"></a>(2).remove方法</h3></li>
</ol>
<ol>
<li>该节点与该节点所包含的所有后代节点将同时被删除</li>
</ol>
<ol>
<li>提供传递一个筛选的表达式，删除指定合集中的元素</li>
</ol>
<h1 id="9-DOM节点删除之保留数据的删除操作detach"><a href="#9-DOM节点删除之保留数据的删除操作detach" class="headerlink" title="9.DOM节点删除之保留数据的删除操作detach()"></a>9.DOM节点删除之保留数据的删除操作detach()</h1><p>如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理</p>
<p>detach从字面上就很容易理解。让一个web元素托管。即从当前页面中移除该元素，但保留这个元素的内存模型对象。<br>来看看jquery官方文档的解释：</p>
<blockquote>
<p>这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。</p>
<p>$(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。</p>
</blockquote>
<p>当然这里要特别注意，detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据</p>
<p>参考右边的代码区域，通过 $(“p”).detach()把所有的P元素删除后，再通过append把删除的p元素放到页面上，通过点击文字，可以证明事件没有丢失</p>
<h1 id="10-DOM节点删除之detach-和remove-区别"><a href="#10-DOM节点删除之detach-和remove-区别" class="headerlink" title="10.DOM节点删除之detach()和remove()区别"></a>10.DOM节点删除之detach()和remove()区别</h1><h3 id="1-remove：移除节点"><a href="#1-remove：移除节点" class="headerlink" title="(1).remove：移除节点"></a>(1).remove：移除节点</h3><ol>
<li>无参数，移除自身整个节点以及该节点的内部的所有节点，包括节点上事件与数据</li>
</ol>
<ol>
<li>有参数，移除筛选出的节点以及该节点的内部的所有节点，包括节点上事件与数据<h3 id="2-detach：移除节点"><a href="#2-detach：移除节点" class="headerlink" title="(2).detach：移除节点"></a>(2).detach：移除节点</h3></li>
</ol>
<ol>
<li>移除的处理与remove一致</li>
</ol>
<ol>
<li>与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来</li>
</ol>
<ol>
<li>例如：$(“p”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。</li>
</ol>
<h1 id="11-DOM拷贝clone"><a href="#11-DOM拷贝clone" class="headerlink" title="11.DOM拷贝clone()"></a>11.DOM拷贝clone()</h1><p>克隆节点是DOM的常见操作，jQuery提供一个clone方法，专门用于处理dom的克隆</p>
<blockquote>
<p>.clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。</p>
</blockquote>
<p>clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了</p>
<pre><code>例如：
HTML部分
&lt;div&gt;&lt;/div&gt;

JavaScript部分
$(&quot;div&quot;).on(&apos;click&apos;, function() {//执行操作})

//clone处理一
$(&quot;div&quot;).clone()   //只克隆了结构，事件丢失

//clone处理二
$(&quot;div&quot;).clone(true) //结构、事件与数据都克隆
</code></pre><p>使用上就是这样简单，使用克隆的我们需要额外知道的细节：</p>
<ol>
<li>clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css(‘color’,’red’) 增加了一个颜色</li>
</ol>
<ol>
<li>通过传递true，将所有绑定在原始元素上的事件处理函数复制到克隆元素上</li>
</ol>
<ol>
<li>clone()方法是jQuery扩展的，只能处理通过jQuery绑定的事件与数据</li>
</ol>
<ol>
<li>元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个</li>
</ol>
<h1 id="12-DOM替换replaceWith-和replaceAll"><a href="#12-DOM替换replaceWith-和replaceAll" class="headerlink" title="12.DOM替换replaceWith()和replaceAll()"></a>12.DOM替换replaceWith()和replaceAll()</h1><h3 id="1-replaceWith-newContent-："><a href="#1-replaceWith-newContent-：" class="headerlink" title="(1). .replaceWith( newContent )："></a>(1). .replaceWith( newContent )：</h3><p>用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合</p>
<p>简单来说：用$()选择节点A，调用replaceWith方法，传入一个新的内容B（HTML字符串，DOM元素，或者jQuery对象）用来替换选中的节点A</p>
<p>看个简单的例子：一段HTML代码</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;第一段&lt;/p&gt;
    &lt;p&gt;第二段&lt;/p&gt;
    &lt;p&gt;第三段&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>替换第二段的节点与内容</p>
<pre><code>$(&quot;p:eq(1)&quot;).replaceWith(&apos;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos;)
</code></pre><p>通过jQuery筛选出第二个p元素，调用replaceWith进行替换，结果如下</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;第一段&lt;/p&gt;
    &lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos;
    &lt;p&gt;第三段&lt;/p&gt;
&lt;/div&gt;
</code></pre><h3 id="2-replaceAll-target-："><a href="#2-replaceAll-target-：" class="headerlink" title="(2).replaceAll( target ) ："></a>(2).replaceAll( target ) ：</h3><p>用集合的匹配元素替换每个目标元素</p>
<p>.replaceAll()和.replaceWith()功能类似，但是目标和源相反，用上述的HTML结构，我们用replaceAll处理<br>$(‘<a style="color:red">替换第二段的内容</a>‘).replaceAll(‘p:eq(1)’)</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="(3).总结"></a>(3).总结</h3><ol>
<li>.replaceAll()和.replaceWith()功能类似，主要是目标和源的位置区别</li>
</ol>
<ol>
<li>.replaceWith()与.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序</li>
</ol>
<ol>
<li>.replaceWith()方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用</li>
</ol>
<ol>
<li>.replaceWith()方法返回的jQuery对象引用的是替换前的节点，而不是通过replaceWith/replaceAll方法替换后的节点</li>
</ol>
<h1 id="13-DOM包裹wrap-方法"><a href="#13-DOM包裹wrap-方法" class="headerlink" title="13.DOM包裹wrap()方法"></a>13.DOM包裹wrap()方法</h1><p>如果要将元素用其他元素包裹起来，也就是给它增加一个父元素，针对这样的处理，JQuery提供了一个wrap方法</p>
<h3 id="1-wrap-wrappingElement-："><a href="#1-wrap-wrappingElement-：" class="headerlink" title="(1).wrap( wrappingElement )："></a>(1).wrap( wrappingElement )：</h3><p>在集合中匹配的每个元素周围包裹一个HTML结构</p>
<p>简单的看一段代码：</p>
<pre><code>&lt;p&gt;p元素&lt;/p&gt;
给p元素增加一个div包裹
$(&apos;p&apos;).wrap(&apos;&lt;div&gt;&lt;/div&gt;&apos;)
</code></pre><p>最后的结构，p元素增加了一个父div的结构</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><h3 id="2-wrap-function-："><a href="#2-wrap-function-：" class="headerlink" title="(2).wrap( function ) ："></a>(2).wrap( function ) ：</h3><p>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象</p>
<p>使用后的效果与直接传递参数是一样，只不过可以把代码写在函数体内部，写法不同而已</p>
<p>以第一个案例为例：</p>
<pre><code>$(&apos;p&apos;).wrap(function() {
    return &apos;&lt;div&gt;&lt;/div&gt;&apos;;   //与第一种类似，只是写法不一样
})
</code></pre><h3 id="3-注意："><a href="#3-注意：" class="headerlink" title="(3).注意："></a>(3).注意：</h3><p>.wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套了好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。</p>
<h1 id="14-DOM包裹unwrap-方法"><a href="#14-DOM包裹unwrap-方法" class="headerlink" title="14.DOM包裹unwrap()方法"></a>14.DOM包裹unwrap()方法</h1><p>我们可以通过wrap方法给选中元素增加一个包裹的父元素。相反，如果删除选中元素的父元素要如何处理 ?</p>
<p>jQuery提供了一个unwarp()方法 ，作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。</p>
<p>看一段简单案例：</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>我要删除这段代码中的div，一般常规的方法会直接通过remove或者empty方法</p>
<pre><code>$(&apos;div&apos;).remove();
</code></pre><p>但是如果我还要保留内部元素p，这样就意味着需要多做很多处理，步骤相对要麻烦很多，为了更便捷，jQuery提供了unwarp方法很方便的处理了这个问题</p>
<pre><code>$(&apos;p&apos;).unwarp();
</code></pre><p>找到p元素，然后调用unwarp方法，这样只会删除父辈div元素了</p>
<p>结果：</p>
<pre><code>&lt;p&gt;p元素&lt;/p&gt;
</code></pre><p>这个方法比较简单，也不接受任何参数，注意参考下案例的使用即可</p>
<h1 id="15-DOM包裹wrapAll-方法"><a href="#15-DOM包裹wrapAll-方法" class="headerlink" title="15.DOM包裹wrapAll()方法"></a>15.DOM包裹wrapAll()方法</h1><h3 id="1-wrapAll-wrappingElement-："><a href="#1-wrapAll-wrappingElement-：" class="headerlink" title="(1).wrapAll( wrappingElement )："></a>(1).wrapAll( wrappingElement )：</h3><p>给集合中匹配的元素增加一个外面包裹HTML结构</p>
<p>简单的看一段代码：</p>
<pre><code>&lt;p&gt;p元素&lt;/p&gt;
&lt;p&gt;p元素&lt;/p&gt;
</code></pre><p>给所有p元素增加一个div包裹</p>
<pre><code>$(&apos;p&apos;).wrapAll(&apos;&lt;div&gt;&lt;/div&gt;&apos;)
</code></pre><p>最后的结构，2个P元素都增加了一个父div的结构</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><h3 id="2-wrapAll-function-："><a href="#2-wrapAll-function-：" class="headerlink" title="(2).wrapAll( function ) ："></a>(2).wrapAll( function ) ：</h3><p>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象</p>
<p>通过回调的方式可以单独处理每一个元素<br>以上面案例为例，</p>
<pre><code>$(&apos;p&apos;).wrapAll(function() {
    return &apos;&lt;div&gt;&lt;div/&gt;&apos;; 
})
</code></pre><p>以上的写法的结果如下，等同于warp的处理了</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><h1 id="16-DOM包裹wrapInner-方法"><a href="#16-DOM包裹wrapInner-方法" class="headerlink" title="16.DOM包裹wrapInner()方法"></a>16.DOM包裹wrapInner()方法</h1><p>如果要将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素，针对这样的处理，JQuery提供了一个wrapInner方法</p>
<h3 id="1-wrapInner-wrappingElement-："><a href="#1-wrapInner-wrappingElement-：" class="headerlink" title="(1).wrapInner( wrappingElement )："></a>(1).wrapInner( wrappingElement )：</h3><p>给集合中匹配的元素的内部，增加包裹的HTML结构</p>
<p>听起来有点绕，可以用个简单的例子描述下，简单的看一段代码：</p>
<pre><code>&lt;div&gt;p元素&lt;/div&gt;
&lt;div&gt;p元素&lt;/div&gt;
给所有元素增加一个p包裹
$(&apos;div&apos;).wrapInner(&apos;&lt;p&gt;&lt;/p&gt;&apos;)
</code></pre><p>最后的结构，匹配的di元素的内部元素被p给包裹了</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><h3 id="2-wrapInner-function-："><a href="#2-wrapInner-function-：" class="headerlink" title="(2).wrapInner( function ) ："></a>(2).wrapInner( function ) ：</h3><p>允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容</p>
<p>以上面案例为例，</p>
<pre><code>$(&apos;div&apos;).wrapInner(function() {
    return &apos;&lt;p&gt;&lt;/p&gt;&apos;; 
})
</code></pre><p>以上的写法的结果如下，等同于第一种处理了</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><p><strong>注意：</strong><br> 当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。</p>
<h1 id="17-jQuery遍历之children-方法"><a href="#17-jQuery遍历之children-方法" class="headerlink" title="17.jQuery遍历之children()方法"></a>17.jQuery遍历之children()方法</h1><p>jQuery是一个合集对象，如果想快速查找合集里面的第一级子元素，此时可以用children()方法。这里需要注意：.children(selector) 方法是返回匹配元素集合中每个元素的所有子元素（仅儿子辈，这里可以理解为就是父亲-儿子的关系）</p>
<p><strong>理解节点查找关系：</strong></p>
<pre><code>&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>代码如果是$(“div”).children()，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。</p>
<p><strong>children()无参数</strong><br>允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过children是匹配合集中每一给元素的第一级子元素</p>
</blockquote>
<p><strong>.children()方法选择性地接受同一类型选择器表达式</strong></p>
<pre><code>$(&quot;div&quot;).children(&quot;.selected&quot;)
</code></pre><p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
<hr>
<pre><code>.detach() 隐身

.remove 自杀

.empty 身体被掏空

.clone 复制 （true全复制 false 浅复制，无事件）

.replaceWith 删除并替换节点（结合.replaceAll()来记）

.wrap 每个人加个爸爸

.unwrap 爸爸没了

.wrapAll 所有人加个爸爸

.wrapAll（function）每个人加个爸爸

.wrapInner 加个儿子

.children() 找儿子
</code></pre><h1 id="18-jQuery遍历之find-方法"><a href="#18-jQuery遍历之find-方法" class="headerlink" title="18.jQuery遍历之find()方法"></a>18.jQuery遍历之find()方法</h1><p>jQuery是一个合集对象，如果想快速查找DOM树中的这些元素的后代元素，此时可以用find()方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系）</p>
<p><strong>理解节点查找关系：</strong></p>
<pre><code>&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>代码如果是$(“div”).find(“li”)，此时，li与div是祖辈关系，通过find方法就可以快速的查找到了。</p>
<p><strong>.find()方法要注意的知识点：</strong></p>
<ol>
<li>find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。</li>
</ol>
<ol>
<li>与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 ‘*’。<br>find只在后代中遍历，不包括自己。</li>
</ol>
<ol>
<li>选择器 context 是由 .find() 方法实现的；因此，$(‘.item-ii’).find(‘li’) 等价于 $(‘li’, ‘.item-ii’)(找到类名为item-ii的标签下的li标签)。</li>
</ol>
<p><strong>注意重点：</strong></p>
<ol>
<li>.find()和.children()方法是相似的</li>
</ol>
<ol>
<li>.children只查找第一级的子节点</li>
</ol>
<ol>
<li>.find查找范围包括子节点的所有后代节点</li>
</ol>
<h1 id="19-jQuery遍历之parent-方法"><a href="#19-jQuery遍历之parent-方法" class="headerlink" title="19.jQuery遍历之parent()方法"></a>19.jQuery遍历之parent()方法</h1><p>jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的父元素（这里可以理解为就是父亲-儿子的关系），此时可以用parent()方法</p>
<p>因为是父元素，这个方法只会向上查找一级</p>
<p><strong>理解节点查找关系：</strong></p>
<pre><code>&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>查找ul的父元素div, $(ul).parent()，就是这样简单的表达</p>
<p><strong>parent()无参数</strong></p>
<p>parent()方法允许我们能够在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素</p>
</blockquote>
<p><strong>parent()方法选择性地接受同一型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<h1 id="20-jQuery遍历之parents-方法"><a href="#20-jQuery遍历之parents-方法" class="headerlink" title="20.jQuery遍历之parents()方法"></a>20.jQuery遍历之parents()方法</h1><p>jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的所有祖辈元素，此时可以用parents()方法</p>
<p>其实也类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点</p>
<p><strong>理解节点查找关系：</strong></p>
<pre><code>&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>在li节点上找到祖 辈元素div， 这里可以用$(“li”).parents()方法</p>
<p><strong>parents()无参数</strong></p>
<p>parents()方法允许我们能够在DOM树中搜索到这些元素的祖先元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象;</p>
<p>返回的元素秩序是从离他们最近的父级元素开始的</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过parent是匹配合集中所有元素的祖辈元素</p>
</blockquote>
<p><strong>parents()方法选择性地接受同一型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<p><strong>注意事项：</strong></p>
<blockquote>
<p>1 .parents()和.parent()方法是相似的，但后者只是进行了一个单级的DOM树查找<br>2  $( “html” ).parent()方法返回一个包含document的集合，而$( “html” ).parents()返回一个空集合。</p>
</blockquote>
<h1 id="21-jQuery遍历之closest-方法"><a href="#21-jQuery遍历之closest-方法" class="headerlink" title="21.jQuery遍历之closest()方法"></a>21.jQuery遍历之closest()方法</h1><p>以选定的元素为中心，往内查找可以通过find、children方法。如果往上查找，也就是查找当前元素的父辈祖辈元素，jQuery提供了closest()方法，这个方法类似parents但是又有一些细微的区别，属于使用频率很高的方法</p>
<p><strong>closest()方法接受一个匹配元素的选择器字符串</strong></p>
<p>从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素</p>
<p>例如：在div元素中，往上查找所有的li元素，可以这样表达</p>
<pre><code>$(&quot;div&quot;).closet(&quot;li&apos;)
</code></pre><p><strong>注意：jQuery是一个合集对象，所以通过closest是匹配合集中每一个元素的祖先元素</strong></p>
<p><strong>closest()方法给定的jQuery集合或元素来过滤元素</strong></p>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个jQuery的对象</p>
<p><strong>注意事项</strong>：在使用的时候需要特别注意下</p>
<p>粗看.parents()和.closest()是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了</p>
<ol>
<li>起始位置不同：.closest开始于当前元素 .parents开始于父元素</li>
</ol>
<ol>
<li>遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合</li>
</ol>
<ol>
<li>结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象</li>
</ol>
<h1 id="22-jQuery遍历之next-方法"><a href="#22-jQuery遍历之next-方法" class="headerlink" title="22.jQuery遍历之next()方法"></a>22.jQuery遍历之next()方法</h1><p>jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合，此时可以用next()方法</p>
<p><strong>理解节点查找关系：</strong></p>
<p>如下class=”item-1”元素就是红色部分，那蓝色的class=”item-2”就是它的兄弟元素</p>
<pre><code>&lt;ul class=&quot;level-3&quot;&gt;
    &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><strong>next()无参数</strong></p>
<p>允许我们找遍元素集合中紧跟着这些元素的直接兄弟元素，并根据匹配的元素创建一个新的 jQuery 对象。</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素</p>
</blockquote>
<p><strong>next()方法选择性地接受同一类型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<h1 id="23-jQuery遍历之prev-方法"><a href="#23-jQuery遍历之prev-方法" class="headerlink" title="23.jQuery遍历之prev()方法"></a>23.jQuery遍历之prev()方法</h1><p>jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合，此时可以用prev()方法</p>
<p><strong>理解节点查找关系：</strong></p>
<p>如下蓝色的class=”item-2”的li元素，红色的节点就是它的prev兄弟节点</p>
<pre><code>&lt;ul class=&quot;level-3&quot;&gt;
    &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><strong>prev()无参数</strong></p>
<p>取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过prev是匹配合集中每一个元素的上一个兄弟元素</p>
</blockquote>
<p><strong>prev()方法选择性地接受同一类型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<h1 id="24-jQuery遍历之siblings"><a href="#24-jQuery遍历之siblings" class="headerlink" title="24.jQuery遍历之siblings()"></a>24.jQuery遍历之siblings()</h1><p>jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素的同辈元素，此时可以用siblings()方法</p>
<p><strong>理解节点查找关系：</strong></p>
<p>如下蓝色的class=”item-2”的li元素，红色的节点就是它的siblings兄弟节点</p>
<pre><code>&lt;ul class=&quot;level-3&quot;&gt;
    &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><strong>siblings()无参数</strong></p>
<p>取得一个包含匹配的元素集合中每一个元素的同辈元素的元素集合</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过siblings是匹配合集中每一个元素的同辈元素</p>
</blockquote>
<p><strong>siblings()方法选择性地接受同一类型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<h1 id="25-jQuery遍历之add-方法"><a href="#25-jQuery遍历之add-方法" class="headerlink" title="25.jQuery遍历之add()方法"></a>25.jQuery遍历之add()方法</h1><p>jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？jQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中</p>
<blockquote>
<p>.add()的参数可以几乎接受任何的$()，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用。</p>
</blockquote>
<p>简单的看一个案例：</p>
<p>操作：选择所有的li元素，之后把p元素也加入到li的合集中</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;list item 1&lt;/li&gt;
    &lt;li&gt;list item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新的p元素&lt;/p&gt;
</code></pre><h3 id="处理一：传递选择器"><a href="#处理一：传递选择器" class="headerlink" title="处理一：传递选择器"></a>处理一：传递选择器</h3><pre><code>$(&apos;li&apos;).add(&apos;p&apos;)
</code></pre><h3 id="处理二：传递dom元素"><a href="#处理二：传递dom元素" class="headerlink" title="处理二：传递dom元素"></a>处理二：传递dom元素</h3><pre><code>$(&apos;li&apos;).add(document.getElementsByTagName(&apos;p&apos;)[0])
</code></pre><p>还有一种方式，就是动态创建P标签加入到合集，然后插入到指定的位置，但是这样就改变元素的本身的排列了</p>
<pre><code>$(&apos;li&apos;).add(&apos;&lt;p&gt;新的p元素&lt;/p&gt;&apos;).appendTo(目标位置)
</code></pre><h1 id="26-jQuery遍历之each"><a href="#26-jQuery遍历之each" class="headerlink" title="26.jQuery遍历之each()"></a>26.jQuery遍历之each()</h1><p>jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。比如我们操作$(“li”).css(‘’) 给所有的li设置style值，因为jQuery是一个合集对象，所以css方法内部就必须封装一个遍历的方法，被称为隐式迭代的过程。要一个一个给合集中每一个li设置颜色，这里方法就是each</p>
<p>.each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数</p>
<p>所以大体上了解3个重点：</p>
<ol>
<li>each是一个for循环的包装迭代器</li>
</ol>
<ol>
<li>each通过回调的方式处理，并且会有2个固定的实参，索引与元素</li>
</ol>
<ol>
<li>each回调方法中的this指向当前迭代的dom元素</li>
<li><p>看一个简单的案例</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;慕课网&lt;/li&gt;
    &lt;li&gt;Aaron&lt;/li&gt;
&lt;/ul&gt;
</code></pre></li>
</ol>
<p>开始迭代li，循环2次</p>
<pre><code>$(&quot;li&quot;).each(function(index, element) {
     index 索引 0,1
     element是对应的li节点 li,li
     this 指向的是li
})
</code></pre><p>这样可以在循环体会做一些逻辑操作了，如果需要提前退出，可以以通过返回 false以便在回调函数内中止循</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/jquery-一-样式篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/jquery-一-样式篇/" itemprop="url">jquery(一)样式篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:25:39+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-document-ready"><a href="#1-document-ready" class="headerlink" title="1.$(document).ready"></a>1.$(document).ready</h1><p>作用是等页面的文档（document）中的节点都加载完毕后，再执行后续的代码，因为我们在执行代码的时候，可能会依赖页面的某一个元素，我们要确保这个元素真正的的被加载完毕后才能正确的使用。</p>
<h1 id="2-jQuery对象与DOM对象"><a href="#2-jQuery对象与DOM对象" class="headerlink" title="2.jQuery对象与DOM对象"></a>2.jQuery对象与DOM对象</h1><p>通过一个简单的例子，简单区分下jQuery对象与DOM对象：<br>    </p><p></p>
<p>我们要获取页面上这个id为imooc的p元素，然后给这个文本节点增加一段文字：“您好！通过慕课网学习jQuery才是最佳的途径”，并且让文字颜色变成红色。</p>
<p>普通处理，通过标准JavaScript处理：</p>
<pre><code>var p = document.getElementById(&apos;imooc&apos;);
p.innerHTML = &apos;您好！通过慕课网学习jQuery才是最佳的途径&apos;;
p.style.color = &apos;red&apos;;
</code></pre><p>通过原生DOM模型提供的document.getElementById(“imooc”) 方法获取的DOM元素就是一个DOM对象，再通过innerHTML与style属性处理文本与颜色。</p>
<p>jQuery的处理：</p>
<pre><code>var $p = $(&apos;#imooc&apos;);
$p.html(&apos;您好！通过慕课网学习jQuery才是最佳的途径&apos;).css(&apos;color&apos;,&apos;red&apos;);
</code></pre><p>通过$(‘#imooc’)方法会得到一个$p的jQuery对象，$p是一个类数组对象。这个对象里面包含了DOM对象的信息，然后封装了很多操作方法，调用自己的方法html与css，得到的效果与标准的JavaScript处理结果是一致的。</p>
<h1 id="3-jQuery对象转化成DOM对象"><a href="#3-jQuery对象转化成DOM对象" class="headerlink" title="3.jQuery对象转化成DOM对象"></a>3.jQuery对象转化成DOM对象</h1><p>在很多场景中，我们需要jQuery与DOM能够相互的转换，它们都是可以操作的DOM元素，jQuery是一个类数组对象，而DOM对象就是一个单独的DOM元素。</p>
<p><strong>如何把jQuery对象转成DOM对象？</strong></p>
<h3 id="1-利用数组下标的方式读取到jQuery中的DOM对象"><a href="#1-利用数组下标的方式读取到jQuery中的DOM对象" class="headerlink" title="(1).利用数组下标的方式读取到jQuery中的DOM对象"></a>(1).利用数组下标的方式读取到jQuery中的DOM对象</h3><p>HTML代码</p>
<div>元素一</div><br><div>元素二</div><br><div>元素三</div>

<p>JavaScript代码</p>
<pre><code>var $div = $(&apos;div&apos;) //jQuery对象
var div = $div[0] //转化成DOM对象
div.style.color = &apos;red&apos; //操作dom对象的属性
</code></pre><p>用jQuery找到所有的div元素（3个），因为jQuery对象也是一个数组结构，可以通过数组下标索引找到第一个div元素，通过返回的div对象，调用它的style属性修改第一个div元素的颜色。这里需要注意的一点是，数组的索引是从0开始的，也就是第一个元素下标是0</p>
<h3 id="2-通过jQuery自带的get-方法"><a href="#2-通过jQuery自带的get-方法" class="headerlink" title="(2).通过jQuery自带的get()方法"></a>(2).通过jQuery自带的get()方法</h3><p>jQuery对象自身提供一个.get() 方法允许我们直接访问jQuery对象中相关的DOM节点，get方法中提供一个元素的索引：</p>
<pre><code>var $div = $(&apos;div&apos;) //jQuery对象
var div = $div.get(0) //通过get方法，转化成DOM对象
div.style.color = &apos;red&apos; //操作dom对象的属性
</code></pre><p>其实我们翻开源码，看看就知道了，get方法就是利用的第一种方式处理的，只是包装成一个get让开发者更直接方便的使用。</p>
<h1 id="4-DOM对象转化成jQuery对象"><a href="#4-DOM对象转化成jQuery对象" class="headerlink" title="4.DOM对象转化成jQuery对象"></a>4.DOM对象转化成jQuery对象</h1><p>相比较jQuery转化成DOM，开发中更多的情况是把一个dom对象加工成jQuery对象。$(参数)是一个多功能的方法，通过传递不同的参数而产生不同的作用。</p>
<p>如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象</p>
<p>通过$(dom)方法将普通的dom对象加工成jQuery对象之后，我们就可以调用jQuery的方法了</p>
<p>HTML代码</p>
<div>元素一</div><br><div>元素二</div><br><div>元素三</div>

<p>JavaScript代码</p>
<pre><code>var div = document.getElementsByTagName(&apos;div&apos;); //dom对象
var $div = $(div); //jQuery对象
var $first = $div.first(); //找到第一个div元素
$first.css(&apos;color&apos;, &apos;red&apos;); //给第一个元素设置颜色
</code></pre><p>通过getElementsByTagName获取到所有div节点的元素，结果是一个dom合集对象，不过这个对象是一个数组合集(3个div元素)。通过$(div)方法转化成jQuery对象，通过调用jQuery对象中的first与css方法查找第一个元素并且改变其颜色。</p>
<h1 id="5-jQuery选择器之id选择器"><a href="#5-jQuery选择器之id选择器" class="headerlink" title="5.jQuery选择器之id选择器"></a>5.jQuery选择器之id选择器</h1><pre><code>$( &quot;#id&quot; )
</code></pre><p>id是唯一的，每个id值在一个页面中只能使用一次。如果多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素。但这种行为不应该发生;有超过一个元素的页面使用相同的id是无效的</p>
<h1 id="6-jQuery选择器之类选择器"><a href="#6-jQuery选择器之类选择器" class="headerlink" title="6.jQuery选择器之类选择器"></a>6.jQuery选择器之类选择器</h1><pre><code>$( &quot;.class&quot; )
</code></pre><h1 id="7-jQuery选择器之元素选择器"><a href="#7-jQuery选择器之元素选择器" class="headerlink" title="7.jQuery选择器之元素选择器"></a>7.jQuery选择器之元素选择器</h1><pre><code>$( &quot;element&quot; )
</code></pre><h1 id="8-jQuery选择器之全选择器（-选择器）"><a href="#8-jQuery选择器之全选择器（-选择器）" class="headerlink" title="8.jQuery选择器之全选择器（*选择器）"></a>8.jQuery选择器之全选择器（*选择器）</h1><pre><code>$( &quot;*&quot; )
</code></pre><h1 id="9-jQuery选择器之层级选择器"><a href="#9-jQuery选择器之层级选择器" class="headerlink" title="9.jQuery选择器之层级选择器"></a>9.jQuery选择器之层级选择器</h1><p><img src="http://oncweb6po.bkt.clouddn.com/5590e98b0001f60d06130229.jpg" alt=""></p>
<ol>
<li>层级选择器都有一个参考节点</li>
</ol>
<ol>
<li>后代选择器包含子选择器的选择的内容</li>
</ol>
<ol>
<li>一般兄弟选择器包含相邻兄弟选择的内容</li>
</ol>
<ol>
<li>相邻兄弟选择器和一般兄弟选择器所选择到的元素，必须在同一个父元素下</li>
</ol>
<h1 id="10-jQuery选择器之基本筛选选择器"><a href="#10-jQuery选择器之基本筛选选择器" class="headerlink" title="10.jQuery选择器之基本筛选选择器"></a>10.jQuery选择器之基本筛选选择器</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57cd1df2000146de06020498.jpg" alt=""></p>
<ol>
<li>:eq(), :lt(), :gt(), :even, :odd 用来筛选他们前面的匹配表达式的集合元素，根据之前匹配的元素在进一步筛选，注意jQuery合集都是从0开始索引</li>
</ol>
<ol>
<li>gt是一个段落筛选，从指定索引的下一个开始，gt(1) 实际从2开始</li>
</ol>
<h1 id="11-jQuery选择器之内容筛选选择器"><a href="#11-jQuery选择器之内容筛选选择器" class="headerlink" title="11.jQuery选择器之内容筛选选择器"></a>11.jQuery选择器之内容筛选选择器</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57cd20bf0001a97f05290214.jpg" alt=""></p>
<ol>
<li>:contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素</li>
</ol>
<ol>
<li>如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。</li>
</ol>
<ol>
<li>:parent与:empty是相反的，两者所涉及的子元素，包括文本节点</li>
</ol>
<h1 id="12-jQuery选择器之可见性筛选选择器"><a href="#12-jQuery选择器之可见性筛选选择器" class="headerlink" title="12.jQuery选择器之可见性筛选选择器"></a>12.jQuery选择器之可见性筛选选择器</h1><p><img src="http://oncweb6po.bkt.clouddn.com/5590f6de0001e2b204460106.jpg" alt=""></p>
<p>元素可以被认为是隐藏的几个情况：</p>
<ol>
<li>他们的CSS display值是none。</li>
</ol>
<ol>
<li>他们是type=”hidden”的表单元素。</li>
</ol>
<ol>
<li>它们的宽度和高度都显式设置为0。</li>
</ol>
<ol>
<li>一个祖先元素是隐藏的，因此该元素是不会在页面上显示。</li>
</ol>
<h1 id="13-jQuery选择器之属性筛选选择器"><a href="#13-jQuery选择器之属性筛选选择器" class="headerlink" title="13.jQuery选择器之属性筛选选择器"></a>13.jQuery选择器之属性筛选选择器</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57d654200001c46507360560.jpg" alt=""></p>
<p>在这么多属性选择器中[attr=”value”]和[attr*=”value”]是最实用的</p>
<pre><code>[attr=&quot;value&quot;]能帮我们定位不同类型的元素，特别是表单form元素的操作，比如说input[type=&quot;text&quot;],input[type=&quot;checkbox&quot;]等
[attr*=&quot;value&quot;]能在网站中帮助我们匹配不同类型的文件
</code></pre><h1 id="14-jQuery选择器之子元素筛选选择器"><a href="#14-jQuery选择器之子元素筛选选择器" class="headerlink" title="14.jQuery选择器之子元素筛选选择器"></a>14.jQuery选择器之子元素筛选选择器</h1><p>子元素筛选选择器不常使用，其筛选规则比起其它的选择器稍微要复杂点</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/559105da0001301105960331.jpg" alt=""></p>
<ol>
<li>:first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1)</li>
</ol>
<ol>
<li>:last 只匹配一个单独的元素， :last-child 选择器可以匹配多个元素：即，为每个父级元素匹配最后一个子元素</li>
</ol>
<ol>
<li>如果子元素只有一个的话，:first-child与:last-child是同一个</li>
</ol>
<ol>
<li>:only-child匹配某个元素是父元素中唯一的子元素，就是说当前子元素是父元素中唯一的元素，则匹配</li>
</ol>
<ol>
<li>jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的</li>
</ol>
<ol>
<li>nth-child(n) 与 :nth-last-child(n) 的区别前者是从前往后计算，后者从后往前计算</li>
</ol>
<h1 id="15-jQuery选择器之表单元素选择器"><a href="#15-jQuery选择器之表单元素选择器" class="headerlink" title="15.jQuery选择器之表单元素选择器"></a>15.jQuery选择器之表单元素选择器</h1><p><img src="http://oncweb6po.bkt.clouddn.com/5592040d0001f8eb04940441.jpg" alt=""></p>
<p>除了input筛选选择器，几乎每个表单类别筛选器都对应一个input元素的type值。大部分表单类别筛选器可以使用属性筛选器替换。比如 $(‘:password’) == $(‘[type=password]’)</p>
<h1 id="16-jQuery选择器之表单对象属性筛选选择器"><a href="#16-jQuery选择器之表单对象属性筛选选择器" class="headerlink" title="16.jQuery选择器之表单对象属性筛选选择器"></a>16.jQuery选择器之表单对象属性筛选选择器</h1><p><img src="http://oncweb6po.bkt.clouddn.com/55920c2f0001198b04940201.jpg" alt=""></p>
<ol>
<li>选择器适用于复选框和单选框，对于下拉框元素, 使用 :selected 选择器</li>
</ol>
<ol>
<li>在某些浏览器中，选择器:checked可能会错误选取到<option>元素，所以保险起见换用选择器input:checked，确保只会选取元素</option></li>
</ol>
<h1 id="17-jQuery选择器之特殊选择器this"><a href="#17-jQuery选择器之特殊选择器this" class="headerlink" title="17.jQuery选择器之特殊选择器this"></a>17.jQuery选择器之特殊选择器this</h1><pre><code>HTML
p.addEventListener(&apos;click&apos;,function(){
    //this === p
    //以下两者的修改都是等价的
    this.style.color = &quot;red&quot;;
    p.style.color = &quot;red&quot;;
},false);

 this.style.color = &quot;red&quot;
</code></pre><hr>
<pre><code>$(&apos;p&apos;).click(function(){
    //把p元素转化成jQuery的对象
    var $this= $(this) 
    $this.css(&apos;color&apos;,&apos;red&apos;)
})
</code></pre><blockquote>
<p>this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。<br>$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。</p>
</blockquote>
<h1 id="18-jQuery的属性与样式之-attr-与-removeAttr"><a href="#18-jQuery的属性与样式之-attr-与-removeAttr" class="headerlink" title="18.jQuery的属性与样式之.attr()与.removeAttr()"></a>18.jQuery的属性与样式之.attr()与.removeAttr()</h1><h3 id="1-attr-有4个表达式"><a href="#1-attr-有4个表达式" class="headerlink" title="(1).attr()有4个表达式"></a>(1).attr()有4个表达式</h3><ol>
<li>attr(传入属性名)：获取属性的值</li>
</ol>
<ol>
<li>attr(属性名, 属性值)：设置属性的值</li>
</ol>
<ol>
<li>attr(属性名,函数值)：设置属性的函数值</li>
</ol>
<ol>
<li>attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … }</li>
</ol>
<h3 id="2-removeAttr-删除方法"><a href="#2-removeAttr-删除方法" class="headerlink" title="(2).removeAttr()删除方法"></a>(2).removeAttr()删除方法</h3><p>.removeAttr( attributeName ) : 为匹配的元素集合中的每个元素中移除一个属性（attribute）</p>
<h3 id="3-注意的问题"><a href="#3-注意的问题" class="headerlink" title="(3).注意的问题"></a>(3).注意的问题</h3><p>dom中有个概念的区分：Attribute和Property翻译出来都是“属性”，《js高级程序设计》书中翻译为“特性”和“属性”。简单理解，Attribute就是dom节点自带的属性</p>
<blockquote>
<p>获取Attribute就需要用attr，获取Property就需要用prop</p>
</blockquote>
<h1 id="19-jQuery的属性与样式之html-及-text"><a href="#19-jQuery的属性与样式之html-及-text" class="headerlink" title="19.jQuery的属性与样式之html()及.text()"></a>19.jQuery的属性与样式之html()及.text()</h1><p>读取、修改元素的html结构或者元素的文本内容是常见的DOM操作，jQuery针对这样的处理提供了2个便捷的方法.html()与.text()</p>
<h3 id="1-html-方法"><a href="#1-html-方法" class="headerlink" title="(1).html()方法"></a>(1).html()方法</h3><p>获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容，具体有3种用法：</p>
<ol>
<li>.html() 不传入值，就是获取集合中第一个匹配元素的HTML内容</li>
</ol>
<ol>
<li>.html( htmlString )  设置每一个匹配元素的html内容</li>
</ol>
<ol>
<li>.html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数</li>
</ol>
<h3 id="2-注意事项："><a href="#2-注意事项：" class="headerlink" title="(2).注意事项："></a>(2).注意事项：</h3><p>.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容）</p>
<h3 id="3-text-方法"><a href="#3-text-方法" class="headerlink" title="(3).text()方法"></a>(3).text()方法</h3><p>得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。，具体有3种用法：</p>
<ol>
<li>.text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代</li>
</ol>
<ol>
<li>.text( textString ) 用于设置匹配元素内容的文本</li>
</ol>
<ol>
<li>.text( function(index, text) ) 用来返回设置文本内容的一个函数</li>
</ol>
<h3 id="4-注意事项："><a href="#4-注意事项：" class="headerlink" title="(4).注意事项："></a>(4).注意事项：</h3><p>.text()结果返回一个字符串，包含所有匹配元素的合并文本</p>
<h3 id="5-html与-text的异同"><a href="#5-html与-text的异同" class="headerlink" title="(5).html与.text的异同:"></a>(5).html与.text的异同:</h3><ol>
<li>.html与.text的方法操作是一样，只是在具体针对处理对象不同</li>
</ol>
<ol>
<li>.html处理的是元素内容，.text处理的是文本内容<br>.html只能使用在HTML文档中，.text 在XML 和 HTML 文档中都能使用</li>
</ol>
<ol>
<li>如果处理的对象只有一个子文本节点，那么html处理的结果与text是一样的</li>
</ol>
<ol>
<li>火狐不支持innerText属性，用了类似的textContent属性，.text()方法综合了2个属性的支持，所以可以兼容所有浏览器</li>
</ol>
<h1 id="20-jQuery的属性与样式之-val"><a href="#20-jQuery的属性与样式之-val" class="headerlink" title="20.jQuery的属性与样式之.val()"></a>20.jQuery的属性与样式之.val()</h1><p>jQuery中有一个.val()方法主要是用于处理表单元素的值，比如 input, select 和 textarea。</p>
<h3 id="1-val-方法"><a href="#1-val-方法" class="headerlink" title="(1).val()方法"></a>(1).val()方法</h3><ol>
<li>.val()无参数，获取匹配的元素集合中第一个元素的当前值</li>
</ol>
<ol>
<li>.val( value )，设置匹配的元素集合中每个元素的值</li>
</ol>
<ol>
<li>.val( function ) ，一个用来返回设置值的函数<h3 id="2-注意事项：-1"><a href="#2-注意事项：-1" class="headerlink" title="(2)注意事项："></a>(2)注意事项：</h3></li>
</ol>
<ol>
<li>通过.val()处理select元素， 当没有选择项被选中，它返回null</li>
</ol>
<ol>
<li>.val()方法多用来设置表单的字段的值</li>
</ol>
<ol>
<li>如果select元素有multiple（多选）属性，并且至少一个选择项被选中， .val()方法返回一个数组，这个数组包含每个选中选择项的值<h3 id="3-html-text-和-val-的差异总结："><a href="#3-html-text-和-val-的差异总结：" class="headerlink" title="(3).html(),.text()和.val()的差异总结："></a>(3).html(),.text()和.val()的差异总结：</h3></li>
</ol>
<ol>
<li>.html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。</li>
</ol>
<ol>
<li>.html(htmlString),.text(textString)和.val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。</li>
</ol>
<ol>
<li>.html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。</li>
</ol>
<h1 id="21-jQuery的属性与样式之增加样式-addClass"><a href="#21-jQuery的属性与样式之增加样式-addClass" class="headerlink" title="21.jQuery的属性与样式之增加样式.addClass()"></a>21.jQuery的属性与样式之增加样式.addClass()</h1><p>通过动态改变类名（class），可以让其修改元素呈现出不同的效果。在HTML结构中里，多个class以空格分隔，当一个节点（或称为一个标签）含有多个class时，DOM元素响应的className属性获取的不是class名称的数组，而是一个含有空格的字符串，这就使得多class操作变得很麻烦。同样的jQuery开发者也考虑到这种情况，增加了一个.addClass()方法，用于动态增加class类名</p>
<h3 id="1-addClass-className-方法"><a href="#1-addClass-className-方法" class="headerlink" title="(1).addClass( className )方法"></a>(1).addClass( className )方法</h3><ol>
<li>.addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名</li>
</ol>
<ol>
<li>.addClass( function(index, currentClass) ) : 这个函数返回一个或更多用空格隔开的要增加的样式名<h3 id="2-注意事项：-2"><a href="#2-注意事项：-2" class="headerlink" title="(2).注意事项："></a>(2).注意事项：</h3>.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上</li>
</ol>
<h3 id="3"><a href="#3" class="headerlink" title="(3)."></a>(3).</h3><p>简单的描述下：在p元素增加一个newClass的样式</p>
<pre><code>&lt;p class=&quot;orgClass&quot;&gt;
$(&quot;p&quot;).addClass(&quot;newClass&quot;)
</code></pre><p>那么p元素的class实际上是 class=”orgClass newClass”样式只会在原本的类上继续增加，通过空格分隔</p>
<h1 id="22-jQuery的属性与样式之删除样式-removeClass"><a href="#22-jQuery的属性与样式之删除样式-removeClass" class="headerlink" title="22.jQuery的属性与样式之删除样式.removeClass()"></a>22.jQuery的属性与样式之删除样式.removeClass()</h1><p>jQuery通过.addClass()方法可以很便捷的增加样式。如果需要样式之间的切换，同样jQuery提供了一个很方便的.removeClass()，它的作用是从匹配的元素中删除全部或者指定的class</p>
<h3 id="1-removeClass-方法"><a href="#1-removeClass-方法" class="headerlink" title="(1).removeClass( )方法"></a>(1).removeClass( )方法</h3><ol>
<li>.removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名</li>
</ol>
<ol>
<li>.removeClass( function(index, class) ) ： 一个函数，返回一个或多个将要被移除的样式名<h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="(2).注意事项"></a>(2).注意事项</h3>如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除</li>
</ol>
<h1 id="23-jQuery的属性与样式之切换样式-toggleClass"><a href="#23-jQuery的属性与样式之切换样式-toggleClass" class="headerlink" title="23.jQuery的属性与样式之切换样式.toggleClass()"></a>23.jQuery的属性与样式之切换样式.toggleClass()</h1><p>在做某些效果的时候，可能会针对同一节点的某一个样式不断的切换，也就是addClass与removeClass的互斥切换，比如隔行换色效果</p>
<p>jQuery提供一个toggleClass方法用于简化这种互斥的逻辑，通过toggleClass方法动态添加删除Class，一次执行相当于addClass，再次执行相当于removeClass</p>
<h3 id="1-toggleClass-方法："><a href="#1-toggleClass-方法：" class="headerlink" title="(1).toggleClass( )方法："></a>(1).toggleClass( )方法：</h3><p>在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类</p>
<ol>
<li>.toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名</li>
</ol>
<ol>
<li>.toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除</li>
</ol>
<ol>
<li>.toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值</li>
</ol>
<ol>
<li>.toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数</li>
</ol>
<h3 id="2-注意事项：-3"><a href="#2-注意事项：-3" class="headerlink" title="(2).注意事项："></a>(2).注意事项：</h3><ol>
<li>toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加</li>
</ol>
<ol>
<li>toggleClass会保留原有的Class名后新增，通过空格隔开</li>
</ol>
<h1 id="24-jQuery的属性与样式之样式操作-css"><a href="#24-jQuery的属性与样式之样式操作-css" class="headerlink" title="24.jQuery的属性与样式之样式操作.css()"></a>24.jQuery的属性与样式之样式操作.css()</h1><p>通过JavaScript获取dom元素上的style属性，我们可以动态的给元素赋予样式属性。在jQuery中我们要动态的修改style属性我们只要使用css()方法就可以实现了</p>
<p><strong>.css() 方法：获取元素样式属性的计算值或者设置元素的CSS属性</strong></p>
<h3 id="1-获取："><a href="#1-获取：" class="headerlink" title="(1).获取："></a>(1).获取：</h3><ol>
<li>.css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值</li>
</ol>
<ol>
<li>.css( propertyNames )：传递一组数组，返回一个对象结果<h3 id="2-设置："><a href="#2-设置：" class="headerlink" title="(2).设置："></a>(2).设置：</h3></li>
</ol>
<ol>
<li><p>.css(propertyName, value )：设置CSS</p>
<p> css(“background-color”,”red”)<br> css(“backgroundColor”,”yellow”)</p>
</li>
<li><p>.css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理</p>
</li>
</ol>
<ol>
<li><p>.css( properties )：可以传一个对象，同时设置多个样式</p>
<pre><code>css({
            &apos;font-size&apos;        :&quot;15px&quot;,
            &quot;background-color&quot; :&quot;#40E0D0&quot;,
            &quot;border&quot;           :&quot;1px solid red&quot;
        })
</code></pre></li>
</ol>
<h3 id="3-注意事项："><a href="#3-注意事项：" class="headerlink" title="(3).注意事项："></a>(3).注意事项：</h3><ol>
<li>浏览器属性获取方式不同，在获取某些值的时候都jQuery采用统一的处理，比如颜色采用RBG，尺寸采用px</li>
</ol>
<ol>
<li>.css()方法支持驼峰写法与大小写混搭的写法，内部做了容错的处理</li>
</ol>
<ol>
<li>当一个数只被作为值（value）的时候， jQuery会将其转换为一个字符串，并添在字符串的结尾处添加px，例如 .css(“width”,50}) 与 .css(“width”,”50px”})一样</li>
</ol>
<h1 id="25-jQuery的属性与样式之-css-与-addClass-设置样式的区别"><a href="#25-jQuery的属性与样式之-css-与-addClass-设置样式的区别" class="headerlink" title="25.jQuery的属性与样式之.css()与.addClass()设置样式的区别"></a>25.jQuery的属性与样式之.css()与.addClass()设置样式的区别</h1><h3 id="1-可维护性："><a href="#1-可维护性：" class="headerlink" title="(1).可维护性："></a>(1).可维护性：</h3><p>.addClass()的本质是通过定义个class类的样式规则，给元素添加一个或多个类。css方法是通过JavaScript大量代码进行改变元素的样式</p>
<p>通过.addClass()我们可以批量的给相同的元素设置统一规则，变动起来比较方便，可以统一修改删除。如果通过.css()方法就需要指定每一个元素是一一的修改，日后维护也要一一的修改，比较麻烦</p>
<h3 id="2-灵活性："><a href="#2-灵活性：" class="headerlink" title="(2).灵活性："></a>(2).灵活性：</h3><p>通过.css()方式可以很容易动态的去改变一个样式的属性，不需要在去繁琐的定义个class类的规则。一般来说在不确定开始布局规则，通过动态生成的HTML代码结构中，都是通过.css()方法处理的</p>
<h3 id="3-样式值："><a href="#3-样式值：" class="headerlink" title="(3).样式值："></a>(3).样式值：</h3><p>.addClass()本质只是针对class的类的增加删除，不能获取到指定样式的属性的值，.css()可以获取到指定的样式值。</p>
<h3 id="4-样式的优先级"><a href="#4-样式的优先级" class="headerlink" title="(4).样式的优先级"></a>(4).样式的优先级</h3><p>通过.css方法设置的样式属性优先级要高于.addClass方法</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="(5).总结"></a>(5).总结</h3><p>.addClass与.css方法各有利弊，一般是静态的结构，都确定了布局的规则，可以用addClass的方法，增加统一的类规则</p>
<p>如果是动态的HTML结构，在不确定规则，或者经常变化的情况下，一般多考虑.css()方式</p>
<h1 id="26-jQuery的属性与样式之元素的数据存储"><a href="#26-jQuery的属性与样式之元素的数据存储" class="headerlink" title="26.jQuery的属性与样式之元素的数据存储"></a>26.jQuery的属性与样式之元素的数据存储</h1><p>.data( key, value ) //实例接口,存数据<br>.data( key ) //实例接口,存数据</p>
<p>删除</p>
<p>jQuery.removeData( element [, name ] )<br>.removeData( [name ] )</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/js深入浅出/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/js深入浅出/" itemprop="url">js深入浅出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:25:00+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h1><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><blockquote>
<p>number</p>
<p>string</p>
<p>boolean</p>
<p>null</p>
<p>undefined</p>
</blockquote>
<h3 id="object-对象"><a href="#object-对象" class="headerlink" title="object 对象"></a>object 对象</h3><blockquote>
<p>Function</p>
<p>Array</p>
<p>Date</p>
</blockquote>
<h2 id="2-隐式转换"><a href="#2-隐式转换" class="headerlink" title="2.隐式转换"></a>2.隐式转换</h2><p>字符串变数字</p>
<blockquote>
<p>num - 0</p>
</blockquote>
<p>数字变字符串</p>
<blockquote>
<p>num + ‘’</p>
</blockquote>
<pre><code>37” – 7 // 30
“37” + 7 // 377
</code></pre><h3 id="a-b"><a href="#a-b" class="headerlink" title="a===b"></a>a===b</h3><p>类型不同</p>
<blockquote>
<p>返回false</p>
</blockquote>
<p>类型相同</p>
<blockquote>
<p>NaN ≠ NaN</p>
<p>new Object ≠ new Object</p>
<p>null === null</p>
<p>undefined === undefined</p>
</blockquote>
<h3 id="a-b-1"><a href="#a-b-1" class="headerlink" title="a == b"></a>a == b</h3><p>类型相同</p>
<blockquote>
<p>同===</p>
</blockquote>
<p>类型不同，尝试类型转换和比较:</p>
<blockquote>
<p>null == undefined 相等</p>
<p>number == string 转number<br>1 == “1.0” // true</p>
<p>boolean == ?  转number<br>1 == true  // true</p>
<p>object == number | string<br>尝试对象转为基本类型<br>new String(‘hi’) == ‘hi’ // true</p>
<p>其它：false</p>
</blockquote>
<h2 id="3-包装对象"><a href="#3-包装对象" class="headerlink" title="3.包装对象"></a>3.包装对象</h2><pre><code>var a = “string”;
alert(a.length);
a.t = 3;
alert(a.t);
</code></pre><p>当对一个字符串（或数组或数字或布尔）（基本类型）进行对象访问的时候，会创建一个对象，当访问完毕，对象立刻销毁，所以a.t设置完后，不存在</p>
<h2 id="4-类型检测"><a href="#4-类型检测" class="headerlink" title="4.类型检测"></a>4.类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><pre><code>typeof 100 === “number”
typeof true === “boolean”
typeof function () {} === “function”

typeof(undefined) ) === “undefined”
typeof(new Object() ) === “object”
typeof( [1， 2] ) === “object”
typeof(NaN ) === “number”
**typeof(null) === “object”**
</code></pre><h3 id="obj-instanceof-Object"><a href="#obj-instanceof-Object" class="headerlink" title="obj instanceof Object"></a>obj instanceof Object</h3><pre><code>[1, 2] instanceof Array === true
new Object() instanceof Array === false
</code></pre><p>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>
<p>Instanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/181635468939277.png" alt=""></p>
<p><strong>Caution！不同window或iframe间的对象类型检测不能使用instanceof！</strong></p>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><pre><code>Object.prototype.toString.apply([]); === “[object Array]”;
Object.prototype.toString.apply(function(){}); === “[object Function]”;
Object.prototype.toString.apply(null); === “[object Null]”
Object.prototype.toString.apply(undefined); === “[object Undefined]”

IE6/7/8 Object.prototype.toString.apply(null) 返回”[object Object]”
</code></pre><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor会指向构造这个对象的构造器或构造函数，constructor可以改写，使用时要小心</p>
<h3 id="duck-type"><a href="#duck-type" class="headerlink" title="duck type"></a>duck type</h3><p>通过一些特征来判断</p>
<h2 id="类型检测小结"><a href="#类型检测小结" class="headerlink" title="类型检测小结"></a>类型检测小结</h2><blockquote>
<p>typeof</p>
<p>适合基本类型及function检测，遇到null失效。</p>
<p>[[Class]]</p>
<p>通过{}.toString拿到，适合内置对象和基元类型，遇到null和undefined失效(IE678等返回[object Object])。</p>
<p>instanceof</p>
<p>适合自定义对象，也可以用来检测原生对象，在不同iframe和window间检测时失效。</p>
</blockquote>
<h1 id="二-表达式和运算符"><a href="#二-表达式和运算符" class="headerlink" title="二.表达式和运算符"></a>二.表达式和运算符</h1><p>表达式是一种JS短语，可使JS解释器用来产生一个值。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="1-原始表达式"><a href="#1-原始表达式" class="headerlink" title="1.原始表达式"></a>1.原始表达式</h3><blockquote>
<p>1.常量、直接量</p>
<p>3.14, “test”</p>
<p>2.关键字</p>
<p>null, this, true</p>
<p>3.变量</p>
<p>i, k, j</p>
<p>复合表达式 10*20</p>
</blockquote>
<h3 id="2-数组、对象的初始化表达式"><a href="#2-数组、对象的初始化表达式" class="headerlink" title="2.数组、对象的初始化表达式"></a>2.数组、对象的初始化表达式</h3><p>[1, 2] </p>
<blockquote>
<p>new Array(1, 2);</p>
</blockquote>
<p>[1, , , 4]</p>
<blockquote>
<p>[1, undefined, undefined , 4]</p>
</blockquote>
<p>{ x : 1, y : 2} </p>
<blockquote>
<p>var o = new Object();<br>o.x = 1; o.y = 2;</p>
</blockquote>
<h3 id="3-函数表达式"><a href="#3-函数表达式" class="headerlink" title="3.函数表达式"></a>3.函数表达式</h3><p>var fe = function(){};</p>
<h3 id="4-属性访问表达式"><a href="#4-属性访问表达式" class="headerlink" title="4.属性访问表达式"></a>4.属性访问表达式</h3><p>var o = {x : 1};</p>
<blockquote>
<p>o.x</p>
<p>o[‘x’]</p>
</blockquote>
<h3 id="5-调用表达式"><a href="#5-调用表达式" class="headerlink" title="5.调用表达式"></a>5.调用表达式</h3><p>func();</p>
<h3 id="6-对象创建表达式"><a href="#6-对象创建表达式" class="headerlink" title="6.对象创建表达式"></a>6.对象创建表达式</h3><p>new Func(1, 2);<br>new Object;</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>一元 +num</p>
<p>二元 a + b</p>
<p>三元 c ? a : b</p>
<p>赋值 x += 1</p>
<p>比较 a == b</p>
<p>算术 a - b</p>
<p>位 a | b</p>
<p>逻辑 exp1 &amp;&amp; exp2</p>
<p>字符串 “a” + “b”</p>
<p><strong>特殊</strong> </p>
<h3 id="1-delete-obj-x"><a href="#1-delete-obj-x" class="headerlink" title="1.delete obj.x"></a>1.delete obj.x</h3><pre><code>var obj = {x : 1};
obj.x;  // 1
delete obj.x;
obj.x;  // undefined

var obj = {};
Object.defineProperty(obj, &apos;x&apos;, {
    configurable : false, 
    value : 1
});
delete obj.x; // false
obj.x;// 1
</code></pre><blockquote>
<p><strong>神奇的Object.defineProperty</strong></p>
</blockquote>
<pre><code>var a={}
Object.defineProperty(a,&quot;b&quot;,{value:123})
console.log(a,b);//123
</code></pre><p> 传入参数</p>
<blockquote>
<p>第一个参数:目标对象</p>
<p>第二个参数:需要定义的属性或方法的名字。</p>
<p>第三个参数:目标属性所拥有的特性。(默认为false)（descriptor）</p>
</blockquote>
<p>前两个参数不多说了，一看代码就懂，主要看第三个参数descriptor，看看有哪些取值</p>
<blockquote>
<p>value:属性的值(不用多说了)</p>
<pre><code>var a= {}
Object.defineProperty(a,&quot;b&quot;,{
  value:123
})
console.log(a.b);//123
</code></pre><p>writable:如果为false，属性的值就不能被重写,只能为只读了<br>    var a = {}; </p>
<pre><code>Object.defineProperty(o, &quot;b&quot;, { 
value : 123,
writable : false });

console.log(a.b); // 打印 37
a.b = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）
console.log(o.a); // 打印 37， 赋值不起作用。
</code></pre><p>configurable:总开关，一旦为false，就不能再设置他的（value，writable，configurable）</p>
<p>enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。</p>
<pre><code>var a= {}
Object.defineProperty(a,&quot;b&quot;,{
  value:3445,
  enumerable:true
})
console.log(Object.keys(a));// 打印[&quot;b&quot;]
改为false

var a= {}
Object.defineProperty(a,&quot;b&quot;,{
  value:3445,
  enumerable:false //注意咯这里改了
})
console.log(Object.keys(a));// 打印[]
</code></pre><p>get:一会细说</p>
<p>set:一会细说</p>
</blockquote>
<h3 id="2-in"><a href="#2-in" class="headerlink" title="2.in"></a>2.in</h3><pre><code>window.x = 1;
‘x’ in window; // true
</code></pre><h3 id="3-instanceof-typeof"><a href="#3-instanceof-typeof" class="headerlink" title="3.instanceof, typeof"></a>3.instanceof, typeof</h3><pre><code>{} instanceof Object// true
typeof 100 === ‘number’ // true
</code></pre><h3 id="4-new"><a href="#4-new" class="headerlink" title="4.new"></a>4.new</h3><pre><code>function Foo(){}
Foo.prototype.x = 1;
var obj = new Foo();
obj.x;  // 1
obj.hasOwnProperty(&apos;x&apos;); // false
obj.__proto__.hasOwnProperty(&apos;x&apos;); // true
</code></pre><blockquote>
<p>hasOwnProperty 本身的属性</p>
<p><strong>proto</strong>即原型，obj这个对象的原型指向Foo这个函数的prototype</p>
</blockquote>
<h3 id="5-this"><a href="#5-this" class="headerlink" title="5.this"></a>5.this</h3><pre><code>this;  // window (浏览器)
var obj = {
func : function(){return this;}
};
obj.func(); // obj
</code></pre><h3 id="6-void"><a href="#6-void" class="headerlink" title="6.void"></a>6.void</h3><pre><code>void 0  // undefined
void(0) // undefined
</code></pre><h1 id="三-语句"><a href="#三-语句" class="headerlink" title="三.语句"></a>三.语句</h1><h3 id="1-block"><a href="#1-block" class="headerlink" title="1.block"></a>1.block</h3><p>请注意：没有块级作用域</p>
<pre><code>var i = 0
for (; i &lt; 10; i++) {
var str = &quot;hi&quot;;
console.log(str);
}
</code></pre><p>为了防止混淆，把for循环中的定义变量var，拿出去写</p>
<h3 id="2-var"><a href="#2-var" class="headerlink" title="2.var"></a>2.var</h3><pre><code>var a = b = 1;
</code></pre><p>b隐式创建了全局变量（所以一条语句定义多个变量，一定要分开）</p>
<h3 id="3-try-catch"><a href="#3-try-catch" class="headerlink" title="3.try catch"></a>3.try catch</h3><pre><code>try {
   throw &quot;test&quot;;
} catch (ex) {
console.log(ex); // test
} finally {
console.log(&apos;finally&apos;);
}
</code></pre><p>先执行try catch中的代码，如果抛出了异常，会由catch从句捕获并且执行，如果没有发生异常，catch部分的代码被忽略掉，但不管是否出现异常，都会执行finally从句；try后面必须接一个catch或一个finally</p>
<pre><code>try {
try {
throw new Error(&quot;oops&quot;);
}
finally {
console.log(&quot;finally&quot;);
}
}
catch (ex) {
console.error(&quot;outer&quot;, ex.message);
}

&quot;finally&quot;
&quot;outer&quot; &quot;oops&quot;
</code></pre><hr>
<pre><code>try {
  try {
  throw new Error(&quot;oops&quot;);
  }
  catch (ex) {
console.error(&quot;inner&quot;, ex.message);
  }
  finally {
console.log(&quot;finally&quot;);
  }
}
catch (ex) {
  console.error(&quot;outer&quot;, ex.message);
}

&quot;inner&quot; &quot;oops&quot;
&quot;finally&quot;
</code></pre><hr>
<pre><code>try {
  try {
throw new Error(&quot;oops&quot;);
  }
  catch (ex) {
console.error(&quot;inner&quot;, ex.message);
throw ex;
  }
  finally {
console.log(&quot;finally&quot;);
  }
}
catch (ex) {
  console.error(&quot;outer&quot;, ex.message);
}

&quot;inner&quot; &quot;oops&quot;
&quot;finally&quot;
&quot;outer&quot; &quot;oops&quot;
</code></pre><h3 id="4-function"><a href="#4-function" class="headerlink" title="4.function"></a>4.function</h3><pre><code>fd(); // true
function fd() {
// do sth.
return true;
}
</code></pre><p>函数声明，会被前置处理掉</p>
<pre><code>fe(); // TypeError
var fe = function() {
// do sth.
};
</code></pre><p>函数表达式，不会提前处理</p>
<h3 id="5-for…in"><a href="#5-for…in" class="headerlink" title="5.for…in"></a>5.for…in</h3><pre><code>var p;
var obj = {x : 1, y: 2}

for (p in obj) {
}
</code></pre><ol>
<li>顺序不确定</li>
<li>enumerable为false时不会出现</li>
<li>for in对象属性时受原型链影响</li>
</ol>
<h3 id="6-switch"><a href="#6-switch" class="headerlink" title="6.switch"></a>6.switch</h3><h3 id="7-循环"><a href="#7-循环" class="headerlink" title="7.循环"></a>7.循环</h3><h3 id="8-with"><a href="#8-with" class="headerlink" title="8.with"></a>8.with</h3><pre><code>with ({x : 1}) {
console.log(x);
}

with (document.forms[0]) {
console.log(name.value);
}

var form = document.forms[0];
console.log(form.name.value);
</code></pre><p>通俗的理解就是，with代表了那个对象。可是这样写有几个缺点：（因此，应该采用变量取对象的方法）</p>
<p>让JS引擎优化更难</p>
<p>可读性差</p>
<p>可被变量定义代替</p>
<p>严格模式下被禁用</p>
<p><strong>修改当前的作用域</strong></p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>严格模式是一种特殊的执行模式，<br>它修复了部分语言上的不足，提供更强的错误检查，并增强安全性。</p>
<pre><code>function func() {
&apos;use strict&apos;;
}

 &apos;use strict&apos;;
function func() {

}
</code></pre><h3 id="1-不允许用with"><a href="#1-不允许用with" class="headerlink" title="1.不允许用with"></a>1.不允许用with</h3><pre><code>!function() {
    &apos;use strict&apos;;
     with({x : 1}) {
console.log(x);
  }
}(); //SyntaxError
</code></pre><h3 id="2-不允许未声明的变量被赋值"><a href="#2-不允许未声明的变量被赋值" class="headerlink" title="2.不允许未声明的变量被赋值"></a>2.不允许未声明的变量被赋值</h3><pre><code>!function() {
    &apos;use strict&apos;;
     x = 1;
  console.log(window.x);
}(); //ReferenceError
</code></pre><h3 id="3-arguments变为参数的静态副本"><a href="#3-arguments变为参数的静态副本" class="headerlink" title="3.arguments变为参数的静态副本"></a>3.arguments变为参数的静态副本</h3><pre><code>!function(a) {
    arguments[0] = 100;
    console.log(a);
}(1);  //100
</code></pre><blockquote>
<p>在一般模式下，如果定义了一个函数，调用它并且传递参数，那么它对应的形参和arguments[0]有一个相互的绑定关系，就是说如果我们修改了arguments[0]，那么这个函数对应的形参b就会被修改了，所以输出100。</p>
<p>如果我们现在不给函数传值，就是像下面这个样子，</p>
</blockquote>
<pre><code>! function (a){
arguments[0]=100;
console.log(a);//undefined
  }();
</code></pre><blockquote>
<p>那么无论我们如何修改arguments[0]的值，输出的都是undefined，因为宝宝你没有传递参数进去啊，~ o(￣▽￣)ブ</p>
</blockquote>
<pre><code>!function(a) {
    &apos;use strict&apos;;
    arguments[0] = 100;
    console.log(a);
}(1);  //1
</code></pre><blockquote>
<p>在严格模式下，arguments[0]变为参数的静态副本，就是说无论函数的参数有没有传递，都不会和arguments相互影响</p>
</blockquote>
<pre><code>!function(a) {
&apos;use strict&apos;;
arguments[0].x = 100;
console.log(a.x);
}({x:1});  //100
</code></pre><blockquote>
<p>但是如果传入的是一个对象的话，将会按照共享传递，使用arguments修改对象的属性，那么还是会相互影响的。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>arguments用法</strong></p>
<p>每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。</p>
</blockquote>
<pre><code>var sum = function (n) {
if (1 == n) {
return 1;
} else {
return n + arguments.callee(n - 1);
}
}
alert(sum(6));
</code></pre><hr>
<h3 id="4-delete参数、函数名报错"><a href="#4-delete参数、函数名报错" class="headerlink" title="4.delete参数、函数名报错"></a>4.delete参数、函数名报错</h3><pre><code>!function(a) {
    &apos;use strict&apos;;
    delete a;
}(1); //SyntaxError
</code></pre><h3 id="5-delete不可配置的属性报错"><a href="#5-delete不可配置的属性报错" class="headerlink" title="5.delete不可配置的属性报错"></a>5.delete不可配置的属性报错</h3><pre><code>!function(a) {
    &apos;use strict&apos;;
    var obj = {};
    Object.defineProperty(obj, 
    &apos;a&apos;, {configurable : false});
    delete obj.a;
}(1); //TypeError
</code></pre><h3 id="6-对象字面量重复属性名报错"><a href="#6-对象字面量重复属性名报错" class="headerlink" title="6.对象字面量重复属性名报错"></a>6.对象字面量重复属性名报错</h3><pre><code>!function() {
    &apos;use strict&apos;;
    var obj = {x : 1, x : 2};
}();  //SyntaxError
</code></pre><h3 id="7-禁止八进制字面量"><a href="#7-禁止八进制字面量" class="headerlink" title="7.禁止八进制字面量"></a>7.禁止八进制字面量</h3><pre><code>!function() {
    &apos;use strict&apos;;
    console.log(0123);
}(); //SyntaxError
</code></pre><h3 id="8-eval-arguments变为关键字，不能作为变量、函数名"><a href="#8-eval-arguments变为关键字，不能作为变量、函数名" class="headerlink" title="8.eval, arguments变为关键字，不能作为变量、函数名"></a>8.eval, arguments变为关键字，不能作为变量、函数名</h3><pre><code>!function() {
    &apos;use strict&apos;;
    function eval(){}
}();  //SyntaxError
</code></pre><h3 id="9-eval独立作用域"><a href="#9-eval独立作用域" class="headerlink" title="9.eval独立作用域"></a>9.eval独立作用域</h3><pre><code>!function() {
    &apos;use strict&apos;;
    eval(&apos;var evalVal = 2;&apos;);
    console.log(typeof evalVal);
}();  //undefined
</code></pre><p><strong>小结</strong></p>
<blockquote>
<p>1.不允许用with</p>
<p>2.所有变量必须声明, 赋值给为声明的变量报错，而不是隐式创建全局变量。</p>
<p>3.eval中的代码不能创建eval所在作用域下的变量、函数。而是为eval单独创建一个作用域，并在eval返回时丢弃。</p>
<p>4.函数中得特殊对象arguments是静态副本，而不像非严格模式那样，修改arguments或修改参数变量会相互影响。</p>
<p>5.删除configurable=false的属性时报错，而不是忽略</p>
<p>6.禁止八进制字面量，如010 (八进制的8)</p>
<p>7.eval, arguments变为关键字，不可作为变量名、函数名等</p>
<p>8.一般函数调用时(不是对象的方法调用，也不使用apply/call/bind等修改this)this指向null，而不是全局对象。</p>
<p>9.若使用apply/call，当传入null或undefined时，this将指向null或undefined，而不是全局对象。</p>
<p>10.试图修改不可写属性(writable=false)，在不可扩展的对象上添加属性时报TypeError，而不是忽略。</p>
<p>11.arguments.caller, arguments.callee被禁用</p>
</blockquote>
<h1 id="四-对象"><a href="#四-对象" class="headerlink" title="四.对象"></a>四.对象</h1><p>对象中包含一系列属性，这些属性是无序的。<br>每个属性都有一个字符串key和对应的value。</p>
<pre><code>var obj = {x : 1, y : 2};
obj.x; // 1
obj.y; // 2
</code></pre><p>##（1)对象创建-字面量<br>    var obj1 = {x : 1, y : 2};<br>    var obj2 = {<br>    x : 1,<br>    y : 2,<br>    o : {<br>        z : 3,<br>        n : 4<br>          }<br>    };</p>
<h3 id="1-创建对象-new-原型链"><a href="#1-创建对象-new-原型链" class="headerlink" title="1.创建对象-new/原型链"></a>1.创建对象-new/原型链</h3><pre><code>function foo(){}
foo.prototype.z = 3;

var obj =new foo();
obj.y = 2;
obj.x = 1;

obj.x; // 1
obj.y; // 2
obj.z; // 3
typeof obj.toString; // ‘function&apos;
&apos;z&apos; in obj; // true
obj.hasOwnProperty(&apos;z&apos;); // false
</code></pre><blockquote>
<p>obj.z不在obj中，会向上查找，即沿着原型链</p>
</blockquote>
<pre><code>obj.z = 5;

obj.hasOwnProperty(&apos;z&apos;); // true
foo.prototype.z; // still 3
obj.z; // 5

obj.z = undefined;
obj.z; // undefined

delete obj.z; // true
obj.z; // 3

delete obj.z; // true
**obj.z; // still 3!!!**
</code></pre><blockquote>
<p>不能delete掉原型链的属性z</p>
</blockquote>
<h3 id="2-对象创建-Object-create"><a href="#2-对象创建-Object-create" class="headerlink" title="2.对象创建-Object.create"></a>2.对象创建-Object.create</h3><pre><code>var obj = Object.create({x : 1});
obj.x // 1
typeof obj.toString // &quot;function&quot;
obj.hasOwnProperty(&apos;x&apos;);// false
</code></pre><blockquote>
<p>创建一个新对象，并将这个对象的原型指向Object.propotype，create后面的属性属于object.propotype中。</p>
</blockquote>
<pre><code>var obj = Object.create(null);
obj.toString // undefined
</code></pre><h2 id="2-属性操作"><a href="#2-属性操作" class="headerlink" title="(2)属性操作"></a>(2)属性操作</h2><h3 id="1-属性读写"><a href="#1-属性读写" class="headerlink" title="1.属性读写"></a>1.属性读写</h3><pre><code>var obj = {x : 1, y : 2};
obj.x; // 1
obj[&quot;y&quot;]; // 2

obj[&quot;x&quot;] = 3;
obj.y = 4;

var obj = {x1 : 1, x2 : 2};
var i = 1, n = 2;

for (; i &lt;= n; i++) {
console.log(obj[&apos;x&apos; + i]);
}
// 输出: 1, 2

var p;
for (p in obj) {
console.log(obj[p]);
}
</code></pre><h3 id="2-属性读写-异常"><a href="#2-属性读写-异常" class="headerlink" title="2.属性读写-异常"></a>2.属性读写-异常</h3><pre><code>var obj = {x : 1};
obj.y; // undefined
var yz = obj.y.z; // TypeError: Cannot read property &apos;z&apos; of undefined
obj.y.z = 2; // TypeError: Cannot set property &apos;z&apos; of undefined

var yz;
if (obj.y) {
    yz = obj.y.z;
}

var yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z;
</code></pre><h3 id="3-属性删除"><a href="#3-属性删除" class="headerlink" title="3.属性删除"></a>3.属性删除</h3><pre><code>var person = {age : 28, title : &apos;fe&apos;};
delete person.age; // true
delete person[&apos;title&apos;]; // true
person.age; // undefined
delete person.age; // true

delete Object.prototype; // false,

var descriptor = Object.getOwnPropertyDescriptor(Object, &apos;prototype&apos;);
descriptor.configurable; // false
</code></pre><blockquote>
<p>不能delete Object.prototype</p>
</blockquote>
<pre><code>var globalVal = 1;
delete globalVal; // false

(function() {
    var localVal = 1;
    return delete localVal;
}()); // false
</code></pre><blockquote>
<p>不能delete 变量</p>
</blockquote>
<pre><code>function fd() {}
delete fd; // false

(function() {
    function fd() {};
    return delete fd;
}()); // false
</code></pre><blockquote>
<p>不能delete 函数</p>
</blockquote>
<pre><code>ohNo = 1;
window.ohNo; // 1
delete ohNo; // true
</code></pre><blockquote>
<p>可以delete 全局变量</p>
</blockquote>
<h3 id="4-属性检测"><a href="#4-属性检测" class="headerlink" title="4.属性检测"></a>4.属性检测</h3><pre><code>var cat = new Object;
cat.legs = 4;
cat.name = &quot;Kitty&quot;;

&apos;legs&apos; in cat; // true
&apos;abc&apos; in cat; // false
&quot;toString&quot; in cat; // true, inherited property!!!


cat.hasOwnProperty(&apos;legs&apos;); // true
cat.hasOwnProperty(&apos;toString&apos;); // false

cat.propertyIsEnumerable(&apos;legs&apos;); // true
cat.propertyIsEnumerable(&apos;toString&apos;); // false
</code></pre><blockquote>
<p>如果判断的属性存在于Object对象的原型内，不管它是否可枚举都会返回false。</p>
</blockquote>
<pre><code>Object.defineProperty(cat, &apos;price&apos;, {enumerable : false, value : 1000});
cat.propertyIsEnumerable(&apos;price&apos;); // false
cat.hasOwnProperty(&apos;price&apos;); // true


if (cat &amp;&amp; cat.legs) {
    cat.legs *= 2;
}


if (cat.legs !== undefined) {
    // only if cat.legs is not undefined
}
</code></pre><h3 id="5-getter-setter方法-另一种读写属性的方式"><a href="#5-getter-setter方法-另一种读写属性的方式" class="headerlink" title="5.getter setter方法(另一种读写属性的方式)"></a>5.getter setter方法(另一种读写属性的方式)</h3><p>getter 是一种获得属性值的方法，setter是一种设置属性值的方法。</p>
<pre><code>var man = {
    name : &apos;Bosn&apos;,
    weibo : &apos;@Bosn&apos;,
    get age() {
        return new Date().getFullYear() - 1988;
    },
    set age(val) {
        console.log(&apos;Age can\&apos;t be set to &apos; + val);
    }
}
console.log(man.age); // 27
man.age = 100; // Age can&apos;t be set to 100
console.log(man.age); // still 27
</code></pre><hr>
<pre><code>var man = {
    weibo : &apos;@Bosn&apos;,
    $age : null,
    get age() {
        if (this.$age == undefined) {
            return new Date().getFullYear() - 1988;
        } else {
            return this.$age;
        }
    },
    set age(val) {
        val = +val;
        if (!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) {
            this.$age = +val;
        } else {
            throw new Error(&apos;Incorrect val = &apos; + val);
        }
    }
}
console.log(man.age); // 27
man.age = 100;
console.log(man.age); // 100;
man.age = &apos;abc&apos;; // error:Incorrect val = NaN
</code></pre><p>get/set与原型链</p>
<pre><code>function foo() {}

Object.defineProperty(foo.prototype, &apos;z&apos;, 
    {get : function(){return 1;}});

var obj = new foo();

obj.z; // 1
obj.z = 10;
obj.z; // still 1

Object.defineProperty(obj, &apos;z&apos;, 
{value : 100, configurable: true});
obj.z; // 100;
delete obj.z;
obj.z; // back to 1
</code></pre><blockquote>
<p>不能修改get的属性</p>
</blockquote>
<h2 id="3-属性标签"><a href="#3-属性标签" class="headerlink" title="(3)属性标签"></a>(3)属性标签</h2><pre><code>Object.getOwnPropertyDescriptor({pro : true}, &apos;pro&apos;);
// Object {value: true, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({pro : true}, &apos;a&apos;); // undefined
</code></pre><blockquote>
<p>Object.getOwnPropertyDescriptor 函数 </p>
<p>语法：Object.getOwnPropertyDescriptor(object, propertyname)</p>
<p>参数：<br>object   必需。包含属性的对象。<br>propertyname 必需。属性的名称。</p>
</blockquote>
<pre><code>var person = {};
Object.defineProperty(person, &apos;name&apos;, {
    configurable : false,
    writable : false,
    enumerable : true,
    value : &quot;Bosn Ma&quot;
});

person.name; // Bosn Ma
person.name = 1;
person.name; // still Bosn Ma
delete person.name; // false
</code></pre><blockquote>
<p>defineProperty中的属性默认false</p>
</blockquote>
<pre><code>Object.defineProperty(person, &apos;type&apos;, {
    configurable : true,
    writable : true,
    enumerable : false,
    value : &quot;Object&quot;
});

Object.keys(person); // [&quot;name&quot;]
</code></pre><hr>
<pre><code>Object.defineProperties(person, {
    title : {value : &apos;fe&apos;, enumerable : true},
    corp : {value : &apos;BABA&apos;, enumerable : true},
    salary : {value : 50000, enumerable : true, writable : true}
});

Object.getOwnPropertyDescriptor(person, &apos;salary&apos;);
// Object {value: 50000, writable: true, enumerable: true, configurable: false}
Object.getOwnPropertyDescriptor(person, &apos;corp&apos;);
// Object {value: &quot;BABA&quot;, writable: false, enumerable: true, configurable: false}
</code></pre><hr>
<pre><code>Object.defineProperties(person, {
    title : {value : &apos;fe&apos;, enumerable : true},
    corp : {value : &apos;BABA&apos;, enumerable : true},
    salary : {value : 50000, enumerable : true, writable : true},
    luck : {
    get : function() {
    return Math.random() &gt; 0.5 ? &apos;good&apos; : &apos;bad&apos;;
    }
    },
    promote : {
    set : function (level) {
    this.salary *= 1 + level * 0.1;
    }
   }
});

Object.getOwnPropertyDescriptor(person, &apos;salary&apos;);
// Object {value: 50000, writable: true, enumerable: true, configurable: false}
Object.getOwnPropertyDescriptor(person, &apos;corp&apos;);
// Object {value: &quot;BABA&quot;, writable: false, enumerable: true, configurable: false}
person.salary; // 50000
person.promote = 2;
person.salary; // 60000
</code></pre><blockquote>
<p>getOwnPropertyDescriptor属性值默认false</p>
</blockquote>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712130113.png" alt=""></p>
<blockquote>
<p>1.configurable为false时，不能delete,不能修改getter/setter方法，不能修改属性标签</p>
<p>2.writable为false时，不能通过属性赋值，修改属性的值</p>
<p>3.configurable和writeable都是false时，才不能修改属性的值</p>
</blockquote>
<p>##（4）.对象标签</p>
<h3 id="1-原型标签-proto"><a href="#1-原型标签-proto" class="headerlink" title="1.原型标签 _proto_"></a>1.原型标签 _proto_</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt=""></p>
<h3 id="2-class标签"><a href="#2-class标签" class="headerlink" title="2.class标签"></a>2.class标签</h3><pre><code>var toString = Object.prototype.toString;
function getType(o){return toString.call(o).slice(8,-1);};

toString.call(null); // &quot;[object Null]&quot;
getType(null); // &quot;Null&quot;
getType(undefined); // &quot;Undefined&quot;
getType(1); // &quot;Number&quot;
getType(new Number(1)); // &quot;Number&quot;
typeof new Number(1); // &quot;object&quot;
getType(true); // &quot;Boolean&quot;
getType(new Boolean(true)); // &quot;Boolean&quot;
</code></pre><blockquote>
<p>slice() 方法</p>
<p><strong>定义和用法</strong><br>slice() 方法可从已有的数组中返回选定的元素。</p>
<p><strong>语法</strong><br>arrayObject.slice(start,end)</p>
<p><strong>start</strong><br>必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p>
<p><strong>end</strong><br>可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
<p><strong>返回值</strong><br>返回一个新的数组，包含从 start 到 end （<strong>不包括该元素</strong>）的 arrayObject 中的元素。</p>
<p><strong>说明</strong><br>请注意，该方法并不会修改数组，而是返回一个子数组。</p>
</blockquote>
<p>3.extensible标签</p>
<h3 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h3><p>如果一个对象可以添加新的属性，则这个对象是可扩展的。让这个对象变的不可扩展，也就是不能再有新的属性</p>
<pre><code>var obj = {x : 1, y : 2};
Object.isExtensible(obj); // true
</code></pre><blockquote>
<p>对象的extensible属性用于表示是否允许在对象中动态添加新的property。ECMAScript 3标准中，所有的对象都是extensible的。</p>
</blockquote>
<pre><code>Object.preventExtensions(obj);
Object.isExtensible(obj); // false
</code></pre><blockquote>
<p>使一个对象变成不是extensible的，可以使用Object.preventExtensions()语句</p>
</blockquote>
<pre><code>obj.z = 1;
obj.z; // undefined, add new property failed
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: true}
</code></pre><h3 id="密封特性"><a href="#密封特性" class="headerlink" title="密封特性"></a>密封特性</h3><p>密封对象是指那些不可 扩展 的，且所有自身属性都不可配置的（non-configurable）对象。</p>
<p>或则说 密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象</p>
<pre><code>Object.seal(obj);
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: false}
Object.isSealed(obj); // true
</code></pre><h3 id="冻结特性"><a href="#冻结特性" class="headerlink" title="冻结特性"></a>冻结特性</h3><p>冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。</p>
<pre><code>Object.freeze(obj);
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: false, enumerable: true, configurable: false}
Object.isFrozen(obj); // true

// [caution] not affects prototype chain!!!
</code></pre><h2 id="5-序列化"><a href="#5-序列化" class="headerlink" title="(5).序列化"></a>(5).序列化</h2><pre><code>var obj = {x : 1, y : true, z : [1, 2, 3], nullVal : null};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null}&quot;

obj = {val : undefined, a : NaN, b : Infinity, c : new Date()};
JSON.stringify(obj); // &quot;{&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:&quot;2015-01-20T14:15:43.910Z&quot;}&quot;

obj = JSON.parse(&apos;{&quot;x&quot; : 1}&apos;);
obj.x; // 1
</code></pre><hr>
<pre><code>var obj = {
    x : 1,
    y : 2,
    o : {
        o1 : 1,
        o2 : 2,
        toJSON : function () {
            return this.o1 + this.o2;
        }
    }
};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3}&quot;
</code></pre><blockquote>
<p>stringify()用于从一个对象解析出字符串，如</p>
<pre><code>var
 a = {a:1,b:2}

结果：

JSON.stringify(a)

&quot;{&quot;a&quot;:1,&quot;b&quot;:2}&quot;
</code></pre><p>parse用于从一个字符串中解析出json对象,如</p>
<pre><code>var str = &apos;{&quot;name&quot;:&quot;huangxiaojian&quot;,&quot;age&quot;:&quot;23&quot;}&apos;

结果：

JSON.parse(str)

Object

age: &quot;23&quot;
name: &quot;huangxiaojian&quot;
__proto__: Object
</code></pre><p>注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。</p>
</blockquote>
<p>##（5）.其他对象方法<br>    var obj = {x : 1, y : 2};<br>    obj.toString(); // “[object Object]”<br>    obj.toString = function() {return this.x + this.y};<br>    “Result “ + obj; // “Result 3”, by toString</p>
<pre><code>+obj; // 3, from toString

obj.valueOf = function() {return this.x + this.y + 100;};
+obj; // 103, from valueOf

&quot;Result &quot; + obj; // still &quot;Result 103&quot;
</code></pre><blockquote>
<p><strong>object.toString( )</strong></p>
<p>返回值  toString()函数的返回值为String类型。返回当前对象的字符串形式。</p>
<p>Array<br>将 Array 的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接。</p>
<p>Boolean<br>如果布尔值是true，则返回”true”。否则返回”false”。</p>
<p>Date<br>返回日期的文本表示。</p>
<p>Error<br>返回一个包含相关错误信息的字符串。</p>
<p>Function<br>返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }”</p>
<p>Number<br>    返回数值的字符串表示。还可返回以指定进制表示的字符串</p>
<p>String<br>    返回 String 对象的值。</p>
<p>Object(默认)<br>返回”[object ObjectName]”，其中 ObjectName 是对象类型的名称。</p>
<p><strong>object.valueOf( )</strong></p>
<p>返回值 函数返回指定对象的原始值。</p>
<p>Array<br>数组实例对象。</p>
<p>Boolean<br>布尔值。</p>
<p>Date<br>以毫秒数存储的时间值，从 UTC 1970 年 1 月 1 日午夜开始计算。</p>
<p>Function<br>函数本身。</p>
<p>Number<br>数字值。</p>
<p>Object<br>对象本身。这是默认设置。</p>
<p>String<br>字符串值。</p>
</blockquote>
<pre><code>var bbb = { 
i: 10, 
toString: function() { 
console.log(&apos;toString&apos;); 
return this.i; 
}, 
valueOf: function() { 
console.log(&apos;valueOf&apos;); 
return this.i; 
} 
} 
alert(bbb);// 10 toString 
alert(+bbb); // 10 valueOf 
alert(&apos;&apos;+bbb); // 10 valueOf 
alert(String(bbb)); // 10 toString 
alert(Number(bbb)); // 10 valueOf 
alert(bbb == &apos;10&apos;); // true valueOf 
alert(bbb === &apos;10&apos;); // false 
</code></pre><hr>
<pre><code>var aa = { 
i: 10, 
toString: function() { 
console.log(&apos;toString&apos;); 
return this.i; 
} 
} 
alert(aa);// 10 toString 
alert(+aa); // 10 toString 
alert(&apos;&apos;+aa); // 10 toString 
alert(String(aa)); // 10 toString 
alert(Number(aa)); // 10 toString 
alert(aa == &apos;10&apos;); // true toString 
再看valueOf。 
var bb = { 
i: 10, 
valueOf: function() { 
console.log(&apos;valueOf&apos;); 
return this.i; 
} 
} 
alert(bb);// [object Object] 
alert(+bb); // 10 valueOf 
alert(&apos;&apos;+bb); // 10 valueOf 
alert(String(bb)); // [object Object] 
alert(Number(bb)); // 10 valueOf 
alert(bb == &apos;10&apos;); // true valueOf 
发现有点不同吧？！它没有像上面toString那样统一规整。对于那个[object Object]，我估计是从Object那里继承过来的，我们再去掉它看看。 
Object.prototype.toString = null; 
var cc = { 
i: 10, 
valueOf: function() { 
console.log(&apos;valueOf&apos;); 
return this.i; 
} 
} 
alert(cc);// 10 valueOf 
alert(+cc); // 10 valueOf 
alert(&apos;&apos;+cc); // 10 valueOf 
alert(String(cc)); // 10 valueOf 
alert(Number(cc)); // 10 valueOf 
alert(cc == &apos;10&apos;); // true valueOf 
</code></pre><blockquote>
<p>总结：valueOf偏向于运算，toString偏向于显示。</p>
<p>1、 在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。</p>
<p>2、 在有运算操作符的情况下，valueOf的优先级高于toString。</p>
<p>3.如果只重写了toString，对象转换时会无视valueOf的存在来进行转换。但是，如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法。在不能调用toString的情况下，只能让valueOf上阵了。对于那个奇怪的字符串拼接问题，可能是出于操作符上，翻开ECMA262-5 发现都有一个getValue操作。嗯，那么谜底应该是揭开了。重写会加大它们调用的优化高，而在有操作符的情况下，valueOf的优先级本来就比toString的高。</p>
</blockquote>
<h1 id="五-数组"><a href="#五-数组" class="headerlink" title="五.数组"></a>五.数组</h1><p>数组是值的有序集合。每个值叫做元素，每个元素在数组中都有数字位置编号，也就是索引。JS中的数组是弱类型的，数组中可以含有不同类型的元素。数组元素甚至可以是对象或其它数组。</p>
<pre><code>var arr = [1, true, null, undefined, {x : 1}, [1, 2, 3]];
</code></pre><h3 id="1-创建数组-字面量"><a href="#1-创建数组-字面量" class="headerlink" title="1.创建数组-字面量"></a>1.创建数组-字面量</h3><pre><code>var BAT = [&apos;Alibaba&apos;, &apos;Tencent&apos;, &apos;Baidu&apos;];
var students = [{name : &apos;Bosn&apos;, age : 27}, {name : &apos;Nunnly&apos;, age : 3}];
var arr = [&apos;Nunnly&apos;, &apos;is&apos;, &apos;big&apos;, &apos;keng&apos;, &apos;B&apos;, 123, true, null];
var arrInArr = [[1, 2], [3, 4, 5]];

var commasArr1 = [1, , 2]; // 1, undefined, 2
var commasArr2 = [,,]; // undefined * 2

size from 0 to 4,294,967,295(2^23  -1 ) 
</code></pre><h3 id="2-创建数组-new-Array"><a href="#2-创建数组-new-Array" class="headerlink" title="2.创建数组-new Array"></a>2.创建数组-new Array</h3><pre><code>var arr = new Array(); 
var arrWithLength = new Array(100); // undefined * 100
var arrLikesLiteral = new Array(true, false, null, 1, 2, &quot;hi&quot;);
// 等价于[true, false, null, 1, 2, &quot;hi&quot;];
</code></pre><blockquote>
<p>new可以省略</p>
</blockquote>
<h3 id="3-数组元素读写"><a href="#3-数组元素读写" class="headerlink" title="3.数组元素读写"></a>3.数组元素读写</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr[1]; // 2
arr.length; // 5


arr[5] = 6;
arr.length; // 6


delete arr[0];
arr[0]; // undefined
</code></pre><h3 id="4-数组元素增删（动态的，无需指定大小）"><a href="#4-数组元素增删（动态的，无需指定大小）" class="headerlink" title="4.数组元素增删（动态的，无需指定大小）"></a>4.数组元素增删（动态的，无需指定大小）</h3><pre><code>var arr = [];
arr[0] = 1;
arr[1] = 2;
arr.push(3);
arr; // [1, 2, 3]

arr[arr.length] = 4; // equal to arr.push(4);
arr; // [1, 2, 3, 4]

arr.unshift(0);
arr; // [0, 1, 2, 3, 4];

delete arr[2];
arr; // [0, 1, undefined, 3, 4]
arr.length; // 5
2 in arr; // false

arr.length -= 1;
arr; // [0, 1, undefined, 3, 4],  4 is removed

arr.pop(); // 3 returned by pop
arr; // [0, 1, undefined], 3 is removed

arr.shift(); // 0 returned by shift
arr; // [1, undefined]
</code></pre><blockquote>
<p>1.向后插入元素 push()</p>
<p>2.向前插入元素 unshift()</p>
<p>3.从后移除元素 pop()</p>
<p>4.从前移除元素 shift()</p>
<p>5.length不固定，可随意更改</p>
<p>6.delete只会删除当前位置的值，长度不会变</p>
</blockquote>
<h3 id="5-数组迭代"><a href="#5-数组迭代" class="headerlink" title="5.数组迭代"></a>5.数组迭代</h3><pre><code>var i = 0, n = 10;
var arr = [1, 2, 3, 4, 5];
for (; i &lt; n; i++) {
    console.log(arr[i]); // 1, 2, 3, 4, 5
}

for(i in arr) {
    console.log(arr[i]); // 1, 2, 3, 4, 5
}

Array.prototype.x = &apos;inherited&apos;;

for(i in arr) {
    console.log(arr[i]); // 1, 2, 3, 4, 5, inherited
}

for(i in arr) {
    if (arr.hasOwnProperty(i)) {
        console.log(arr[i]); // 1, 2, 3, 4, 5
    }
}
</code></pre><blockquote>
<p>for…in  会受原型影响</p>
</blockquote>
<p>##（2）.二维数组、稀疏数组<br>    var arr = [[0, 1], [2, 3], [4, 5]];<br>    var i = 0, j = 0;<br>    var row;<br>    for (; i &lt; arr.length; i++) {<br>         row = arr[i];<br>         console.log(‘row ‘ + i);<br>         for (j = 0; j &lt; row.length; j++) {<br>              console.log(row[j]);<br>         }<br>    }</p>
<pre><code>// result:
// row 0
// 0
// 1
// row 1
// 2
// 3
// row 2
// 4
// 5
</code></pre><p>稀疏数组并不含有从0开始的连续索引。一般length属性值比实际元素个数大。</p>
<pre><code>var arr1 = [undefined];
var arr2 = new Array(1);
0 in arr1; // true
0 in arr2; // false
arr1.length = 100;
arr1[99] = 123;
99 in arr1; // true
98 in arr1; // false

var arr = [,,];
0 in arr; // false
</code></pre><p>##（3）.数组方法</p>
<h3 id="1-Array-prototype-join（将数组转为字符串）"><a href="#1-Array-prototype-join（将数组转为字符串）" class="headerlink" title="1.Array.prototype.join（将数组转为字符串）"></a>1.Array.prototype.join（将数组转为字符串）</h3><pre><code>var arr = [1, 2, 3];
arr.join(); // &quot;1,2,3&quot;
arr.join(&quot;_&quot;); // &quot;1_2_3&quot;

function repeatString(str, n) {
     return new Array(n + 1).join(str);
}
repeatString(&quot;a&quot;, 3); // &quot;aaa&quot;
repeatString(&quot;Hi&quot;, 5); // &quot;HiHiHiHiHi&quot;
</code></pre><h3 id="2-Array-prototype-reverse（将数组逆序）"><a href="#2-Array-prototype-reverse（将数组逆序）" class="headerlink" title="2.Array.prototype.reverse（将数组逆序）"></a>2.Array.prototype.reverse（将数组逆序）</h3><pre><code>var arr = [1, 2, 3];
arr.reverse(); // [3, 2, 1]
arr; // [3, 2, 1]
//原数组被修改
</code></pre><h3 id="3-Array-prototype-sort（排序）"><a href="#3-Array-prototype-sort（排序）" class="headerlink" title="3.Array.prototype.sort（排序）"></a>3.Array.prototype.sort（排序）</h3><pre><code>var arr = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];
arr.sort(); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

arr = [13, 24, 51, 3];
arr.sort(); // [13, 24, 3, 51]
arr; // [13, 24, 3, 51]
//原数组被修改，
</code></pre><p>因为sort是按字母排序的，所以数字排序运用函数</p>
<pre><code>arr.sort(function(a, b) {
     return a - b;
}); // [3, 13, 24, 51]
</code></pre><hr>
<pre><code>arr = [{age : 25}, {age : 39}, {age : 99}];
arr.sort(function(a, b) {
     return a.age - b.age;
});
arr.forEach(function(item) {
     console.log(&apos;age&apos;, item.age);
});
// result:
// age 25
// age 39
// age 99
</code></pre><h3 id="4-Array-prototype-concat（数组合并）"><a href="#4-Array-prototype-concat（数组合并）" class="headerlink" title="4.Array.prototype.concat（数组合并）"></a>4.Array.prototype.concat（数组合并）</h3><pre><code>var arr = [1, 2, 3];
arr.concat(4, 5); // [1, 2, 3, 4, 5]
arr; // [1, 2, 3] 原数组被修改

arr.concat([10, 11], 13); // [1, 2, 3, 10, 11, 13]

arr.concat([1, [2, 3]]); // [1, 2, 3, 1, [2, 3]]
</code></pre><h3 id="5-Array-prototype-slice（返回部分数组）"><a href="#5-Array-prototype-slice（返回部分数组）" class="headerlink" title="5.Array.prototype.slice（返回部分数组）"></a>5.Array.prototype.slice（返回部分数组）</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr.slice(1, 3); // [2, 3]
arr.slice(1); // [2, 3, 4, 5]
arr.slice(1, -1); // [2, 3, 4]
arr.slice(-4, -3); // [2]
//原数组未被修改
</code></pre><h3 id="6-Array-prototype-splice（数组拼接）"><a href="#6-Array-prototype-splice（数组拼接）" class="headerlink" title="6.Array.prototype.splice（数组拼接）"></a>6.Array.prototype.splice（数组拼接）</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr.splice(2); // returns [3, 4, 5]
arr; // [1, 2];

arr = [1, 2, 3, 4, 5];
arr.splice(2, 2); // returns [3, 4] 第二个参数表示截取几个
arr; // [1, 2, 5];

arr = [1, 2, 3, 4, 5];
arr.splice(1, 1, &apos;a&apos;, &apos;b&apos;); // returns [2]
arr; // [1, &quot;a&quot;, &quot;b&quot;, 3, 4, 5]
//原数组被修改
</code></pre><h3 id="7-Array-prototype-forEach（数组遍历）"><a href="#7-Array-prototype-forEach（数组遍历）" class="headerlink" title="7.Array.prototype.forEach（数组遍历）"></a>7.Array.prototype.forEach（数组遍历）</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
    console.log(x + &apos;|&apos; + index + &apos;|&apos; + (a === arr));
});
// 1|0|true
// 2|1|true
// 3|2|true
// 4|3|true
// 5|4|true
</code></pre><h3 id="8-Array-prototype-map（数组映射）"><a href="#8-Array-prototype-map（数组映射）" class="headerlink" title="8.Array.prototype.map（数组映射）"></a>8.Array.prototype.map（数组映射）</h3><pre><code>var arr = [1, 2, 3];
arr.map(function(x) {
     return x + 10;
}); // [11, 12, 13]
arr; // [1, 2, 3]
//原数组未被修改
</code></pre><h3 id="9-Array-prototype-filter（数组过滤）"><a href="#9-Array-prototype-filter（数组过滤）" class="headerlink" title="9.Array.prototype.filter（数组过滤）"></a>9.Array.prototype.filter（数组过滤）</h3><pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.filter(function(x, index) {
     return index % 3 === 0 || x &gt;= 8;
}); // returns [1, 4, 7, 8, 9, 10]
arr; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
//原数组未被修改
</code></pre><h3 id="10-Array-prototype-every-amp-some（数组判断）"><a href="#10-Array-prototype-every-amp-some（数组判断）" class="headerlink" title="10.Array.prototype.every &amp; some（数组判断）"></a>10.Array.prototype.every &amp; some（数组判断）</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr.every(function(x) {
     return x &lt; 10;
}); // true

arr.every(function(x) {
     return x &lt; 3;
}); // false

var arr = [1, 2, 3, 4, 5];
arr.some(function(x) {
     return x === 3;
}); // true

arr.some(function(x) {
     return x === 100;
}); // false
</code></pre><blockquote>
<p>类似逻辑与、逻辑或</p>
</blockquote>
<h3 id="11-Array-prototype-reduce-amp-reduceRight"><a href="#11-Array-prototype-reduce-amp-reduceRight" class="headerlink" title="11.Array.prototype.reduce&amp;reduceRight"></a>11.Array.prototype.reduce&amp;reduceRight</h3><pre><code>var arr = [1, 2, 3];
var sum = arr.reduce(function(x, y) {
     return x + y
}, 0); // 6
arr; //[1, 2, 3]

arr = [3, 9, 6];
var max = arr.reduce(function(x, y) {
     console.log(x + &quot;|&quot; + y);
     return x &gt; y ? x : y;
});
// 3|9
// 9|6
max; // 9
</code></pre><hr>
<pre><code>max = arr.reduceRight(function(x, y) {
     console.log(x + &quot;|&quot; + y);
     return x &gt; y ? x : y;
});
// 6|9
// 9|3
max; // 9
</code></pre><blockquote>
<p>整个数组聚合成唯一一个结果</p>
</blockquote>
<h3 id="12-Array-prototype-indexOf-amp-lastIndexOf-（数组检索）"><a href="#12-Array-prototype-indexOf-amp-lastIndexOf-（数组检索）" class="headerlink" title="12.Array.prototype.indexOf&amp;lastIndexOf （数组检索）"></a>12.Array.prototype.indexOf&amp;lastIndexOf （数组检索）</h3><pre><code>var arr = [1, 2, 3, 2, 1];
arr.indexOf(2); // 1
arr.indexOf(99); // -1
arr.indexOf(1, 1); // 4
arr.indexOf(1, -3); // 4
arr.indexOf(2, -1); // -1
arr.lastIndexOf(2); // 3
arr.lastIndexOf(2, -2); // 3
arr.lastIndexOf(2, -3); // 1
</code></pre><blockquote>
<p>第一个参数是检索的对象，第二个参数是检索的位置，负数即从后面开始。</p>
</blockquote>
<h3 id="13-Array-isArray（判断是否为数组）"><a href="#13-Array-isArray（判断是否为数组）" class="headerlink" title="13.Array.isArray（判断是否为数组）"></a>13.Array.isArray（判断是否为数组）</h3><pre><code>Array.isArray([]); // true
</code></pre><p>##（4）.数组  VS.  一般对象<br>相同</p>
<p>都可以继承<br>数组是对象，对象不一定是数组<br>都可以当做对象添加删除属性</p>
<p>不同</p>
<p>数组自动更新length<br>按索引访问数组常常比访问一般对象属性明显迅速。<br>数组对象继承Array.prototype上的大量数组操作方法</p>
<h2 id="5-字符串和数组"><a href="#5-字符串和数组" class="headerlink" title="(5).字符串和数组"></a>(5).字符串和数组</h2><pre><code>var str = &quot;hello world&quot;;
str.charAt(0); // &quot;h&quot;
str[1]; // e

Array.prototype.join.call(str, &quot;_&quot;);
// &quot;h_e_l_l_o_ _w_o_r_l_d&quot;
</code></pre><blockquote>
<p><strong>call()和apply()方法</strong></p>
<p>1、方法定义</p>
<p>call方法: </p>
<p>语法：call([thisObj[,arg1[, arg2[,   [,.argN]]]]]) </p>
<p>定义：调用一个对象的一个方法，以另一个对象替换当前对象。 </p>
<p>说明：<br>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </p>
<p>apply方法： </p>
<p>语法：apply([thisObj[,argArray]]) </p>
<p>定义：应用某一对象的一个方法，用另一个对象替换当前对象。 </p>
<p>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<p>2、常用实例</p>
<p>a、</p>
<pre><code>function add(a,b)  
{  
    alert(a+b);  
}  
function sub(a,b)  
{  
    alert(a-b);  
}  

add.call(sub,3,1);
</code></pre><p>这个例子中的意思就是用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); // 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</p>
<p>b、</p>
<pre><code>function Animal(){    
    this.name = &quot;Animal&quot;;    
    this.showName = function(){    
        alert(this.name);    
    }    
}    

function Cat(){    
    this.name = &quot;Cat&quot;;    
}    

var animal = new Animal();    
var cat = new Cat();    

//通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。    
//输入结果为&quot;Cat&quot;    
animal.showName.call(cat,&quot;,&quot;);    
//animal.showName.apply(cat,[]);  
</code></pre><p>call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name 应该是 Cat</p>
<p>c、实现继承</p>
<pre><code>function Animal(name){      
    this.name = name;      
    this.showName = function(){      
        alert(this.name);      
    }      
}      

function Cat(name){    
    Animal.call(this, name);    
}      

var cat = new Cat(&quot;Black Cat&quot;);     
cat.showName(); 
</code></pre><p> Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么 Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了.</p>
<p>d、多重继承</p>
<pre><code>function Class10()  
{  
    this.showSub = function(a,b)  
    {  
        alert(a-b);  
    }  
}  

function Class11()  
{  
    this.showAdd = function(a,b)  
    {  
        alert(a+b);  
    }  
}  

function Class2()  
{  
    Class10.call(this);  
    Class11.call(this);  
} 
</code></pre><p> 很简单，使用两个 call 就实现多重继承了</p>
<p>说了call ，当然还有 apply，这两个方法基本上是一个意思，区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments<br>还有 callee，caller..</p>
</blockquote>
<h1 id="六-函数"><a href="#六-函数" class="headerlink" title="六.函数"></a>六.函数</h1><p>函数是一块JavaScript代码，被定义一次，但可执行和调用多次。<br>JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递 所以我们也常叫JS中的函数为函数对象。</p>
<h3 id="不同的调用方式"><a href="#不同的调用方式" class="headerlink" title="不同的调用方式"></a>不同的调用方式</h3><p>直接调用<br>foo();</p>
<p>对象方法<br>o.method();</p>
<p>构造器<br>new Foo();</p>
<p>call/apply/bind<br>func.call(o);</p>
<h2 id="2-函数声明和函数表达式"><a href="#2-函数声明和函数表达式" class="headerlink" title="(2).函数声明和函数表达式"></a>(2).函数声明和函数表达式</h2><h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1.函数声明"></a>1.函数声明</h3><pre><code>function add (a, b) { a = +a;
b = +b;
if (isNaN(a) || isNaN(b)) { return;
}
return a + b;
}
</code></pre><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><pre><code>// function variable
var add = function (a, b) {
// do sth
};

// IEF(Immediately Executed Function)
(function() {
// do sth
})();

// first-class function 
return function() {
// do sth
};

// NFE (Named Function Expression)
//命名函数表达式（有名字的函数表达式） 
var add = function foo (a, b) {
// do sth

};
</code></pre><h3 id="2-变量-amp-函数的声明前置"><a href="#2-变量-amp-函数的声明前置" class="headerlink" title="2.变量&amp;函数的声明前置"></a>2.变量&amp;函数的声明前置</h3><pre><code>//函数声明会前置，即
//function add(a,b) 
var num = add(1, 2);
console.log(num);  //result:3

function add (a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) 
        { return;
    }
    return a + b;
}

//函数表达式中，函数不会前置，可是变量会
//var add 但是它是undefined，没有赋值，只是声明
var num = add(1, 2);
console.log(num);

vaar add = function (a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) 
        { return;
    }
    return a + b;
}
</code></pre><h3 id="3-命名函数表达式"><a href="#3-命名函数表达式" class="headerlink" title="3.命名函数表达式"></a>3.命名函数表达式</h3><pre><code>var func = function nfe() {};
alert(func === nfe);
</code></pre><blockquote>
<p>IE6~8中，会弹出false窗口，即两个不相等，可是外部可以访问nfe;</p>
<p>IE9+中，nfe undefined。即外部不可调用nfe。</p>
<pre><code>// 递归调用
var func = function nfe() {/** do sth.**/ nfe();}
</code></pre></blockquote>
<h3 id="4-Function-构造器"><a href="#4-Function-构造器" class="headerlink" title="4.Function 构造器"></a>4.Function 构造器</h3><pre><code>var func = new Function(&apos;a&apos;, &apos;b&apos;, &apos;console.log(a + b);&apos;);
func(1, 2);    // 3

var func = Function(&apos;a&apos;, &apos;b&apos;, &apos;console.log(a + b);&apos;); func(1, 2);    // 3
</code></pre><hr>
<pre><code>//CASE 1
Function(&apos;var localVal = &quot;local&quot;;
console.log(localVal);&apos;)();
console.log(typeof localVal);
// result: local, undefined
</code></pre><p>localVal仍为局部变量</p>
<pre><code>// CASE 2
var globalVal = &apos;global&apos;;
(function() {
    var localVal = &apos;local&apos;;
    Function(&apos;console.log(typeof localVal, typeof globalVal);&apos;)();
})();
// result: undefined, string
</code></pre><p>local不可访问，全局变量global可以访问</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712195942.png" alt=""></p>
<p>##（2）.this</p>
<h3 id="1-全局的this（浏览器）"><a href="#1-全局的this（浏览器）" class="headerlink" title="1.全局的this（浏览器）"></a>1.全局的this（浏览器）</h3><pre><code>console.log(this.document === document); // true
console.log(this === window); // true this.a = 37;
console.log(window.a); // 37
</code></pre><h3 id="2-一般函数的this（浏览器）"><a href="#2-一般函数的this（浏览器）" class="headerlink" title="2.一般函数的this（浏览器）"></a>2.一般函数的this（浏览器）</h3><pre><code>function f1(){ 
    return this;
}

f1() === window; // true, global object

//严格模式的this指向undefined（全局）
function f2(){
    &quot;use strict&quot;; // see strict mode return this;
}

f2() === undefined; // true
</code></pre><h3 id="3-作为对象方法的函数的this"><a href="#3-作为对象方法的函数的this" class="headerlink" title="3.作为对象方法的函数的this"></a>3.作为对象方法的函数的this</h3><pre><code>var o = 
{ prop: 
37,
    f: function() 
    { return 
        this.prop;
    }
};

console.log(o.f()); // logs 37
</code></pre><hr>
<pre><code>var o = {prop: 37};

function independent() 
{ return this.prop;
}

o.f = independent;

console.log(o.f()); // logs 37
</code></pre><h3 id="4-对象原型链上的this"><a href="#4-对象原型链上的this" class="headerlink" title="4.对象原型链上的this"></a>4.对象原型链上的this</h3><pre><code>var o = {f:function(){ return this.a + this.b; }}; 
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
</code></pre><h3 id="5-get-set方法与this"><a href="#5-get-set方法与this" class="headerlink" title="5.get/set方法与this"></a>5.get/set方法与this</h3><pre><code>function modulus(){
    return Math.sqrt(this.re * this.re + this.im * this.im);
}

var o = 
    { re: 1,
    im: -1,
    get phase(){
        return Math.atan2(this.im, this.re);
    }
};


Object.defineProperty(o, &apos;modulus&apos;, {
get: modulus, enumerable:true, configurable:true});

console.log(o.phase, o.modulus); // logs -0.78 1.4142
</code></pre><p>get,set的this指向它本身的函数</p>
<h3 id="6-构造器中的this"><a href="#6-构造器中的this" class="headerlink" title="6.构造器中的this"></a>6.构造器中的this</h3><pre><code>function MyClass(){
this.a = 37;

}

var o = new    MyClass(); 
console.log(o.a); // 37


function C2(){ 
    this.a = 37; 
    return {a : 38};
}

o = new    C2(); 
console.log(o.a); // 38
</code></pre><h3 id="7-call-apply方法与this"><a href="#7-call-apply方法与this" class="headerlink" title="7.call/apply方法与this"></a>7.call/apply方法与this</h3><pre><code>function add(c, d){
return this.a + this.b + c + d;

}

var o = {a:1, b:3};

add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16

add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 

function bar() {
    console.log(Object.prototype.toString.call(this));

}

bar.call(7); // &quot;[object Number]&quot;
</code></pre><h3 id="8-bind方法与this（IE9-才有"><a href="#8-bind方法与this（IE9-才有" class="headerlink" title="8.bind方法与this（IE9+才有)"></a>8.bind方法与this（IE9+才有)</h3><pre><code>function f(){ 
    return this.a;
}

var g = f.bind({a : &quot;test&quot;}); 
console.log(g()); // test

var o = {a : 37, f : f, g : g};
console.log(o.f(), o.g()); // 37, test
</code></pre><h2 id="（4）-函数属性和arguments"><a href="#（4）-函数属性和arguments" class="headerlink" title="（4）.函数属性和arguments"></a>（4）.函数属性和arguments</h2><pre><code>function foo(x, y, z) {
‘use strict’;
arguments.length; // 2
arguments[0]; // 1

arguments[0] = 10;
x; // change to 10; //绑定关系，严格模式下仍然是1

arguments[2] = 100;
z; // still undefined !! //未传参数失去绑定关系

arguments.callee === foo; // true //严格模式下不能使用
}
</code></pre><h3 id="1-apply-call方法（浏览器）"><a href="#1-apply-call方法（浏览器）" class="headerlink" title="1.apply/call方法（浏览器）"></a>1.apply/call方法（浏览器）</h3><pre><code>function foo(x, y) 
{ 
    console.log(x, y, this);
}

foo.call(100, 1, 2); // 1, 2, Number(100)
foo.apply(true, [3, 4]); // 3, 4, Boolean(true) 
foo.apply(null); // undefined, undefined, window 
foo.apply(undefined); // undefined, undefined, window
</code></pre><hr>
<pre><code>function foo(x, y) {
    &apos;use strict&apos;; 
    console.log(x, y, this);
}

foo.apply(null); //undefined,undefined,null 

foo.apply(undefined); // undefined, undefined, undefined
</code></pre><h3 id="2-bind方法"><a href="#2-bind方法" class="headerlink" title="2.bind方法"></a>2.bind方法</h3><pre><code>this.x = 9;
var module = { 
    x: 81,
    getX: function() { return this.x; }
};

module.getX(); // 81

var getX = module.getX; 
getX(); // 9 指向全局变量

var boundGetX = getX.bind(module); 
boundGetX(); // 81 将这个this指向参数的module
</code></pre><h3 id="3-bind与currying（函数颗粒化，把一个函数拆成多个单元）"><a href="#3-bind与currying（函数颗粒化，把一个函数拆成多个单元）" class="headerlink" title="3.bind与currying（函数颗粒化，把一个函数拆成多个单元）"></a>3.bind与currying（函数颗粒化，把一个函数拆成多个单元）</h3><pre><code>function add(a, b, c) {
    return a + b + c;
}

var func = add.bind(undefined, 100); 
func(1, 2); // 103 
//很多时候，我们不需要传入那么多参数，这里的100，固定赋值给a

var func2 = func.bind(undefined, 200); func2(10); // 310
</code></pre><hr>
<pre><code>function getConfig(colors, size, otherOptions) {
    console.log(colors, size, otherOptions);
}

var defaultConfig = getConfig.bind(null, &quot;#CC0000&quot;, &quot;1024 * 768&quot;); 
defaultConfig(&quot;123&quot;); // #CC0000 1024 * 768 123
defaultConfig(&quot;456&quot;); // #CC0000 1024 * 768 456
</code></pre><h3 id="4-bind-和-new"><a href="#4-bind-和-new" class="headerlink" title="4.bind 和 new"></a>4.bind 和 new</h3><pre><code>function foo() {
    this.b = 100; 
    return this.a;
}

var func = foo.bind({a:1}); 

func(); // 1
new func(); // {b : 100}
</code></pre><p>直接调用foo()的话，this指向全局对象，这里面相对于创建了一个全局变量b，并且赋值为100，返回的是全局变量的a属性</p>
<p>用bind的方法传入一个参数，一个字面量，只有一个属性a，直接调用的话，则this会指向bind的这样的一个参数。</p>
<p>用new的话，return除了是一个对象，否则会以this作为返回值，并且this会被初始化为一个默认的空对象，这个对象的原型是foo.prototype。虽然前面bind了，可是new了之后，会忽略bind，this指向么有bind所指向的。意思是如果用new调用的话，bind的作用会被忽略掉。</p>
<p>##（5）.理解闭包</p>
<p>当一个函数被调用完毕之后，这个局部变量就可以被释放掉了</p>
<p>闭包，以自己的话理解就是，函数被调用完后，局部变量没有被释放。执行上下文仍在栈中，没有出栈。因为下一个执行上下文需要用到。</p>
<h3 id="常见错误之循环闭包"><a href="#常见错误之循环闭包" class="headerlink" title="常见错误之循环闭包"></a>常见错误之循环闭包</h3><pre><code>document.body.innerHTML = &quot;&lt;div  id=div1&gt;aaa&lt;/div&gt;&quot;+ &quot;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;; 

for (var i = 1; i &lt; 4; i++) {
document.getElementById(&apos;div&apos; + i). addEventListener(&apos;click&apos;, function()
 { alert(i); // all are 4!
    });
}
</code></pre><hr>
<pre><code>document.body.innerHTML = &quot;&lt;div  id=div1&gt;aaa&lt;/div&gt;&quot;+ &quot;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;; 

for (var i = 1; i &lt; 4; i++) {
!function(i) 
        { 
            document.getElementById(&apos;div&apos; + i).
            addEventListener(&apos;click&apos;, function() { alert(i); // 1, 2, 3
        });
    }(i);
}
//将每次遍历的1，2，3的值，传到匿名函数（下面那个i），然后在这个匿名函数里面，再用到这个参数i
</code></pre><h3 id="闭包封装"><a href="#闭包封装" class="headerlink" title="闭包封装"></a>闭包封装</h3><pre><code>(function() {
    var _userId = 23492; 
    var _typeId = &apos;item&apos;; 
    var export = {};

    function converter(userId) { 
        return +userId;
    }

    export.getUserId = function() { 
        return converter(_userId);
    }

    export.getTypeId = function() { 
        return _typeId;
    }

    window.export = export;

}());

export.getUserId(); // 23492 
export.getTypeId();    // item

export._userId; // undefined 
export._typeId; // undefined 
export.converter; // undefined
</code></pre><p>函数有函数自己的作用域，里面定义的变量，外部是无法访问的。</p>
<p>我们在函数中定义变量，外部无法用，再用window.export=export这样的方式，把我们最终想输出的对象输出去</p>
<p>外部只能通过export这个对象提供的方法来访问到里面的具体的函数的变量</p>
<p>##（6）.作用域<br>     var a = 10;        全局<br>    (function() {<br>         var b = 20;函数<br>    })();</p>
<pre><code>console.log(a);    // 10
console.log(b);    // error, b in not defined

for (var item in {a : 1, b : 2}) { 
    console.log(item);

}

console.log(item);    // item still in scope

eval(&quot;var a = 1;&quot;); //eval
</code></pre><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><pre><code>function outer2() {
    var local2 = 1; 
    function outer1() {
        var local1 = 1;
        // visit local1, local2 or global3 作用域链从初开始向上找创建该作用域的函数
    }
    outer1();
}
var global3 = 1;
outer2();

function outer() { 
    var i = 1;
    var func = new Function(&quot;console.log(typeof i);&quot;); 
    func();    // undefined}  //Function中的变量外部无法访问
outer();
</code></pre><h3 id="利用函数作用域封装"><a href="#利用函数作用域封装" class="headerlink" title="利用函数作用域封装"></a>利用函数作用域封装</h3><pre><code>(function() {
    // do sth here 
    var a, b;
})();

!function() {
    // do sth here 
    var a, b;
}();
</code></pre><blockquote>
<p>写成函数表达式，为了防止变量被提前声明。留下一堆括号，会报语法错误</p>
</blockquote>
<p>##（7）.ES3执行上下文<br>图文详情参见《js深入了解闭包和原型》</p>
<blockquote>
<p><strong>JS解释器如何找到我们定义的函数和变量？</strong></p>
<p>变量对象(Variable Object, 缩写为VO)是一个抽象 概念中的“对象”，它用于存储执行上下文中的：</p>
<ol>
<li>变量</li>
<li>函数声明</li>
<li>函数参数</li>
</ol>
</blockquote>
<pre><code>var a = 10; 
function test(x) {
    var b = 20;
}
test(30);

VO(globalContext) = { 
    a : 10,
    test : &lt;ref to function&gt;
};
VO(test functionContext) = { 
    x : 30,
    b: 20
};
</code></pre><h3 id="1-变量初始化阶段（对于函数来说）"><a href="#1-变量初始化阶段（对于函数来说）" class="headerlink" title="1.变量初始化阶段（对于函数来说）"></a>1.变量初始化阶段（对于函数来说）</h3><blockquote>
<p><strong>VO按照如下顺序填充:</strong></p>
<ol>
<li><p>函数参数 (若未传⼊入，初始化该参数值为undefined)</p>
</li>
<li><p>函数声明 (若发⽣生命名冲突，会覆盖)</p>
</li>
<li><p>变量声明 (初始化变量值为undefined，若发⽣生命名冲突，会忽略。)</p>
</li>
</ol>
</blockquote>
<pre><code>function test(a, b) {
    var c = 10; function d() {}
    var e = function _e() {}; (function x() {});
    b = 20;
}
test(10);

AO(test) = { 
    a: 10,
    b: undefined, 
    c: undefined,
    d: &lt;ref to func &quot;d&quot;&gt; 
    e: undefined
};
//函数表达式不会影响VO
</code></pre><h3 id="2-代码执行阶段"><a href="#2-代码执行阶段" class="headerlink" title="2.代码执行阶段"></a>2.代码执行阶段</h3><pre><code>function test(a, b) {
    var c = 10; function d() {}
    var e = function _e() {}; (function x() {});
    b = 20;
}
test(10);

AO(test) = { 
    a: 10,
    b: 20,
    c: 10,
    d: &lt;reference to FunctionDeclaration &quot;d&quot;&gt; 
    e: function _e() {};
};
</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>alert(x);    // function

var x = 10; 
alert(x);    // 10
x = 20;

function x() {} 
alert(x);    // 20

if (true) { 
    var a = 1;
} else {
    var b = true;
}

alert(a);    // 1
alert(b);    // undefined
</code></pre><p>首先，vo对象里面，有一个x，值是一个函数对象（函数声明前置），有一个a和b，值是undefined。var x=10：因为变量名和函数名冲突，忽略</p>
<p>然后进入代码执行阶段，var x=10,赋值成功，alert为10；因为b被前置处理，所以alert b不会报错，undefined</p>
<h1 id="七-oop（面向对象程序设计）"><a href="#七-oop（面向对象程序设计）" class="headerlink" title="七.oop（面向对象程序设计）"></a>七.oop（面向对象程序设计）</h1><p>1.继承</p>
<p>2.原型链</p>
<p>3.prototype</p>
<p>4.instanceof</p>
<p>以上《js深入了解闭包和原型》</p>
<p>5.实现继承的方法</p>
<pre><code>Student.prototype = Object.create(Person.prototype)
</code></pre><blockquote>
<p>创建一个空对象，并将其原型指向person.prototype(ES5之后才可以使用）</p>
</blockquote>
<pre><code>if(!Object.create){
    Object.create = function(proto){
        function F(){}
        F.prototype = proto;
        return new F;
    };
}//ES5之前使用方法
</code></pre><h3 id="6-模拟重载"><a href="#6-模拟重载" class="headerlink" title="6.模拟重载"></a>6.模拟重载</h3><p>重载的定义是指函数的方法名相同，但参数不同。比如我写两个关于js的同名函数：</p>
<pre><code>&lt;script type = &quot;text/javascript&quot; &gt;
    function add(a,b){
        var sum = a+b;
        alert (sum);
    }
    add(2,3);

    //第二个函数
    function add(c,d,e){
        var sum2 = c+d+e;
        alert (sum2);
    }
    add(2,3,4);

&lt;/script&gt;
</code></pre><blockquote>
<p>结果为NaN 9 ，这就说明后面的函数把前一个同名函数覆盖掉了，从而可以得出js函数不存在重载，永远调用最后一个方法。</p>
<p>虽说JS函数不存在重载，但是我们可以实现js里面的模拟重载，接下来见证奇迹的时刻到了。要想实现js模拟重载必先回用到 arguments.用来存放js参数。实现方法如下：</p>
</blockquote>
<pre><code>function add1(){
    //比如传递的是两个参数
    if(arguments.length == 2){
        return arguments[0] +arguments[1];
    }else if(arguments.length ==3){
        return arguments[0]+arguments[1]+arguments[2];
    }else if(arguments.length == 4){
        return arguments[0]+arguments[1]+arguments[2]+arguments[3];
    }else{
        return 0 ;
    }
}

    //调用
    alert(add1(1,2));
    alert(add2(1,2,3));
    alert(add3(1,2,3,4));
    alert(add4(1,2,3,4,5));

    结果 3 6 10 0
</code></pre><h3 id="7-调用子类的方法（子掉父）"><a href="#7-调用子类的方法（子掉父）" class="headerlink" title="7.调用子类的方法（子掉父）"></a>7.调用子类的方法（子掉父）</h3><pre><code>function Person(name){
  this.name=name;
}

function Student(name,className){
  this.className=className;
  Person.call(this,name);//调用别的构造器   
}

var mike=new Student(&apos;mike&apos;,&apos;Network3&apos;);

//子类调用已被覆盖的父类的方法
Person.prototype.init=function{
...
}
Student.prototype.inti=function{
  Person.prototype.init.apply(this,arguments);    
}
</code></pre><h3 id="8-链式调用"><a href="#8-链式调用" class="headerlink" title="8.链式调用"></a>8.链式调用</h3><pre><code>function ClassManager(){} //先定义一个构造器
ClassManager.prototype.addClass = function(str){
    console.log(&apos;Class + str + &apos;added&apos;);
    return this;
};

 //然后在ClassMannager构造器上增加addclass方法,需要注意一点，最后return this，this指向classmanager的实例

var manager = new ClassManager();
manager.addClass(&apos;classA&apos;).addClass(&apos;classB&apos;).addClass(&apos;classC&apos;);
//Class:class A added
//Class:class B added
//Class:class C added
</code></pre><h3 id="9-抽象类"><a href="#9-抽象类" class="headerlink" title="9.抽象类**"></a>9.抽象类**</h3><h3 id="9-模块化"><a href="#9-模块化" class="headerlink" title="9.模块化"></a>9.模块化</h3><p>所谓模块化就是将需要用到的方法封装成为一个模块，哪里需要直接调用即可，比如你需要计算1+1和2+2，那么你只需要调用a+b的方法即可，无需反复重写，但是由于js并不支持类的继承，因此如何封装和调用方法就成为js模块化的重要思路。</p>
<blockquote>
<p>最简单的方式</p>
<pre><code>function sum(a,b){
        alert(a+b);
    }
function sub(a,b){
        alert(a-b);
    }
    sum(1,1);
    sum(2,2);
    sub(11,1);
</code></pre><p>上面的sum（），sub（）分别都可以算作是一个模块，需要用的时候直接调用即可，但是这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。比如a，b是全局变量同时方法中需要改变a，b值的时候。</p>
<p>因此大多时候我们都会将其采用对象的写法：</p>
<pre><code>var Sum=new Object({
        a:1,
        b:2,
        sum:function(){
            alert(this.a-this.b);
        }
    });
    Sum.sum();
</code></pre><p> 上面的函数sum()，封装在Sum对象里。使用的时候，就是调用这个对象的属性。</p>
<p>Sum.sum();</p>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写,比如：</p>
<p>sum.a=2;</p>
<p>因此，在这个的基础上，我们可以采用立即执行函数写法：</p>
<pre><code>var Sum=(function(){
       var a=1;
       var b=2;
       var sum=function(){
           alert(a+b);
       };
       var sub=function(){
           alert(a-b);
       };
       return {
           sum:sum,
           sub:sub
       }
   })();
   alert(Sum.a);
   Sum.sum();
</code></pre><p> 第一个输出的Sum.a是undefind，外部是无法获取我们模块内部参数的，但是由于方法我们返回成为一个对象，因此是可以由外部调用的。</p>
<p>同时该模块还可以为其添加新的方法</p>
<pre><code>Sum=(function () {

        m3 = function () {
            alert(&quot;开始计算&quot;);
        };
        return {m3:m3}
    })(Sum);
        Sum.m3();
</code></pre><p>但是注意，这里不能直接调用Sum中的变量a，b，如果需要使用这些参数还需要重新赋予，关于解决方式大家有好的办法欢迎回复。</p>
<p>另外为了避免执行顺序等干扰造成程序报错，在添加方法时也可以写成</p>
</blockquote>
<pre><code>Sum=(function () {

    m3 = function () {
        alert(&quot;im&quot;);
    };
    return {m3:m3}
})(window.Sum || {});
</code></pre><p>这样即使是空对象也可以添加成功。</p>
<h1 id="八-正则与模式匹配"><a href="#八-正则与模式匹配" class="headerlink" title="八.正则与模式匹配"></a>八.正则与模式匹配</h1><h3 id="1-什么是正则？"><a href="#1-什么是正则？" class="headerlink" title="1.什么是正则？"></a>1.什么是正则？</h3><p> 在常见的字符串检索或替换中，我们需要提供一种模式表示检索或替换的规则。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串</p>
<h3 id="2-正则基础"><a href="#2-正则基础" class="headerlink" title="2.正则基础"></a>2.正则基础</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712215823.png" alt=""></p>
<h3 id="3-范围符号"><a href="#3-范围符号" class="headerlink" title="3.范围符号"></a>3.范围符号</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712215946.png" alt=""></p>
<h3 id="4-特殊字符转义"><a href="#4-特殊字符转义" class="headerlink" title="4.特殊字符转义"></a>4.特殊字符转义</h3><pre><code>/\^abc/.test(&apos;^abc&apos;);
</code></pre><h3 id="5-分组"><a href="#5-分组" class="headerlink" title="5.分组"></a>5.分组</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712220152.png" alt=""></p>
<h3 id="6-重复"><a href="#6-重复" class="headerlink" title="6.重复"></a>6.重复</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712220251.png" alt=""></p>
<h3 id="7-三个Flag"><a href="#7-三个Flag" class="headerlink" title="7.三个Flag"></a>7.三个Flag</h3><p>global </p>
<p>ignoreCase </p>
<p>multiline</p>
<pre><code>/abc/gim.test(&quot;ABC&quot;); //true
RegExp(&quot;abc&quot;,&quot;mgi&quot;);
</code></pre><h3 id="8-RegExp-对象属性"><a href="#8-RegExp-对象属性" class="headerlink" title="8.RegExp 对象属性"></a>8.RegExp 对象属性</h3><p>global </p>
<p>ignoreCase </p>
<p>multiline </p>
<p>source</p>
<pre><code>/abc/g.global //true
/abc/g.ignoreCase //false
/abc/g.multiline //false
/abc/g.source //&quot;abc&quot;
</code></pre><h3 id="9-RegExp-对象方法"><a href="#9-RegExp-对象方法" class="headerlink" title="9.RegExp 对象方法"></a>9.RegExp 对象方法</h3><p>complie exec test toString</p>
<pre><code>/abc/.exec(&quot;abcdef&quot;); //&quot;abc&quot;
/abc/.test(&quot;abcde&quot;); //true
/abc/.toString(); //&quot;/abc/&quot;

var reg = /abc/;
reg.compile(&quot;def&quot;);
reg.test(&quot;def&quot;); //true
</code></pre><h3 id="10-string类型与正则相关的方法"><a href="#10-string类型与正则相关的方法" class="headerlink" title="10.string类型与正则相关的方法"></a>10.string类型与正则相关的方法</h3><p>String.prototype.search</p>
<pre><code>&quot;abcabcdef&quot;.search(/(abc)\1); //0
</code></pre><p>String.prototype.replace</p>
<pre><code>&quot;aabbbbcc&quot;.repalce(/b+?/,&quot;1&quot;); //aa1bbbcc
</code></pre><p>String.prototype.match</p>
<pre><code>&quot;aabbbbcc&quot;.match(/b+/); //[&quot;bbbb&quot;]

&quot;aabbbbccbbaa&quot;.match(/b+/g); //[&quot;bbbb&quot;,&quot;bb&quot;]
</code></pre><p>String.prototype.split</p>
<pre><code>&quot;aabbbbccbbaa&quot;.split(/b+/); //[&quot;aa&quot;,&quot;cc&quot;,&quot;aa&quot;]
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/dom事件探秘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/dom事件探秘/" itemprop="url">dom事件探秘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:24:06+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h1><p>描述的是从页面中接受事件的顺序</p>
<p>###（1）.事件冒泡</p>
<blockquote>
<p>事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播至最不具体的那个节点（文档）。</p>
</blockquote>
<p>###（2）.事件捕获</p>
<p>不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件</p>
<h1 id="二、使用事件处理程序"><a href="#二、使用事件处理程序" class="headerlink" title="二、使用事件处理程序"></a>二、使用事件处理程序</h1><h3 id="1-HTML事件处理程序"><a href="#1-HTML事件处理程序" class="headerlink" title="(1).HTML事件处理程序"></a>(1).HTML事件处理程序</h3><p>缺点：</p>
<ol>
<li>js和html紧密在一起</li>
<li>如需修改，要改两个地方</li>
</ol>
<p>###（2）.DOM0级事件处理程序</p>
<p>较传统的方式：把一个函数赋值给一个事件的处理程序属性</p>
<p>用的比较多的方法 简单 跨浏览器的优势</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170719182127.png" alt=""></p>
<p>###（3）.DOM2级事件处理程序</p>
<p>DOM2级事件定义了两个方法：</p>
<blockquote>
<p>用于处理指定和删除事件处理程序的操作</p>
<p><strong>addEventListener()和removeEventListener().</strong></p>
<p>接收三个参数：要处理的事件名、作为事件处理程序的函数和布尔值（默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。）</p>
</blockquote>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170719183515.png" alt=""></p>
<blockquote>
<p>总结：</p>
<p>1、DOM0级和DOM2级的共同优点：</p>
<p>能添加多个事件处理程序，按顺序执行，HTML事件处理程序无法做到~</p>
<p>2、关于dom0级和dom2级的区别</p>
<p>DOM0级事件处理：同时绑定几个不同的事件，例如在绑定onclick的基础上再绑定一个onmouseover为按钮2设置背景颜色（这里注意不能onclick、onmouseover事件都设为alert弹出哦，可能有冲突，dom0和dom2都不能成功）；但是不能同时绑定多个相同的事件，比如onclick；会覆盖，只会执行最后一个的函数；</p>
<p>DOM2级事件处理：优点：同时绑定几个事件（相同或不同），然后顺序执行，不会覆盖。缺点：不具有跨浏览器优势。</p>
</blockquote>
<p>###（4）.IE事件处理程序</p>
<p><strong>attchEvent()添加事件</strong></p>
<p><strong>detachEvent()删除事件</strong></p>
<p>接受相同的两个参数：事件处理程序的名称和事件处理程序的函数</p>
<p>不使用第三个参数的原因：IE8以及更早的浏览器版本只支持事件冒泡</p>
<p>###（5）.跨浏览器的事件处理程序</p>
<h1 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h1><p>在触发DOM上的事件时都会产生一个对象</p>
<p>事件对象event</p>
<h3 id="1-DOM中的事件对象"><a href="#1-DOM中的事件对象" class="headerlink" title="1.DOM中的事件对象"></a>1.DOM中的事件对象</h3><p>（1）.type属性 用于获取事件类型</p>
<p>（2）.target属性 用于获取事件目标</p>
<p>（3）.stopPropagation()方法 用于阻止事件冒泡</p>
<p>（4）.preventDefault()方法 阻止事件的默认行为</p>
<h3 id="2-IE中的事件对象"><a href="#2-IE中的事件对象" class="headerlink" title="2.IE中的事件对象"></a>2.IE中的事件对象</h3><p>（1）.type属性 用于获取事件类型</p>
<p>（2）.srcElement属性 用于获取事件目标</p>
<p>（3）.cancelBubble()方法 用于阻止事件冒泡</p>
<p>设置为true表示阻止冒泡，设置为false表示不阻止冒泡</p>
<p>（4）.returnValue()方法 阻止事件的默认行为</p>
<p>设置为false表示阻止事件的默认行为</p>
<h1 id="四、事件类型"><a href="#四、事件类型" class="headerlink" title="四、事件类型"></a>四、事件类型</h1><p>###（1）.鼠标事件</p>
<p>onmousedown:在用户按下任何鼠标按钮时触发</p>
<p>onmousemove:当鼠标指针在元素内部移动时重复地触发</p>
<p>onmouseup:当用户释放鼠标按钮时触发</p>
<p>鼠标事件都是在浏览器窗口中的特定位置上发生的。这个位置信息保存在事件的clientX和clientY属性中。所有浏览器都支持这俩个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。不包括页面滚动的距离。</p>
<p>###（2）.键盘事件</p>
<p>keyDown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件</p>
<p>keyPress:当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件</p>
<p>keyUp:当用户释放键盘上的键时触发</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/canvas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/canvas/" itemprop="url">canvas</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:23:32+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、基本"><a href="#一、基本" class="headerlink" title="一、基本"></a>一、基本</h1><h3 id="1-写法"><a href="#1-写法" class="headerlink" title="1.写法"></a>1.写法</h3><ol>
<li><p>Html</p>
<pre><code>&lt;canvas id = &quot;canvas&quot;&gt;&lt;/canvas&gt;
</code></pre></li>
</ol>
<ol>
<li><p>Javascript</p>
<pre><code>var canvas = ducument.getElementById(&apos;canvas&apos;)
var context = canvas.getContext(&apos;2d&apos;)
//使用context进行绘制
</code></pre><h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h3></li>
</ol>
<ul>
<li>canvas.width</li>
<li>canvas.height</li>
<li>canvas.getContext(‘2d’)</li>
</ul>
<h1 id="二、线条基本"><a href="#二、线条基本" class="headerlink" title="二、线条基本"></a>二、线条基本</h1><h4 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h4><p>canvas是基于状态的绘制机制</p>
<pre><code>moveTo(x,y)
lineTo(x,y)//构成线条

beginPath()
closePath()//声明一个路径的开始和封闭的结束
</code></pre><h3 id="2-具体的状态设置"><a href="#2-具体的状态设置" class="headerlink" title="2.具体的状态设置"></a>2.具体的状态设置</h3><ul>
<li>lineWidth</li>
</ul>
<ul>
<li>strokeStyle</li>
</ul>
<ul>
<li>fillStyle</li>
</ul>
<p>stroke()</p>
<p>fill()</p>
<pre><code>//绘制矩形的三个函数
cxt.rect(x,y,width,height)

cxt.fillRect(x,y,width,height)

cxt.strokeRect(x,y,width,height)
</code></pre><h3 id="3-Draw-a-Rectangle"><a href="#3-Draw-a-Rectangle" class="headerlink" title="3.Draw a Rectangle"></a>3.Draw a Rectangle</h3><pre><code>cxt.moveTo(x,y)
cxt.lineTo(x+width,y)
cxt.lineTo(x+width,y+height)
cxt.lineTo(x,y+height)

cxt.rect(x,y,width,height)

cxt.fillRect(x,y,width,height)

cxt.strokeRect(x,y,width,height)
</code></pre><h4 id="1-遮挡"><a href="#1-遮挡" class="headerlink" title="(1).遮挡"></a>(1).遮挡</h4><p>后绘制的图案会遮挡前面绘制的图案（当然和颜色有关）</p>
<h4 id="2-fillStyle-strokeStyle"><a href="#2-fillStyle-strokeStyle" class="headerlink" title="(2).fillStyle strokeStyle"></a>(2).fillStyle strokeStyle</h4><pre><code>#fff
#642
rgb(255,128,0)
rgba(100,100,100,0.8) 透明度
hsl(20,62%,285）
hsla(40,82%,33%,0.6)
red
</code></pre><h1 id="三、线条的其他属性"><a href="#三、线条的其他属性" class="headerlink" title="三、线条的其他属性"></a>三、线条的其他属性</h1><ul>
<li>lineWidth</li>
</ul>
<ul>
<li><p>lineCap(用于设置一个线条两端的形状）</p>
<ol>
<li>butt(default)默认</li>
<li>round</li>
<li>square<blockquote>
<p>只适用线条的头尾，不适用中间</p>
</blockquote>
</li>
</ol>
</li>
<li><p>lineJoin(线条与线条相交的时候呈现出来的形态）</p>
<ol>
<li>miter(default)默认尖角</li>
<li>bevel 斜接</li>
<li>round 圆角</li>
</ol>
</li>
</ul>
<blockquote>
<p>context.miterLimit 只有当属性为miter时有效，默认为10<br>miterLimit描述了linejoin所形成的尖角，内角和外角距离的最大值，超过则用bevel呈现</p>
</blockquote>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723182344.png" alt=""></p>
<h3 id="1-Draw-a-Star"><a href="#1-Draw-a-Star" class="headerlink" title="(1).Draw a Star"></a>(1).Draw a Star</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170723180351.png" alt=""></p>
<h1 id="四、图像变换和状态保存"><a href="#四、图像变换和状态保存" class="headerlink" title="四、图像变换和状态保存"></a>四、图像变换和状态保存</h1><ul>
<li>位移 translate(x,y)</li>
</ul>
<ul>
<li>旋转 rotate(deg)</li>
</ul>
<ul>
<li>缩放 scale(sx,sy)//有副作用，坐标，边框都会放大</li>
</ul>
<p>在canvas的图形变换中，是叠加的</p>
<p>context.save() 保存图形的当前状态</p>
<p>context.restore() 返回在save这个节点的canvas的所有的状态</p>
<h1 id="五、深入理解图形变换"><a href="#五、深入理解图形变换" class="headerlink" title="五、深入理解图形变换"></a>五、深入理解图形变换</h1><h3 id="1-变换矩阵"><a href="#1-变换矩阵" class="headerlink" title="1.变换矩阵"></a>1.变换矩阵</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723193827.png" alt=""></p>
<h3 id="2-设置矩阵"><a href="#2-设置矩阵" class="headerlink" title="2.设置矩阵"></a>2.设置矩阵</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723193947.png" alt=""></p>
<p>因为transform有继承的一个特性，如果前面设置多个transform，会叠加。而使用setTransform,则会自动把前面的设置点消除掉</p>
<h1 id="六、填充样式"><a href="#六、填充样式" class="headerlink" title="六、填充样式"></a>六、填充样式</h1><h3 id="1-线性渐变"><a href="#1-线性渐变" class="headerlink" title="1.线性渐变"></a>1.线性渐变</h3><p>step 1</p>
<pre><code>var grd = context.createLinearGradient(xstart,ystart,xend,yend);
</code></pre><p>step2</p>
<pre><code>grd.addColorStop(stop,color)
</code></pre><h3 id="2-径向渐变"><a href="#2-径向渐变" class="headerlink" title="2.径向渐变"></a>2.径向渐变</h3><p>step1</p>
<pre><code>var grd = context.createRadialGradient(x0,y0,r0,x1,y1,r1);
</code></pre><p>step2</p>
<pre><code>grd.addColorStop(stop,color)
</code></pre><h3 id="3-使用图片、画布或者video"><a href="#3-使用图片、画布或者video" class="headerlink" title="3.使用图片、画布或者video"></a>3.使用图片、画布或者video</h3><p><em>createPattern</em></p>
<p>1、createPattern(img,repeat-style)</p>
<p>repeat-style:</p>
<ul>
<li>no-repeat</li>
<li>repeat-x</li>
<li>repeat-y</li>
<li>repeat</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723200717.png" alt=""></p>
<p>2、createPattern(canvas,repeat-style)</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723200812.png" alt=""></p>
<p>3、createPattern(video,repeat-style)</p>
<blockquote>
<p>fillStyle = color/gradient/image/canvas/video</p>
</blockquote>
<h1 id="六、曲线的绘制"><a href="#六、曲线的绘制" class="headerlink" title="六、曲线的绘制"></a>六、曲线的绘制</h1><h3 id="1-Draw-an-Arc"><a href="#1-Draw-an-Arc" class="headerlink" title="(1).Draw an Arc"></a>(1).Draw an Arc</h3><pre><code>context.arc(
    centerx,centery,radius,
    startingAngle,endingAngle,
    anticlockwise = false
)
//anticlockwise = false默认为顺时针
</code></pre><h3 id="2-arcTo"><a href="#2-arcTo" class="headerlink" title="(2)arcTo"></a>(2)arcTo</h3><pre><code>context.arcTo(
    x1,y1,x2,y2,radius);
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723202245.png" alt=""></p>
<p>x1,y1 x2,y2形成的直线是参考线，从起点开始，但是从切点开始弧度，终止弧度是另一条边的切点，注意，(x2,y2)不一定是弧线结束点</p>
<p>(x1,y1)实际上是一个控制点，(x2,y2)是终止点</p>
<h3 id="3-quadraticCurveTo"><a href="#3-quadraticCurveTo" class="headerlink" title="(3).quadraticCurveTo()"></a>(3).quadraticCurveTo()</h3><p>二次贝塞尔曲线</p>
<p>context.moveTo(x0,y0)<br>context.quadraticCurveTo(x1,y1,x2,y2)</p>
<p>与arcTo不一样的是，弧线的起点就是x0,y0。弧度由x1,y1这个控制点决定</p>
<h3 id="4-bezierCurveTo-三次贝塞尔曲线"><a href="#4-bezierCurveTo-三次贝塞尔曲线" class="headerlink" title="(4).bezierCurveTo() 三次贝塞尔曲线"></a>(4).bezierCurveTo() 三次贝塞尔曲线</h3><p>context.moveTo(x0,y0)<br>context.bezierCurveTo(x1,y1,x2,y2,x3,y3)</p>
<p>两个控制点，前面二次贝塞尔曲线不能画波浪线，外翻</p>
<h1 id="七、文字的渲染"><a href="#七、文字的渲染" class="headerlink" title="七、文字的渲染"></a>七、文字的渲染</h1><h3 id="1-文字渲染基础"><a href="#1-文字渲染基础" class="headerlink" title="(1).文字渲染基础"></a>(1).文字渲染基础</h3><pre><code>context.font = &apos;bold 40px Arial&apos;

context.fillText(string,x,y,[maxlen]);

context.strokeText(string,x,y,[maxlen])
</code></pre><h3 id="2-font"><a href="#2-font" class="headerlink" title="(2).font"></a>(2).font</h3><pre><code>默认值：&apos;20px sans-serif&apos;

context.font = font-style font-variant font-weight font-size font-family
</code></pre><ol>
<li><p>font-style:</p>
<ul>
<li>normal(default)</li>
<li>italic(斜体字)</li>
<li>oblique(倾斜字体)</li>
</ul>
</li>
<li><p>font-variant</p>
<ul>
<li>normal(default)</li>
<li>small-caps(英文大写的小字体)</li>
</ul>
</li>
<li><p>font-weight</p>
<ul>
<li>lighter</li>
<li>normal(100,200,300,400)</li>
<li>bold(500,600,700)</li>
<li>bolder(800,900)</li>
</ul>
</li>
<li><p>font-size</p>
</li>
<li><p>font-family</p>
</li>
</ol>
<h3 id="3-文本对齐"><a href="#3-文本对齐" class="headerlink" title="(3).文本对齐"></a>(3).文本对齐</h3><pre><code>水平对齐
context.textalign = left/center/right

垂直对齐
context.textBaseline = top/middle/bottom/alphabetic(default,针对拉丁文)/ideographic（针对汉字，日文等块状文字）/hanging(针对印度文)
</code></pre><h3 id="4-文本的度量"><a href="#4-文本的度量" class="headerlink" title="(4).文本的度量"></a>(4).文本的度量</h3><pre><code>context.measureText(string).width
</code></pre><h1 id="八、高级内容"><a href="#八、高级内容" class="headerlink" title="八、高级内容"></a>八、高级内容</h1><h3 id="1-阴影"><a href="#1-阴影" class="headerlink" title="(1).阴影"></a>(1).阴影</h3><pre><code>context.shadowColor

context.shadowOffsetX

context.shadowOffsetX

context.shadowBlur
</code></pre><h3 id="2-global"><a href="#2-global" class="headerlink" title="(2).global"></a>(2).global</h3><pre><code>globalAlpha//全局透明度

globalCompositeOperation//绘制的图像在重叠时所产生的效果
</code></pre><hr>
<pre><code>globalCompositeOperation

source-over
source-atop
source-in 
source-out

destination-over
destination-atop
destination-in
destination-out

lighter
copy
xor
</code></pre><h3 id="3-剪辑区域"><a href="#3-剪辑区域" class="headerlink" title="(3).剪辑区域"></a>(3).剪辑区域</h3><p>context.clip()</p>
<h3 id="4-路径方向和剪纸效果"><a href="#4-路径方向和剪纸效果" class="headerlink" title="(4).路径方向和剪纸效果"></a>(4).路径方向和剪纸效果</h3><h3 id="非零环绕原则"><a href="#非零环绕原则" class="headerlink" title="非零环绕原则"></a>非零环绕原则</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723214312.png" alt=""></p>
<p>如何判断里面/外面呢？</p>
<p>在一个区域里取一个点，向外引一条射线，那么这条射线就会与组成这个区域的线条相交，注意，绘制的这条线是有方向的。所以我们可以定义这条射线一个方向与线条相交是+1，反之-1；如果存在一条射线，按上面所说的计算，它的结果是非零，那么这个区域就是里面。</p>
<h3 id="5-clearRect"><a href="#5-clearRect" class="headerlink" title="(5).clearRect"></a>(5).clearRect</h3><pre><code>context.clearRect(x,y,width,height)
</code></pre><p>就是对这个指定区域进行一次清空操作，通常用在动画上，清空一次屏幕，然后重绘</p>
<h3 id="6-isPointInPath"><a href="#6-isPointInPath" class="headerlink" title="(6).isPointInPath"></a>(6).isPointInPath</h3><pre><code>context.isPointInPath(x,y)
</code></pre><p>看这个坐标是否在路径中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/css媒体查询/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/css媒体查询/" itemprop="url">css媒体查询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:22:39+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h1><pre><code>&lt;!-- link元素中的CSS媒体查询 --&gt;
&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;

&lt;!-- 样式表中的CSS媒体查询 --&gt;
&lt;style&gt;
@media (max-width: 600px) {
  .facet_sidebar {
    display: none;
  }
}
&lt;/style&gt;
</code></pre><p>即使媒体查询返回false, <link> 标签指向的样式表也将会被下载(但是它们不会被应用)</p>
<h1 id="2-逻辑操作符"><a href="#2-逻辑操作符" class="headerlink" title="2.逻辑操作符"></a>2.逻辑操作符</h1><h3 id="1-and"><a href="#1-and" class="headerlink" title="(1).and"></a>(1).and</h3><pre><code>@media tv and (min-width: 700px) and (orientation: landscape) { ... }
</code></pre><p>现在，上面媒体查询仅在电视媒体上，可视区域不小于700像素宽度并且是横屏时有效。</p>
<h3 id="2-逗号分隔列表"><a href="#2-逗号分隔列表" class="headerlink" title="(2).逗号分隔列表"></a>(2).逗号分隔列表</h3><pre><code>@media (min-width: 700px), handheld and (orientation: landscape) { ... }
</code></pre><p>等同于 or 逻辑操作符。</p>
<h3 id="3-not"><a href="#3-not" class="headerlink" title="(3).not"></a>(3).not</h3><pre><code>@media not all and (monochrome) { ... }
@media not (all and (monochrome)) { ... }

@media not screen and (color), print and (color)
@media (not (screen and (color))), print and (color)
</code></pre><h3 id="4-only"><a href="#4-only" class="headerlink" title="(4).only"></a>(4).only</h3><p>only 关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt;
</code></pre><h1 id="3-媒体属性"><a href="#3-媒体属性" class="headerlink" title="3.媒体属性"></a>3.媒体属性</h1><h3 id="1-颜色（color）"><a href="#1-颜色（color）" class="headerlink" title="(1).颜色（color）"></a>(1).颜色（color）</h3><p>指定输出设备每个像素单元的比特值。如果设备不支持输出颜色，则该值为0。</p>
<pre><code>向所有能显示颜色的设备应用样式表：

@media all and (color) { ... }

向每个颜色单元至少有4个比特的设备应用样式表：

@media all and (min-color: 4) { ... }
</code></pre><h3 id="2-颜色索引（color-index）"><a href="#2-颜色索引（color-index）" class="headerlink" title="(2).颜色索引（color-index）"></a>(2).颜色索引（color-index）</h3><pre><code>向所有使用索引颜色的设备应用样式表，你可以这么做：

@media all and (color-index) { ... }
向所有使用至少256个索引颜色的设备应用样式表：

&lt;link rel=&quot;stylesheet&quot; media=&quot;all and (min-color-index: 256)&quot; href=&quot;http://foo.bar.com/stylesheet
</code></pre><h3 id="3-宽高比（aspect-ratio）"><a href="#3-宽高比（aspect-ratio）" class="headerlink" title="(3).宽高比（aspect-ratio）"></a>(3).宽高比（aspect-ratio）</h3><p>描述了输出设备目标显示区域的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例。</p>
<h3 id="4-设备宽高比（device-aspect-ratio）"><a href="#4-设备宽高比（device-aspect-ratio）" class="headerlink" title="(4).设备宽高比（device-aspect-ratio）"></a>(4).设备宽高比（device-aspect-ratio）</h3><p>描述了输出设备的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例。</p>
<pre><code>@media screen and (device-aspect-ratio: 16/9), screen and (device-aspect-ratio: 16/10) { ... } 宽高比或者16：9或者16：10。
</code></pre><h3 id="5-设备高度（device-height）"><a href="#5-设备高度（device-height）" class="headerlink" title="(5).设备高度（device-height）"></a>(5).设备高度（device-height）</h3><p>描述了输出设备的高度（整个屏幕或页的高度，而不是仅仅像文档窗口一样的渲染区域）。</p>
<pre><code>向显示在最大宽度800px的屏幕上的文档应用样式表，你可以这样做：

&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width: 799px)&quot; /&gt;
</code></pre><h3 id="6-设备宽度（device-width）"><a href="#6-设备宽度（device-width）" class="headerlink" title="(6).设备宽度（device-width）"></a>(6).设备宽度（device-width）</h3><p>描述了输出设备的宽度（整个屏幕或页的高度，而不是仅仅像文档窗口一样的渲染区域）。</p>
<h3 id="7-网格（grid）"><a href="#7-网格（grid）" class="headerlink" title="(7).网格（grid）"></a>(7).网格（grid）</h3><p>是否接受 min/max 前缀： 否</p>
<p>判断输出设备是网格设备还是位图设备。如果设备是基于网格的（例如电传打字机终端或只能显示一种字形的电话），该值为1，否则为0。</p>
<h3 id="8-高度（height）"><a href="#8-高度（height）" class="headerlink" title="(8).高度（height）"></a>(8).高度（height）</h3><p>height 媒体属性描述了输出设备渲染区域（如可视区域的高度或打印机纸盒的高度）的高度。</p>
<h3 id="9-黑白（monochrome）"><a href="#9-黑白（monochrome）" class="headerlink" title="(9).黑白（monochrome）"></a>(9).黑白（monochrome）</h3><p>指定了一个黑白（灰度）设备每个像素的比特数。如果不是黑白设备，值为0。</p>
<h3 id="10-方向（orientation）"><a href="#10-方向（orientation）" class="headerlink" title="(10).方向（orientation）"></a>(10).方向（orientation）</h3><p>值：landscape | portrait</p>
<p>指定了设备处于横屏（宽度大于高度）模式还是竖屏（高度大于宽度）模式。</p>
<pre><code>向竖屏设备应用样式表：

@media all and (orientation: portrait) { ... }
</code></pre><h3 id="11-分辨率（resolution）"><a href="#11-分辨率（resolution）" class="headerlink" title="(11).分辨率（resolution）"></a>(11).分辨率（resolution）</h3><p>指定输出设备的分辨率（像素密度）。分辨率可以用每英寸（dpi）或每厘米（dpcm）的点数来表示。</p>
<h3 id="12-扫描（scan）"><a href="#12-扫描（scan）" class="headerlink" title="(12).扫描（scan）"></a>(12).扫描（scan）</h3><p>值： progressive | interlace</p>
<pre><code>向以顺序方式扫描的电视机上应用样式表：

@media tv and (scan: progressive) { ... }
</code></pre><h3 id="13-宽度（width）"><a href="#13-宽度（width）" class="headerlink" title="(13).宽度（width）"></a>(13).宽度（width）</h3><p>width 媒体属性描述了输出设备渲染区域（如可视区域的宽度或打印机纸盒的宽度）的宽度。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/javascript运行机制详解：event-loop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/javascript运行机制详解：event-loop/" itemprop="url">javascript运行机制详解：event loop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:22:05+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、为什么JavaScript是单线程？"><a href="#一、为什么JavaScript是单线程？" class="headerlink" title="一、为什么JavaScript是单线程？"></a>一、为什么JavaScript是单线程？</h1><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<h1 id="二、任务队列"><a href="#二、任务队列" class="headerlink" title="二、任务队列"></a>二、任务队列</h1><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>
<p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<blockquote>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br><img src="http://oncweb6po.bkt.clouddn.com/bg2014100801.jpg" alt=""><br>（4）主线程不断重复上面的第三步。</p>
</blockquote>
<h1 id="三、事件和回调函数"><a href="#三、事件和回调函数" class="headerlink" title="三、事件和回调函数"></a>三、事件和回调函数</h1><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p>
<p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>
<p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p>
<h1 id="四、Event-Loop"><a href="#四、Event-Loop" class="headerlink" title="四、Event Loop"></a>四、Event Loop</h1><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/bg2014100802.png" alt=""></p>
<p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。</p>
<p>执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。</p>
<pre><code>var req = new XMLHttpRequest();
req.open(&apos;GET&apos;, url);    
req.onload = function (){};    
req.onerror = function (){};    
req.send();
</code></pre><p>上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。</p>
<pre><code>var req = new XMLHttpRequest();
req.open(&apos;GET&apos;, url);
req.send();
req.onload = function (){};    
req.onerror = function (){};   
</code></pre><p>也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。</p>
<h1 id="五、定时器"><a href="#五、定时器" class="headerlink" title="五、定时器"></a>五、定时器</h1><p>除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。</p>
<p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。</p>
<p>setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。</p>
<pre><code>console.log(1);
setTimeout(function(){console.log(2);},1000);
console.log(3);
</code></pre><p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。</p>
<p>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p>
<pre><code>setTimeout(function(){console.log(1);}, 0);
console.log(2);
</code></pre><p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。</p>
<p>总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>
<p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p>
<p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/js进阶知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/js进阶知识/" itemprop="url">js进阶知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:21:36+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、变量名"><a href="#一、变量名" class="headerlink" title="一、变量名"></a>一、变量名</h1><h3 id="1-命名"><a href="#1-命名" class="headerlink" title="1.命名"></a>1.命名</h3><p>1.必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字。</p>
<p>2.变量名区分大小写，如:A与a是两个不同变量。</p>
<p>3.不允许使用JavaScript关键字和保留字做变量名。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/529c07c000014f5103080447.jpg" alt=""></p>
<h3 id="2-声明"><a href="#2-声明" class="headerlink" title="2.声明"></a>2.声明</h3><pre><code>var mynum ; //声明一个变量mynum
var num1,mun2 ; //声明一个变量num1
</code></pre><h3 id="3-变量赋值"><a href="#3-变量赋值" class="headerlink" title="3.变量赋值"></a>3.变量赋值</h3><p>= 是赋值，==是等于号</p>
<pre><code>var num1 = 123;       // 123是数值
var num2 = &quot;一二三&quot;;    //&quot;一二三&quot;是字符串
var num3=true;    //布尔值true（真），false(假)
</code></pre><h1 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h1><h3 id="1-二维数组"><a href="#1-二维数组" class="headerlink" title="1.二维数组"></a>1.二维数组</h3><pre><code>var myarr=new Array();  //先声明一维 
for(var i=0;i&lt;2;i++){   //一维长度为2
   myarr[i]=new Array();  //再声明二维 
   for(var j=0;j&lt;3;j++){   //二维长度为3
   myarr[i][j]=i+j;   // 赋值，每个数组元素的值为i+j
   }
 }
</code></pre><hr>
<pre><code>var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]]
</code></pre><h1 id="三、鼠标事件"><a href="#三、鼠标事件" class="headerlink" title="三、鼠标事件"></a>三、鼠标事件</h1><p><img src="http://oncweb6po.bkt.clouddn.com/53e198540001b66404860353.jpg" alt=""></p>
<h3 id="1-onfocus（获得焦点事件）"><a href="#1-onfocus（获得焦点事件）" class="headerlink" title="1.onfocus（获得焦点事件）"></a>1.onfocus（获得焦点事件）</h3><p>当一个文本框获得焦点时，它里面的文本就像“好123”网站上的百度搜索输入框那样全部被自动选中，这样的操作可以利用onfocus来实现。 </p>
<p>以下的文本框，当鼠标指针移过去时，里面的文字全部被选中： </p>
<p>请输入网址 </p>
<p>这是怎么做的呢？看以下代码及解释： </p>
<pre><code>&lt;input type=&quot;text&quot;name=&quot;url&quot; value=&quot;http://www.gxblk.com&quot; size=&quot;30&quot;onmousemove=&quot;this.focus();this.select();&quot;&gt;
</code></pre><blockquote>
<p>代码里，input标签内嵌入了onmousemove（鼠标指针经过）事件的JS语句，其等号后面的this.focus()意为其自身获得焦点；获得焦点的标志是该文本框内将出现输入光标，但要让其内的文字全部被选中，我们还得用上this.select()语句，它的意思就是选中全部文本框里的文字。</p>
</blockquote>
<h3 id="2-onblur（失去焦点事件）"><a href="#2-onblur（失去焦点事件）" class="headerlink" title="2.onblur（失去焦点事件）"></a>2.onblur（失去焦点事件）</h3><p>我们经常会检测文本框是否已经被正确输入，检测工作通常在用户点击了提交按钮之后进行，事实上，利用控件失去焦点的时候，我们就可以实时进行这个检测工作，这样的话，onblur事件就派上用场了。 </p>
<p>以下例子有四个文本框，如果还没有任何单击它们当中的任意一个的操作，那么什么事情也不会发生，但是，当你单击了其中的任何一个使其拥有了焦点（输入光标在里面），如果什么都没有输入并且单击了别的地方令其失去焦点，就会弹出一个警告，试试看 </p>
<p>姓名 </p>
<p>性别 </p>
<p>年龄 </p>
<p>住址 </p>
<p>以下是代码和解释： </p>
<p>表单代码 </p>
<pre><code>&lt;form name=&quot;blur_test&quot;&gt; 
&lt;p&gt;姓名 &lt;input type=&quot;text&quot; name=&quot;name&quot;value=&quot;&quot; size=&quot;30&quot;onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 
性别 &lt;inputtype=&quot;text&quot; name=&quot;sex&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 
年龄 &lt;inputtype=&quot;text&quot; name=&quot;age&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 
住址 &lt;inputtype=&quot;text&quot; name=&quot;addr&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;/p&gt; 
&lt;/form&gt;

&lt;scriptlanguage=&quot;javascript&quot;&gt; 
function chkvalue(txt) { 
if(txt.value==&quot;&quot;) alert(&quot;文本框里必须填写内容!&quot;); 
} 
&lt;/script&gt;
</code></pre><blockquote>
<p>表单代码里，每一个方框框的代码都嵌入一个onblur JS语句，它们都调用后面的JS代码中的自定义函数chkvalue(this)，意思是，当文本框失去焦点时就调用chkvalue()函数；这chkvalue()函数检测文本框是否为空，如果是就弹出警告窗口。该函数有一个参数（txt），对应于前面文本框调用该函数的参数（this）即自身。 </p>
</blockquote>
<h3 id="3-onselect事件"><a href="#3-onselect事件" class="headerlink" title="3.onselect事件"></a>3.onselect事件</h3><p>选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。</p>
<h3 id="4-文本框内容改变事件（onchange）"><a href="#4-文本框内容改变事件（onchange）" class="headerlink" title="4.文本框内容改变事件（onchange）"></a>4.文本框内容改变事件（onchange）</h3><p>通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。</p>
<h3 id="5-加载事件（onload）"><a href="#5-加载事件（onload）" class="headerlink" title="5.加载事件（onload）"></a>5.加载事件（onload）</h3><p>事件会在页面加载完成后，立即发生，同时执行被调用的程序。</p>
<p>注意：</p>
<p>1、加载页面时，触发onload事件，事件写在<body>标签内。</body></p>
<p>2、此节的加载页面，可理解为打开一个新页面时。</p>
<p>如下代码,当加载一个新页面时，弹出对话框“加载中，请稍等…”。</p>
<blockquote>
<p>支持的标签：<body\>, <frame\>, <frameset\>, <iframe\>, <img\>, <input type="image" \="">, <link\>, <script\> ,<style\>，写在<body\>内监听页面加载，正如写在<img\>监听图像加载。</img\></body\></style\></script\></link\></img\></iframe\></frameset\></frame\></body\></p>
</blockquote>
<h3 id="6-卸载事件（onunload）"><a href="#6-卸载事件（onunload）" class="headerlink" title="6.卸载事件（onunload）"></a>6.卸载事件（onunload）</h3><p>当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。</p>
<p><strong>注意：不同浏览器对onunload事件支持不同。</strong></p>
<p>如下代码,当退出页面时，弹出对话框“您确定离开该网页吗？”。</p>
<h1 id="四、-JavaScript内置对象"><a href="#四、-JavaScript内置对象" class="headerlink" title="四、 JavaScript内置对象"></a>四、 JavaScript内置对象</h1><h3 id="1-Date-日期对象"><a href="#1-Date-日期对象" class="headerlink" title="1.Date 日期对象"></a>1.Date 日期对象</h3><p>定义一个时间对象 :</p>
<pre><code>var Udate=new Date(); 
</code></pre><p>使 Udate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。</p>
<p>访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;”</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/555c650d0001ae7b04180297.jpg" alt=""></p>
<h4 id="1-返回星期方法"><a href="#1-返回星期方法" class="headerlink" title="(1).返回星期方法"></a>(1).返回星期方法</h4><p>getDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var mydate=new Date();//定义日期对象
  var weekday=[&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;];
//定义数组对象,给每个数组项赋值
  var mynum=mydate.getDay();//返回值存储在变量mynum中
  document.write(mydate.getDay());//输出getDay()获取值
  document.write(&quot;今天是：&quot;+ weekday[mynum]);//输出星期几
&lt;/script&gt;
</code></pre><h4 id="2-返回-设置时间方法"><a href="#2-返回-设置时间方法" class="headerlink" title="(2).返回/设置时间方法"></a>(2).返回/设置时间方法</h4><p>get/setTime() 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。</p>
<h3 id="2-String字符串对象"><a href="#2-String字符串对象" class="headerlink" title="2.String字符串对象"></a>2.String字符串对象</h3><h4 id="1-toUpperCase-，toLowerCase"><a href="#1-toUpperCase-，toLowerCase" class="headerlink" title="(1).toUpperCase()，toLowerCase()"></a>(1).toUpperCase()，toLowerCase()</h4><p>使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写,另一个反之</p>
<h4 id="2-charAt"><a href="#2-charAt" class="headerlink" title="(2).charAt()"></a>(2).charAt()</h4><pre><code>stringObject.charAt(index)
</code></pre><p>可返回指定位置的字符。返回的字符是长度为 1 的字符串。</p>
<h4 id="3-字符串分割split"><a href="#3-字符串分割split" class="headerlink" title="(3).字符串分割split()"></a>(3).字符串分割split()</h4><p>split() 方法将字符串分割为字符串数组，并返回此数组。</p>
<pre><code>stringObject.split(separator,limit)
</code></pre><p><strong>注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。</strong></p>
<pre><code>var mystr = &quot;www.imooc.com&quot;;
document.write(mystr.split(&quot;.&quot;)+&quot;&lt;br&gt;&quot;);
document.write(mystr.split(&quot;.&quot;, 2)+&quot;&lt;br&gt;&quot;);

www,imooc,com
www,imooc

document.write(mystr.split(&quot;&quot;)+&quot;&lt;br&gt;&quot;);
document.write(mystr.split(&quot;&quot;, 5));

w,w,w,.,i,m,o,o,c,.,c,o,m
w,w,w,.,i
</code></pre><h4 id="4-提取字符串substring"><a href="#4-提取字符串substring" class="headerlink" title="(4).提取字符串substring()"></a>(4).提取字符串substring()</h4><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符</p>
<pre><code>stringObject.substring(startPos,stopPos) 
</code></pre><p><strong>注意：</strong></p>
<ol>
<li>返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。</li>
<li>如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。</li>
<li>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。</li>
</ol>
<h4 id="5-提取指定数目的字符substr"><a href="#5-提取指定数目的字符substr" class="headerlink" title="(5).提取指定数目的字符substr()"></a>(5).提取指定数目的字符substr()</h4><p>substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。</p>
<pre><code>stringObject.substr(startPos,length)
</code></pre><p><strong>注意：</strong></p>
<p>如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。<br>如果startPos为负数且绝对值大于字符串长度，startPos为0。</p>
<blockquote>
<p>string.substring( 起点 ， 终点 )</p>
<p>string.substr( 起点 ，长度 )</p>
</blockquote>
<h3 id="3-Math对象"><a href="#3-Math对象" class="headerlink" title="3.Math对象"></a>3.Math对象</h3><p>Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。</p>
<p>Math 对象属性</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/532fe7cf0001e7b505170269.jpg" alt=""></p>
<p>Math 对象方法</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/532fe841000174db05160622.jpg" alt=""></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var mypi=Math.PI; 
  var myabs=Math.abs(-15);
  document.write(mypi);
  document.write(myabs);
&lt;/script&gt;

3.141592653589793
15
</code></pre><h4 id="1-向上取整ceil"><a href="#1-向上取整ceil" class="headerlink" title="(1).向上取整ceil()"></a>(1).向上取整ceil()</h4><pre><code>Math.ceil(x)
</code></pre><p>ceil() 方法可对一个数进行向上取整。x必须是一个数值</p>
<p><strong>注意：</strong>它返回的是大于或等于x，并且与x最接近的整数。</p>
<h4 id="2-向下取整floor"><a href="#2-向下取整floor" class="headerlink" title="(2).向下取整floor()"></a>(2).向下取整floor()</h4><pre><code>Math.floor(x)
</code></pre><p>floor() 方法可对一个数进行向下取整。</p>
<p><strong>注意：</strong>返回的是小于或等于x，并且与 x 最接近的整数。</p>
<h4 id="3-四舍五入round"><a href="#3-四舍五入round" class="headerlink" title="(3).四舍五入round()"></a>(3).四舍五入round()</h4><pre><code>Math.round(x)
</code></pre><p>round() 方法可把一个数字四舍五入为最接近的整数。</p>
<p>注意：</p>
<ol>
<li>返回与 x 最接近的整数。</li>
<li>对于 0.5，该方法将进行上舍入。(5.5 将舍入为 6)</li>
<li>如果 x 与两侧整数同等接近，则结果接近 +∞方向的数字值 。(如 -5.5 将舍入为 -5; -5.52 将舍入为 -6)</li>
</ol>
<h4 id="4-随机数-random"><a href="#4-随机数-random" class="headerlink" title="(4).随机数 random()"></a>(4).随机数 random()</h4><pre><code>Math.random();
</code></pre><p>random() 方法可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。</p>
<p><strong>注意：</strong>返回一个大于或等于 0 但小于 1 的符号为正的数字值。</p>
<h3 id="4-Array-数组对象"><a href="#4-Array-数组对象" class="headerlink" title="4.Array 数组对象"></a>4.Array 数组对象</h3><p><img src="http://oncweb6po.bkt.clouddn.com/533295ab0001dead05190599.jpg" alt=""></p>
<h4 id="1-数组连接concat"><a href="#1-数组连接concat" class="headerlink" title="(1).数组连接concat()"></a>(1).数组连接concat()</h4><p>concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var mya = new Array(3);
  mya[0] = &quot;1&quot;;
  mya[1] = &quot;2&quot;;
  mya[2] = &quot;3&quot;;
  document.write(mya.concat(4,5)+&quot;&lt;br&gt;&quot;);
  document.write(mya); 
&lt;/script&gt;

1,2,3,4,5
1,2,3
</code></pre><h4 id="2-指定分隔符连接数组元素join"><a href="#2-指定分隔符连接数组元素join" class="headerlink" title="(2).指定分隔符连接数组元素join()"></a>(2).指定分隔符连接数组元素join()</h4><p>join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。不改变原来数组</p>
<h4 id="3-颠倒数组元素顺序reverse"><a href="#3-颠倒数组元素顺序reverse" class="headerlink" title="(3).颠倒数组元素顺序reverse()"></a>(3).颠倒数组元素顺序reverse()</h4><p>该方法会改变原来的数组，而不会创建新的数组。</p>
<h4 id="4-选定元素slice"><a href="#4-选定元素slice" class="headerlink" title="(4).选定元素slice()"></a>(4).选定元素slice()</h4><pre><code>arrayObject.slice(start,end)
</code></pre><p><strong>注意：</strong></p>
<ol>
<li>可使用负值从数组的尾部选取元素。<br>2.如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。</li>
<li>String.slice() 与 Array.slice() 相似。</li>
<li>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</li>
<li>该方法并不会修改数组，而是返回一个子数组</li>
</ol>
<h4 id="5-数组排序sort"><a href="#5-数组排序sort" class="headerlink" title="(5).数组排序sort()"></a>(5).数组排序sort()</h4><pre><code>arrayObject.sort(方法函数)
</code></pre><p><strong>注意</strong></p>
<p>1.如果不指定&lt;方法函数&gt;，则按unicode码顺序排列。</p>
<p>2.如果指定&lt;方法函数&gt;，则按&lt;方法函数&gt;所指定的排序方法排序。</p>
<pre><code>排序函数：

&lt;script type=&quot;text/javascript&quot;&gt;
  function sortNum(a,b) {
  return a - b;
 //升序，如降序，把“a - b”该成“b - a”
}
 var myarr = new Array(&quot;80&quot;,&quot;16&quot;,&quot;50&quot;,&quot;6&quot;,&quot;100&quot;,&quot;1&quot;);
  document.write(myarr + &quot;&lt;br&gt;&quot;);
  document.write(myarr.sort(sortNum));
&lt;/script&gt;


80,16,50,6,100,1
1,6,16,50,80,100
</code></pre><h1 id="五、浏览器对象"><a href="#五、浏览器对象" class="headerlink" title="五、浏览器对象"></a>五、浏览器对象</h1><p>window对象是BOM的核心，window对象指当前的浏览器窗口。</p>
<p>window对象方法:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/535483720001a54506670563.jpg" alt=""></p>
<h3 id="1-计时器"><a href="#1-计时器" class="headerlink" title="1.计时器"></a>1.计时器</h3><p>在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。<br>计时器类型：</p>
<p>一次性计时器：仅在指定的延迟时间之后触发一次。</p>
<p>间隔性触发计时器：每隔一定的时间间隔就触发一次。</p>
<p>计时器方法：</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/56976e1700014fc504090143.jpg" alt=""></p>
<h4 id="1-setInterval"><a href="#1-setInterval" class="headerlink" title="(1).setInterval()"></a>(1).setInterval()</h4><p>在执行时,从载入页面后每隔指定的时间执行代码。</p>
<pre><code>setInterval(代码,交互时间);
</code></pre><p>参数说明：</p>
<ol>
<li>代码：要调用的函数或要执行的代码串。</li>
<li>交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。</li>
</ol>
<p>返回值:<br>一个可以传递给 clearInterval() 从而取消对”代码”的周期性执行的值。</p>
<pre><code>调用函数格式(假设有一个clock()函数):
setInterval(&quot;clock()&quot;,1000)
或
setInterval(clock,1000)
</code></pre><p>我们设置一个计时器，每隔100毫秒调用clock()函数，并将时间显示出来，代码如下:</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
&lt;title&gt;计时器&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var int=setInterval(clock, 100)
  function clock(){
    var time=new Date();
    document.getElementById(&quot;clock&quot;).value = time;
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;clock&quot; size=&quot;50&quot;  /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="2-取消计时器clearInterval"><a href="#2-取消计时器clearInterval" class="headerlink" title="(2).取消计时器clearInterval()"></a>(2).取消计时器clearInterval()</h3><p>clearInterval() 方法可取消由 setInterval() 设置的交互时间。</p>
<pre><code>clearInterval(id_of_setInterval)
</code></pre><p>参数说明:</p>
<p>id_of_setInterval：由 setInterval() 返回的 ID 值。</p>
<p>每隔 100 毫秒调用 clock() 函数,并显示时间。当点击按钮时，停止时间,代码如下:</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
&lt;title&gt;计时器&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
   function clock(){
      var time=new Date();                     
      document.getElementById(&quot;clock&quot;).value = time;
   }
// 每隔100毫秒调用clock函数，并将返回值赋值给i
     var i=setInterval(&quot;clock()&quot;,100);
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;clock&quot; size=&quot;50&quot;  /&gt;
    &lt;input type=&quot;button&quot; value=&quot;Stop&quot; onclick=&quot;clearInterval(i)&quot;  /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="3-计时器setTimeout"><a href="#3-计时器setTimeout" class="headerlink" title="(3).计时器setTimeout()"></a>(3).计时器setTimeout()</h3><p>setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次。</p>
<pre><code>setTimeout(代码,延迟时间);
</code></pre><p>参数说明：</p>
<ol>
<li>要调用的函数或要执行的代码串。</li>
<li>延时时间：在执行代码前需等待的时间，以毫秒为单位（1s=1000ms)。</li>
</ol>
<p>要创建一个运行于无穷循环中的计数器，我们需要编写一个函数来调用其自身。在下面的代码，当按钮被点击后，输入域便从0开始计数。</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var num=0;
function numCount(){
 document.getElementById(&apos;txt&apos;).value=num;
 num=num+1;
 setTimeout(&quot;numCount()&quot;,1000);
 }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form&gt;
&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;
&lt;input type=&quot;button&quot; value=&quot;Start&quot; onClick=&quot;numCount()&quot; /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="4-取消计时器clearTimeout"><a href="#4-取消计时器clearTimeout" class="headerlink" title="(4).取消计时器clearTimeout()"></a>(4).取消计时器clearTimeout()</h3><p>setTimeout()和clearTimeout()一起使用，停止计时器。</p>
<pre><code>clearTimeout(id_of_setTimeout)
</code></pre><hr>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var num=0,i;
  function timedCount(){
    document.getElementById(&apos;txt&apos;).value=num;
    num=num+1;
    i=setTimeout(timedCount,1000);
  }
    setTimeout(timedCount,1000);
  function stopCount(){
    clearTimeout(i);
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Stop&quot; onClick=&quot;stopCount()&quot;&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="2-History对象"><a href="#2-History对象" class="headerlink" title="2.History对象"></a>2.History对象</h3><p>history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。</p>
<p><strong>注意:</strong></p>
<p>从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。</p>
<p>window.history.[属性|方法]（window可以省略。）</p>
<p>History 对象属性</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/53548c030001759e05840068.jpg" alt=""></p>
<p>History 对象方法</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/53548c200001228206210123.jpg" alt=""></p>
<h4 id="1-返回前一个浏览的页面"><a href="#1-返回前一个浏览的页面" class="headerlink" title="(1).返回前一个浏览的页面"></a>(1).返回前一个浏览的页面</h4><p>back()方法，加载 history 列表中的前一个 URL。</p>
<pre><code>window.history.back();
</code></pre><p>比如，返回前一个浏览的页面，代码如下：<br>window.history.back();</p>
<p>注意：等同于点击浏览器的倒退按钮。</p>
<p>back()相当于go(-1),代码如下:</p>
<pre><code>window.history.go(-1);
</code></pre><h4 id="2-返回下一个浏览的页面"><a href="#2-返回下一个浏览的页面" class="headerlink" title="(2).返回下一个浏览的页面"></a>(2).返回下一个浏览的页面</h4><p>forward()方法，加载 history 列表中的下一个 URL。</p>
<p>如果倒退之后，再想回到倒退之前浏览的页面，则可以使用forward()方法,代码如下:</p>
<pre><code>window.history.forward();
</code></pre><p>注意：等价点击前进按钮。</p>
<p>forward()相当于go(1),代码如下:</p>
<pre><code>window.history.go(1);
</code></pre><h4 id="3-返回浏览历史中的其他页面"><a href="#3-返回浏览历史中的其他页面" class="headerlink" title="(3).返回浏览历史中的其他页面"></a>(3).返回浏览历史中的其他页面</h4><p>go()方法，根据当前所处的页面，加载 history 列表中的某个具体的页面。</p>
<pre><code>window.history.go(number);

go(1)等价forward()
go(0)等价当前页面
go(-1)等价back()
</code></pre><h3 id="3-Location对象"><a href="#3-Location对象" class="headerlink" title="3.Location对象"></a>3.Location对象</h3><p>location用于获取或设置窗体的URL，并且可以用于解析URL。</p>
<pre><code>location.[属性|方法]
</code></pre><p>location对象属性图示:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/53605c5a0001b26909900216.jpg" alt=""></p>
<p>location 对象属性：</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/5354b1d00001c4ec06220271.jpg" alt=""></p>
<p>location 对象方法:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/5354b1eb00016a2405170126.jpg" alt=""></p>
<h3 id="4-Navigator对象"><a href="#4-Navigator对象" class="headerlink" title="4.Navigator对象"></a>4.Navigator对象</h3><p>Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。</p>
<p>对象属性:<br><img src="http://oncweb6po.bkt.clouddn.com/5354cff70001428b06880190.jpg" alt=""></p>
<h3 id="5-screen对象"><a href="#5-screen对象" class="headerlink" title="5.screen对象"></a>5.screen对象</h3><p>screen对象用于获取用户的屏幕信息。</p>
<pre><code>window.screen.属性
</code></pre><p>对象属性:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/5354d2810001a47706210213.jpg" alt=""></p>
<h4 id="1-屏幕分辨率的高和宽"><a href="#1-屏幕分辨率的高和宽" class="headerlink" title="(1).屏幕分辨率的高和宽"></a>(1).屏幕分辨率的高和宽</h4><p>window.screen 对象包含有关用户屏幕的信息。</p>
<ol>
<li>screen.height 返回屏幕分辨率的高</li>
<li>screen.width 返回屏幕分辨率的宽</li>
</ol>
<p><strong>注意:</strong></p>
<p>1.单位以像素计。</p>
<ol>
<li>window.screen 对象在编写时可以不使用 window 这个前缀。</li>
</ol>
<h4 id="2-屏幕可用高和宽度"><a href="#2-屏幕可用高和宽度" class="headerlink" title="(2).屏幕可用高和宽度"></a>(2).屏幕可用高和宽度</h4><ol>
<li><p>screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如任务栏。</p>
</li>
<li><p>screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如任务栏。</p>
</li>
</ol>
<p><strong>注意:</strong><br>不同系统的任务栏默认高度不一样，及任务栏的位置可在屏幕上下左右任何位置，所以有可能可用宽度和高度不一样。</p>
<h1 id="六、DOM"><a href="#六、DOM" class="headerlink" title="六、DOM"></a>六、DOM</h1><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p>
<p>HTML文档可以说由节点构成的集合，DOM节点有:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170719160326.png" alt=""></p>
<ol>
<li>元素节点：上图中<html>、<body>、<p>等都是元素节点，即标签。</p></body></html></li>
<li><p>文本节点:向用户展示的内容，如<li\>…</li\>中的JavaScript、DOM、CSS等文本。</p>
</li>
<li><p>属性节点:元素属性，如<a\>标签的链接属性href=”<a href="http://www.imooc.com&quot;。" target="_blank" rel="external">http://www.imooc.com&quot;。</a></a\></p>
</li>
</ol>
<p>节点属性:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/5375c953000117ee05240129.jpg" alt=""></p>
<p>遍历节点树:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/53f17a6400017d2905230219.jpg" alt=""></p>
<p>DOM操作:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/538d29da000152db05360278.jpg" alt=""></p>
<p>注意:前两个是document方法。</p>
<h4 id="1-getElementsByName-方法"><a href="#1-getElementsByName-方法" class="headerlink" title="(1).getElementsByName()方法"></a>(1).getElementsByName()方法</h4><p><strong>注意:</strong></p>
<ol>
<li>因为文档中的 name 属性可能不唯一，所有 getElementsByName() 方法返回的是元素的数组，而不是一个元素。</li>
<li>和数组类似也有length属性，可以和访问数组一样的方法来访问，从0开始。</li>
</ol>
<h4 id="2-getElementsByTagName-方法"><a href="#2-getElementsByTagName-方法" class="headerlink" title="(2).getElementsByTagName()方法"></a>(2).getElementsByTagName()方法</h4><p>返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。</p>
<p><strong>说明:</strong></p>
<ol>
<li>Tagname是标签的名称，如p、a、img等标签名。</li>
<li>和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。</li>
</ol>
<h4 id="3-getAttribute-方法"><a href="#3-getAttribute-方法" class="headerlink" title="(3).getAttribute()方法"></a>(3).getAttribute()方法</h4><p>通过元素节点的属性名称获取属性的值。</p>
<pre><code>elementNode.getAttribute(name)
</code></pre><h4 id="4-setAttribute"><a href="#4-setAttribute" class="headerlink" title="(4).setAttribute()"></a>(4).setAttribute()</h4><p>setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。</p>
<pre><code>elementNode.setAttribute(name,value)
</code></pre><p><strong>说明：</strong></p>
<p>1.name: 要设置的属性名。</p>
<p>2.value: 要设置的属性值。</p>
<p><strong>注意：</strong></p>
<p>1.把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。</p>
<p>2.类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。</p>
<h4 id="5-节点属性"><a href="#5-节点属性" class="headerlink" title="5.节点属性"></a>5.节点属性</h4><p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：</p>
<ol>
<li>nodeName : 节点的名称</li>
<li>nodeValue ：节点的值</li>
<li>nodeType ：节点的类型</li>
</ol>
<p>一、nodeName 属性: 节点的名称，是只读的。</p>
<ol>
<li>元素节点的 nodeName 与标签名相同</li>
<li>属性节点的 nodeName 是属性的名称</li>
<li>文本节点的 nodeName 永远是 #text</li>
<li>文档节点的 nodeName 永远是 #document</li>
</ol>
<p>二、nodeValue 属性：节点的值</p>
<ol>
<li>元素节点的 nodeValue 是 undefined 或 null</li>
<li>文本节点的 nodeValue 是文本自身</li>
<li>属性节点的 nodeValue 是属性的值</li>
</ol>
<p>三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型:</p>
<p>元素类型    节点类型</p>
<ul>
<li>元素          1</li>
</ul>
<ul>
<li>属性          2</li>
</ul>
<ul>
<li>文本          3</li>
</ul>
<ul>
<li>注释          8</li>
</ul>
<ul>
<li>文档          9</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170719161333.png" alt=""></p>
<h4 id="6-访问子节点childNodes"><a href="#6-访问子节点childNodes" class="headerlink" title="6.访问子节点childNodes"></a>6.访问子节点childNodes</h4><p>访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，他具有length属性。</p>
<pre><code>elementNode.childNodes
</code></pre><p><strong>注意：</strong><br>如果选定的节点没有子节点，则该属性返回不包含节点的 NodeList。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/538405fa00010e6c05630357.jpg" alt=""></p>
<pre><code>运行结果:
IE:
  UL子节点个数:3
  节点类型:1
其它浏览器:
   UL子节点个数:7
   节点类型:3
</code></pre><p><strong>注意:</strong></p>
<ol>
<li>IE全系列、firefox、chrome、opera、safari兼容问题</li>
<li>节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点，所以IE是3，其它浏览器是7，如下图所示:</li>
</ol>
<p><img src="http://oncweb6po.bkt.clouddn.com/538d2b8a000163e303430127.jpg" alt=""></p>
<p>如果把代码改成这样:</p>
<p><ul\><li\>javascript</li\><li\>jQuery</li\><li\>PHP</li\></ul\></p>
<pre><code>运行结果:（IE和其它浏览器结果是一样的）
  UL子节点个数:3
  节点类型:1
</code></pre><h4 id="7-访问子节点的第一和最后项"><a href="#7-访问子节点的第一和最后项" class="headerlink" title="7.访问子节点的第一和最后项"></a>7.访问子节点的第一和最后项</h4><p>一、firstChild 属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。</p>
<pre><code>node.firstChild
</code></pre><p>说明：与elementNode.childNodes[0]是同样的效果。 </p>
<p>二、 lastChild 属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。</p>
<pre><code>node.lastChild
</code></pre><p>说明：与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 </p>
<h4 id="8-访问父节点parentNode"><a href="#8-访问父节点parentNode" class="headerlink" title="8.访问父节点parentNode"></a>8.访问父节点parentNode</h4><p>获取指定节点的父节点</p>
<pre><code>elementNode.parentNode
</code></pre><p><strong>注意</strong>:父节点只能有一个。</p>
<h4 id="9-访问兄弟节点"><a href="#9-访问兄弟节点" class="headerlink" title="9.访问兄弟节点"></a>9.访问兄弟节点</h4><ol>
<li><p>nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。</p>
<p> nodeObject.nextSibling</p>
</li>
</ol>
<p>说明：如果无此节点，则该属性返回 null。</p>
<ol>
<li><p>previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。</p>
<p> nodeObject.previousSibling  </p>
</li>
</ol>
<p>说明：如果无此节点，则该属性返回 null。</p>
<p>注意: 两个属性获取的是节点。Internet Explorer 会忽略节点间生成的空白文本节点（例如，换行符号），而其它浏览器不会忽略。</p>
<h4 id="10-插入节点appendChild"><a href="#10-插入节点appendChild" class="headerlink" title="10.插入节点appendChild()"></a>10.插入节点appendChild()</h4><p>在指定节点的最后一个子节点列表之后添加一个新的子节点。</p>
<pre><code>appendChild(newnode)
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/5398fd020001ad4905890193.jpg" alt=""></p>
<pre><code>运行结果:
HTML
JavaScript
This is a new p
</code></pre><h4 id="11-插入节点insertBefore"><a href="#11-插入节点insertBefore" class="headerlink" title="11.插入节点insertBefore()"></a>11.插入节点insertBefore()</h4><p>insertBefore() 方法可在已有的子节点前插入一个新的子节点。</p>
<pre><code>insertBefore(newnode,node);
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/5395318100010c6806960431.jpg" alt=""></p>
<pre><code>运行结果:
This is a new p
JavaScript
HTML
</code></pre><h4 id="12-删除节点removeChild"><a href="#12-删除节点removeChild" class="headerlink" title="12.删除节点removeChild()"></a>12.删除节点removeChild()</h4><p>removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。</p>
<pre><code>nodeObject.removeChild(node)
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/5399744d000153a306060342.jpg" alt=""></p>
<pre><code>运行结果:
HTML
删除节点的内容: javascript
</code></pre><p><strong>注意:</strong> 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。<br>如果要完全删除对象，给 x 赋 null 值，代码如下:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/539975a800017c8e04790082.jpg" alt=""></p>
<h4 id="13-替换元素节点replaceChild"><a href="#13-替换元素节点replaceChild" class="headerlink" title="13.替换元素节点replaceChild()"></a>13.替换元素节点replaceChild()</h4><p>replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。</p>
<pre><code>node.replaceChild (newnode,oldnew ) 
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/539557d70001c3ee07190429.jpg" alt=""></p>
<pre><code>效果: 将文档中的 Java 改为 JavaScript。
</code></pre><p><strong>注意:</strong></p>
<ol>
<li>当 oldnode 被替换时，所有与之相关的属性内容都将被移除。 </li>
<li>newnode 必须先被建立。</li>
<li>只有父结点才能调用  replaceChild(newnode,oldnode).这个方法，所以，要想替换当前结点的内容或者属性，那么首先得获得父节点，才可以操作，这就是为什么 oldnode.parentNode.replaceChild(newnode,oldnode); 这句代码的写法。。</li>
</ol>
<h4 id="14-创建元素节点createElement"><a href="#14-创建元素节点createElement" class="headerlink" title="14.创建元素节点createElement"></a>14.创建元素节点createElement</h4><p>createElement()方法可创建元素节点。此方法可返回一个 Element 对象。</p>
<pre><code>document.createElement(tagName)
</code></pre><p>tagName：字符串值，这个字符串用来指明创建元素的类型。</p>
<p><strong>注意</strong>：要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。</p>
<h4 id="15-创建文本节点createTextNode"><a href="#15-创建文本节点createTextNode" class="headerlink" title="15.创建文本节点createTextNode"></a>15.创建文本节点createTextNode</h4><p>createTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。</p>
<pre><code>document.createTextNode(data)
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/53951c200001d32d07130554.jpg" alt=""></p>
<h4 id="16-浏览器窗口可视区域大小"><a href="#16-浏览器窗口可视区域大小" class="headerlink" title="16.浏览器窗口可视区域大小"></a>16.浏览器窗口可视区域大小</h4><p>获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法:</p>
<p>一、对于IE9+、Chrome、Firefox、Opera 以及 Safari：</p>
<p>•  window.innerHeight - 浏览器窗口的内部高度</p>
<p>•  window.innerWidth - 浏览器窗口的内部宽度</p>
<p>二、对于 Internet Explorer 8、7、6、5：</p>
<p>•  document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。</p>
<p>•  document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。</p>
<p>或者</p>
<p>Document对象的body属性对应HTML文档的<body>标签</body></p>
<p>•  document.body.clientHeight</p>
<p>•  document.body.clientWidth</p>
<pre><code>在不同浏览器都实用的 JavaScript 方案：
var w= document.documentElement.clientWidth
      || document.body.clientWidth;
var h= document.documentElement.clientHeight
      || document.body.clientHeight;
</code></pre><h4 id="17-网页尺寸scrollHeight"><a href="#17-网页尺寸scrollHeight" class="headerlink" title="17.网页尺寸scrollHeight"></a>17.网页尺寸scrollHeight</h4><p>scrollHeight和scrollWidth，获取网页内容高度和宽度。</p>
<p>一、针对IE、Opera:<br>scrollHeight 是网页内容实际高度，可以小于 clientHeight。</p>
<p>二、针对NS、FF:<br>scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。</p>
<p>三、浏览器兼容性</p>
<pre><code>var w=document.documentElement.scrollWidth
   || document.body.scrollWidth;
var h=document.documentElement.scrollHeight
   || document.body.scrollHeight;
</code></pre><p>注意:区分大小写<br>scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。</p>
<h4 id="18-网页尺寸offsetHeight"><a href="#18-网页尺寸offsetHeight" class="headerlink" title="18.网页尺寸offsetHeight"></a>18.网页尺寸offsetHeight</h4><p>offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。<br>一、值<br>offsetHeight = clientHeight + 滚动条 + 边框。<br>二、浏览器兼容性</p>
<pre><code>var w= document.documentElement.offsetWidth
    || document.body.offsetWidth;
var h= document.documentElement.offsetHeight
    || document.body.offsetHeight;
</code></pre><h4 id="19-网页卷去的距离与偏移量"><a href="#19-网页卷去的距离与偏移量" class="headerlink" title="19.网页卷去的距离与偏移量"></a>19.网页卷去的距离与偏移量</h4><p><img src="http://oncweb6po.bkt.clouddn.com/5347b2b10001e1a307520686.jpg" alt=""></p>
<p><strong>scrollLeft</strong>:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。</p>
<p><strong>scrollTop</strong>:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。</p>
<p><strong>offsetLeft</strong>:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。</p>
<p><strong>offsetTop</strong>:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。</p>
<p><strong>注意:</strong></p>
<ol>
<li>区分大小写</li>
<li>offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/px-em-rem单位/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/px-em-rem单位/" itemprop="url">px em rem单位</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:21:17+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.px</p>
<p>相对长度单位。像素px是相对于显示器屏幕分辨率而言的</p>
<blockquote>
<p>但是IE无法调整那些使用px作为单位的字体大小</p>
</blockquote>
<p>2.em</p>
<p>相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。（即相对父元素）</p>
<p>浏览器默认字体字体行高16px，1em=16px。在css中的body选择器中声明Font-size=62.5%，只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p>
<blockquote>
<p>会继承父级元素的字体大小</p>
</blockquote>
<p>3.rem</p>
<p>相对长度单位，但相对的只是HTML根元素。</p>
<pre><code>p {font-size:14px; font-size:.875rem;}
</code></pre><p>14px = 0.875em</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/person.jpg"
               alt="ZhangWei2222" />
          <p class="site-author-name" itemprop="name">ZhangWei2222</p>
           
              <p class="site-description motion-element" itemprop="description">Dream high</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">30</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangWei2222</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
