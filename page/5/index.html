<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="Dream high">
<meta property="og:type" content="website">
<meta property="og:title" content="ZhangWei2222">
<meta property="og:url" content="http://super-wei.xyz/page/5/index.html">
<meta property="og:site_name" content="ZhangWei2222">
<meta property="og:description" content="Dream high">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhangWei2222">
<meta name="twitter:description" content="Dream high">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://super-wei.xyz/page/5/"/>





  <title>ZhangWei2222</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhangWei2222</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/css媒体查询/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/css媒体查询/" itemprop="url">css媒体查询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:22:39+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h1><pre><code>&lt;!-- link元素中的CSS媒体查询 --&gt;
&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;

&lt;!-- 样式表中的CSS媒体查询 --&gt;
&lt;style&gt;
@media (max-width: 600px) {
  .facet_sidebar {
    display: none;
  }
}
&lt;/style&gt;
</code></pre><p>即使媒体查询返回false, <link> 标签指向的样式表也将会被下载(但是它们不会被应用)</p>
<h1 id="2-逻辑操作符"><a href="#2-逻辑操作符" class="headerlink" title="2.逻辑操作符"></a>2.逻辑操作符</h1><h3 id="1-and"><a href="#1-and" class="headerlink" title="(1).and"></a>(1).and</h3><pre><code>@media tv and (min-width: 700px) and (orientation: landscape) { ... }
</code></pre><p>现在，上面媒体查询仅在电视媒体上，可视区域不小于700像素宽度并且是横屏时有效。</p>
<h3 id="2-逗号分隔列表"><a href="#2-逗号分隔列表" class="headerlink" title="(2).逗号分隔列表"></a>(2).逗号分隔列表</h3><pre><code>@media (min-width: 700px), handheld and (orientation: landscape) { ... }
</code></pre><p>等同于 or 逻辑操作符。</p>
<h3 id="3-not"><a href="#3-not" class="headerlink" title="(3).not"></a>(3).not</h3><pre><code>@media not all and (monochrome) { ... }
@media not (all and (monochrome)) { ... }

@media not screen and (color), print and (color)
@media (not (screen and (color))), print and (color)
</code></pre><h3 id="4-only"><a href="#4-only" class="headerlink" title="(4).only"></a>(4).only</h3><p>only 关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt;
</code></pre><h1 id="3-媒体属性"><a href="#3-媒体属性" class="headerlink" title="3.媒体属性"></a>3.媒体属性</h1><h3 id="1-颜色（color）"><a href="#1-颜色（color）" class="headerlink" title="(1).颜色（color）"></a>(1).颜色（color）</h3><p>指定输出设备每个像素单元的比特值。如果设备不支持输出颜色，则该值为0。</p>
<pre><code>向所有能显示颜色的设备应用样式表：

@media all and (color) { ... }

向每个颜色单元至少有4个比特的设备应用样式表：

@media all and (min-color: 4) { ... }
</code></pre><h3 id="2-颜色索引（color-index）"><a href="#2-颜色索引（color-index）" class="headerlink" title="(2).颜色索引（color-index）"></a>(2).颜色索引（color-index）</h3><pre><code>向所有使用索引颜色的设备应用样式表，你可以这么做：

@media all and (color-index) { ... }
向所有使用至少256个索引颜色的设备应用样式表：

&lt;link rel=&quot;stylesheet&quot; media=&quot;all and (min-color-index: 256)&quot; href=&quot;http://foo.bar.com/stylesheet
</code></pre><h3 id="3-宽高比（aspect-ratio）"><a href="#3-宽高比（aspect-ratio）" class="headerlink" title="(3).宽高比（aspect-ratio）"></a>(3).宽高比（aspect-ratio）</h3><p>描述了输出设备目标显示区域的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例。</p>
<h3 id="4-设备宽高比（device-aspect-ratio）"><a href="#4-设备宽高比（device-aspect-ratio）" class="headerlink" title="(4).设备宽高比（device-aspect-ratio）"></a>(4).设备宽高比（device-aspect-ratio）</h3><p>描述了输出设备的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例。</p>
<pre><code>@media screen and (device-aspect-ratio: 16/9), screen and (device-aspect-ratio: 16/10) { ... } 宽高比或者16：9或者16：10。
</code></pre><h3 id="5-设备高度（device-height）"><a href="#5-设备高度（device-height）" class="headerlink" title="(5).设备高度（device-height）"></a>(5).设备高度（device-height）</h3><p>描述了输出设备的高度（整个屏幕或页的高度，而不是仅仅像文档窗口一样的渲染区域）。</p>
<pre><code>向显示在最大宽度800px的屏幕上的文档应用样式表，你可以这样做：

&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width: 799px)&quot; /&gt;
</code></pre><h3 id="6-设备宽度（device-width）"><a href="#6-设备宽度（device-width）" class="headerlink" title="(6).设备宽度（device-width）"></a>(6).设备宽度（device-width）</h3><p>描述了输出设备的宽度（整个屏幕或页的高度，而不是仅仅像文档窗口一样的渲染区域）。</p>
<h3 id="7-网格（grid）"><a href="#7-网格（grid）" class="headerlink" title="(7).网格（grid）"></a>(7).网格（grid）</h3><p>是否接受 min/max 前缀： 否</p>
<p>判断输出设备是网格设备还是位图设备。如果设备是基于网格的（例如电传打字机终端或只能显示一种字形的电话），该值为1，否则为0。</p>
<h3 id="8-高度（height）"><a href="#8-高度（height）" class="headerlink" title="(8).高度（height）"></a>(8).高度（height）</h3><p>height 媒体属性描述了输出设备渲染区域（如可视区域的高度或打印机纸盒的高度）的高度。</p>
<h3 id="9-黑白（monochrome）"><a href="#9-黑白（monochrome）" class="headerlink" title="(9).黑白（monochrome）"></a>(9).黑白（monochrome）</h3><p>指定了一个黑白（灰度）设备每个像素的比特数。如果不是黑白设备，值为0。</p>
<h3 id="10-方向（orientation）"><a href="#10-方向（orientation）" class="headerlink" title="(10).方向（orientation）"></a>(10).方向（orientation）</h3><p>值：landscape | portrait</p>
<p>指定了设备处于横屏（宽度大于高度）模式还是竖屏（高度大于宽度）模式。</p>
<pre><code>向竖屏设备应用样式表：

@media all and (orientation: portrait) { ... }
</code></pre><h3 id="11-分辨率（resolution）"><a href="#11-分辨率（resolution）" class="headerlink" title="(11).分辨率（resolution）"></a>(11).分辨率（resolution）</h3><p>指定输出设备的分辨率（像素密度）。分辨率可以用每英寸（dpi）或每厘米（dpcm）的点数来表示。</p>
<h3 id="12-扫描（scan）"><a href="#12-扫描（scan）" class="headerlink" title="(12).扫描（scan）"></a>(12).扫描（scan）</h3><p>值： progressive | interlace</p>
<pre><code>向以顺序方式扫描的电视机上应用样式表：

@media tv and (scan: progressive) { ... }
</code></pre><h3 id="13-宽度（width）"><a href="#13-宽度（width）" class="headerlink" title="(13).宽度（width）"></a>(13).宽度（width）</h3><p>width 媒体属性描述了输出设备渲染区域（如可视区域的宽度或打印机纸盒的宽度）的宽度。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/javascript运行机制详解：event-loop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/javascript运行机制详解：event-loop/" itemprop="url">javascript运行机制详解：event loop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:22:05+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、为什么JavaScript是单线程？"><a href="#一、为什么JavaScript是单线程？" class="headerlink" title="一、为什么JavaScript是单线程？"></a>一、为什么JavaScript是单线程？</h1><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<h1 id="二、任务队列"><a href="#二、任务队列" class="headerlink" title="二、任务队列"></a>二、任务队列</h1><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
<p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p>
<p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p>
<blockquote>
<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>
<p>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>
<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br><img src="http://oncweb6po.bkt.clouddn.com/bg2014100801.jpg" alt=""><br>（4）主线程不断重复上面的第三步。</p>
</blockquote>
<h1 id="三、事件和回调函数"><a href="#三、事件和回调函数" class="headerlink" title="三、事件和回调函数"></a>三、事件和回调函数</h1><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。</p>
<p>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。</p>
<p>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p>
<p>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p>
<h1 id="四、Event-Loop"><a href="#四、Event-Loop" class="headerlink" title="四、Event Loop"></a>四、Event Loop</h1><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/bg2014100802.png" alt=""></p>
<p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。</p>
<p>执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。</p>
<pre><code>var req = new XMLHttpRequest();
req.open(&apos;GET&apos;, url);    
req.onload = function (){};    
req.onerror = function (){};    
req.send();
</code></pre><p>上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。</p>
<pre><code>var req = new XMLHttpRequest();
req.open(&apos;GET&apos;, url);
req.send();
req.onload = function (){};    
req.onerror = function (){};   
</code></pre><p>也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。</p>
<h1 id="五、定时器"><a href="#五、定时器" class="headerlink" title="五、定时器"></a>五、定时器</h1><p>除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。</p>
<p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。</p>
<p>setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。</p>
<pre><code>console.log(1);
setTimeout(function(){console.log(2);},1000);
console.log(3);
</code></pre><p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。</p>
<p>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p>
<pre><code>setTimeout(function(){console.log(1);}, 0);
console.log(2);
</code></pre><p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。</p>
<p>总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>
<p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。</p>
<p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/js进阶知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/js进阶知识/" itemprop="url">js进阶知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:21:36+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、变量名"><a href="#一、变量名" class="headerlink" title="一、变量名"></a>一、变量名</h1><h3 id="1-命名"><a href="#1-命名" class="headerlink" title="1.命名"></a>1.命名</h3><p>1.必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字。</p>
<p>2.变量名区分大小写，如:A与a是两个不同变量。</p>
<p>3.不允许使用JavaScript关键字和保留字做变量名。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/529c07c000014f5103080447.jpg" alt=""></p>
<h3 id="2-声明"><a href="#2-声明" class="headerlink" title="2.声明"></a>2.声明</h3><pre><code>var mynum ; //声明一个变量mynum
var num1,mun2 ; //声明一个变量num1
</code></pre><h3 id="3-变量赋值"><a href="#3-变量赋值" class="headerlink" title="3.变量赋值"></a>3.变量赋值</h3><p>= 是赋值，==是等于号</p>
<pre><code>var num1 = 123;       // 123是数值
var num2 = &quot;一二三&quot;;    //&quot;一二三&quot;是字符串
var num3=true;    //布尔值true（真），false(假)
</code></pre><h1 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h1><h3 id="1-二维数组"><a href="#1-二维数组" class="headerlink" title="1.二维数组"></a>1.二维数组</h3><pre><code>var myarr=new Array();  //先声明一维 
for(var i=0;i&lt;2;i++){   //一维长度为2
   myarr[i]=new Array();  //再声明二维 
   for(var j=0;j&lt;3;j++){   //二维长度为3
   myarr[i][j]=i+j;   // 赋值，每个数组元素的值为i+j
   }
 }
</code></pre><hr>
<pre><code>var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]]
</code></pre><h1 id="三、鼠标事件"><a href="#三、鼠标事件" class="headerlink" title="三、鼠标事件"></a>三、鼠标事件</h1><p><img src="http://oncweb6po.bkt.clouddn.com/53e198540001b66404860353.jpg" alt=""></p>
<h3 id="1-onfocus（获得焦点事件）"><a href="#1-onfocus（获得焦点事件）" class="headerlink" title="1.onfocus（获得焦点事件）"></a>1.onfocus（获得焦点事件）</h3><p>当一个文本框获得焦点时，它里面的文本就像“好123”网站上的百度搜索输入框那样全部被自动选中，这样的操作可以利用onfocus来实现。 </p>
<p>以下的文本框，当鼠标指针移过去时，里面的文字全部被选中： </p>
<p>请输入网址 </p>
<p>这是怎么做的呢？看以下代码及解释： </p>
<pre><code>&lt;input type=&quot;text&quot;name=&quot;url&quot; value=&quot;http://www.gxblk.com&quot; size=&quot;30&quot;onmousemove=&quot;this.focus();this.select();&quot;&gt;
</code></pre><blockquote>
<p>代码里，input标签内嵌入了onmousemove（鼠标指针经过）事件的JS语句，其等号后面的this.focus()意为其自身获得焦点；获得焦点的标志是该文本框内将出现输入光标，但要让其内的文字全部被选中，我们还得用上this.select()语句，它的意思就是选中全部文本框里的文字。</p>
</blockquote>
<h3 id="2-onblur（失去焦点事件）"><a href="#2-onblur（失去焦点事件）" class="headerlink" title="2.onblur（失去焦点事件）"></a>2.onblur（失去焦点事件）</h3><p>我们经常会检测文本框是否已经被正确输入，检测工作通常在用户点击了提交按钮之后进行，事实上，利用控件失去焦点的时候，我们就可以实时进行这个检测工作，这样的话，onblur事件就派上用场了。 </p>
<p>以下例子有四个文本框，如果还没有任何单击它们当中的任意一个的操作，那么什么事情也不会发生，但是，当你单击了其中的任何一个使其拥有了焦点（输入光标在里面），如果什么都没有输入并且单击了别的地方令其失去焦点，就会弹出一个警告，试试看 </p>
<p>姓名 </p>
<p>性别 </p>
<p>年龄 </p>
<p>住址 </p>
<p>以下是代码和解释： </p>
<p>表单代码 </p>
<pre><code>&lt;form name=&quot;blur_test&quot;&gt; 
&lt;p&gt;姓名 &lt;input type=&quot;text&quot; name=&quot;name&quot;value=&quot;&quot; size=&quot;30&quot;onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 
性别 &lt;inputtype=&quot;text&quot; name=&quot;sex&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 
年龄 &lt;inputtype=&quot;text&quot; name=&quot;age&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 
住址 &lt;inputtype=&quot;text&quot; name=&quot;addr&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;/p&gt; 
&lt;/form&gt;

&lt;scriptlanguage=&quot;javascript&quot;&gt; 
function chkvalue(txt) { 
if(txt.value==&quot;&quot;) alert(&quot;文本框里必须填写内容!&quot;); 
} 
&lt;/script&gt;
</code></pre><blockquote>
<p>表单代码里，每一个方框框的代码都嵌入一个onblur JS语句，它们都调用后面的JS代码中的自定义函数chkvalue(this)，意思是，当文本框失去焦点时就调用chkvalue()函数；这chkvalue()函数检测文本框是否为空，如果是就弹出警告窗口。该函数有一个参数（txt），对应于前面文本框调用该函数的参数（this）即自身。 </p>
</blockquote>
<h3 id="3-onselect事件"><a href="#3-onselect事件" class="headerlink" title="3.onselect事件"></a>3.onselect事件</h3><p>选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。</p>
<h3 id="4-文本框内容改变事件（onchange）"><a href="#4-文本框内容改变事件（onchange）" class="headerlink" title="4.文本框内容改变事件（onchange）"></a>4.文本框内容改变事件（onchange）</h3><p>通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。</p>
<h3 id="5-加载事件（onload）"><a href="#5-加载事件（onload）" class="headerlink" title="5.加载事件（onload）"></a>5.加载事件（onload）</h3><p>事件会在页面加载完成后，立即发生，同时执行被调用的程序。</p>
<p>注意：</p>
<p>1、加载页面时，触发onload事件，事件写在<body>标签内。</body></p>
<p>2、此节的加载页面，可理解为打开一个新页面时。</p>
<p>如下代码,当加载一个新页面时，弹出对话框“加载中，请稍等…”。</p>
<blockquote>
<p>支持的标签：<body\>, <frame\>, <frameset\>, <iframe\>, <img\>, <input type="image" \="">, <link\>, <script\> ,<style\>，写在<body\>内监听页面加载，正如写在<img\>监听图像加载。</img\></body\></style\></script\></link\></img\></iframe\></frameset\></frame\></body\></p>
</blockquote>
<h3 id="6-卸载事件（onunload）"><a href="#6-卸载事件（onunload）" class="headerlink" title="6.卸载事件（onunload）"></a>6.卸载事件（onunload）</h3><p>当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。</p>
<p><strong>注意：不同浏览器对onunload事件支持不同。</strong></p>
<p>如下代码,当退出页面时，弹出对话框“您确定离开该网页吗？”。</p>
<h1 id="四、-JavaScript内置对象"><a href="#四、-JavaScript内置对象" class="headerlink" title="四、 JavaScript内置对象"></a>四、 JavaScript内置对象</h1><h3 id="1-Date-日期对象"><a href="#1-Date-日期对象" class="headerlink" title="1.Date 日期对象"></a>1.Date 日期对象</h3><p>定义一个时间对象 :</p>
<pre><code>var Udate=new Date(); 
</code></pre><p>使 Udate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。</p>
<p>访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;”</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/555c650d0001ae7b04180297.jpg" alt=""></p>
<h4 id="1-返回星期方法"><a href="#1-返回星期方法" class="headerlink" title="(1).返回星期方法"></a>(1).返回星期方法</h4><p>getDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下:</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var mydate=new Date();//定义日期对象
  var weekday=[&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;];
//定义数组对象,给每个数组项赋值
  var mynum=mydate.getDay();//返回值存储在变量mynum中
  document.write(mydate.getDay());//输出getDay()获取值
  document.write(&quot;今天是：&quot;+ weekday[mynum]);//输出星期几
&lt;/script&gt;
</code></pre><h4 id="2-返回-设置时间方法"><a href="#2-返回-设置时间方法" class="headerlink" title="(2).返回/设置时间方法"></a>(2).返回/设置时间方法</h4><p>get/setTime() 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。</p>
<h3 id="2-String字符串对象"><a href="#2-String字符串对象" class="headerlink" title="2.String字符串对象"></a>2.String字符串对象</h3><h4 id="1-toUpperCase-，toLowerCase"><a href="#1-toUpperCase-，toLowerCase" class="headerlink" title="(1).toUpperCase()，toLowerCase()"></a>(1).toUpperCase()，toLowerCase()</h4><p>使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写,另一个反之</p>
<h4 id="2-charAt"><a href="#2-charAt" class="headerlink" title="(2).charAt()"></a>(2).charAt()</h4><pre><code>stringObject.charAt(index)
</code></pre><p>可返回指定位置的字符。返回的字符是长度为 1 的字符串。</p>
<h4 id="3-字符串分割split"><a href="#3-字符串分割split" class="headerlink" title="(3).字符串分割split()"></a>(3).字符串分割split()</h4><p>split() 方法将字符串分割为字符串数组，并返回此数组。</p>
<pre><code>stringObject.split(separator,limit)
</code></pre><p><strong>注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。</strong></p>
<pre><code>var mystr = &quot;www.imooc.com&quot;;
document.write(mystr.split(&quot;.&quot;)+&quot;&lt;br&gt;&quot;);
document.write(mystr.split(&quot;.&quot;, 2)+&quot;&lt;br&gt;&quot;);

www,imooc,com
www,imooc

document.write(mystr.split(&quot;&quot;)+&quot;&lt;br&gt;&quot;);
document.write(mystr.split(&quot;&quot;, 5));

w,w,w,.,i,m,o,o,c,.,c,o,m
w,w,w,.,i
</code></pre><h4 id="4-提取字符串substring"><a href="#4-提取字符串substring" class="headerlink" title="(4).提取字符串substring()"></a>(4).提取字符串substring()</h4><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符</p>
<pre><code>stringObject.substring(startPos,stopPos) 
</code></pre><p><strong>注意：</strong></p>
<ol>
<li>返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。</li>
<li>如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。</li>
<li>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。</li>
</ol>
<h4 id="5-提取指定数目的字符substr"><a href="#5-提取指定数目的字符substr" class="headerlink" title="(5).提取指定数目的字符substr()"></a>(5).提取指定数目的字符substr()</h4><p>substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。</p>
<pre><code>stringObject.substr(startPos,length)
</code></pre><p><strong>注意：</strong></p>
<p>如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。<br>如果startPos为负数且绝对值大于字符串长度，startPos为0。</p>
<blockquote>
<p>string.substring( 起点 ， 终点 )</p>
<p>string.substr( 起点 ，长度 )</p>
</blockquote>
<h3 id="3-Math对象"><a href="#3-Math对象" class="headerlink" title="3.Math对象"></a>3.Math对象</h3><p>Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。</p>
<p>Math 对象属性</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/532fe7cf0001e7b505170269.jpg" alt=""></p>
<p>Math 对象方法</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/532fe841000174db05160622.jpg" alt=""></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var mypi=Math.PI; 
  var myabs=Math.abs(-15);
  document.write(mypi);
  document.write(myabs);
&lt;/script&gt;

3.141592653589793
15
</code></pre><h4 id="1-向上取整ceil"><a href="#1-向上取整ceil" class="headerlink" title="(1).向上取整ceil()"></a>(1).向上取整ceil()</h4><pre><code>Math.ceil(x)
</code></pre><p>ceil() 方法可对一个数进行向上取整。x必须是一个数值</p>
<p><strong>注意：</strong>它返回的是大于或等于x，并且与x最接近的整数。</p>
<h4 id="2-向下取整floor"><a href="#2-向下取整floor" class="headerlink" title="(2).向下取整floor()"></a>(2).向下取整floor()</h4><pre><code>Math.floor(x)
</code></pre><p>floor() 方法可对一个数进行向下取整。</p>
<p><strong>注意：</strong>返回的是小于或等于x，并且与 x 最接近的整数。</p>
<h4 id="3-四舍五入round"><a href="#3-四舍五入round" class="headerlink" title="(3).四舍五入round()"></a>(3).四舍五入round()</h4><pre><code>Math.round(x)
</code></pre><p>round() 方法可把一个数字四舍五入为最接近的整数。</p>
<p>注意：</p>
<ol>
<li>返回与 x 最接近的整数。</li>
<li>对于 0.5，该方法将进行上舍入。(5.5 将舍入为 6)</li>
<li>如果 x 与两侧整数同等接近，则结果接近 +∞方向的数字值 。(如 -5.5 将舍入为 -5; -5.52 将舍入为 -6)</li>
</ol>
<h4 id="4-随机数-random"><a href="#4-随机数-random" class="headerlink" title="(4).随机数 random()"></a>(4).随机数 random()</h4><pre><code>Math.random();
</code></pre><p>random() 方法可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。</p>
<p><strong>注意：</strong>返回一个大于或等于 0 但小于 1 的符号为正的数字值。</p>
<h3 id="4-Array-数组对象"><a href="#4-Array-数组对象" class="headerlink" title="4.Array 数组对象"></a>4.Array 数组对象</h3><p><img src="http://oncweb6po.bkt.clouddn.com/533295ab0001dead05190599.jpg" alt=""></p>
<h4 id="1-数组连接concat"><a href="#1-数组连接concat" class="headerlink" title="(1).数组连接concat()"></a>(1).数组连接concat()</h4><p>concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var mya = new Array(3);
  mya[0] = &quot;1&quot;;
  mya[1] = &quot;2&quot;;
  mya[2] = &quot;3&quot;;
  document.write(mya.concat(4,5)+&quot;&lt;br&gt;&quot;);
  document.write(mya); 
&lt;/script&gt;

1,2,3,4,5
1,2,3
</code></pre><h4 id="2-指定分隔符连接数组元素join"><a href="#2-指定分隔符连接数组元素join" class="headerlink" title="(2).指定分隔符连接数组元素join()"></a>(2).指定分隔符连接数组元素join()</h4><p>join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。不改变原来数组</p>
<h4 id="3-颠倒数组元素顺序reverse"><a href="#3-颠倒数组元素顺序reverse" class="headerlink" title="(3).颠倒数组元素顺序reverse()"></a>(3).颠倒数组元素顺序reverse()</h4><p>该方法会改变原来的数组，而不会创建新的数组。</p>
<h4 id="4-选定元素slice"><a href="#4-选定元素slice" class="headerlink" title="(4).选定元素slice()"></a>(4).选定元素slice()</h4><pre><code>arrayObject.slice(start,end)
</code></pre><p><strong>注意：</strong></p>
<ol>
<li>可使用负值从数组的尾部选取元素。<br>2.如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。</li>
<li>String.slice() 与 Array.slice() 相似。</li>
<li>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</li>
<li>该方法并不会修改数组，而是返回一个子数组</li>
</ol>
<h4 id="5-数组排序sort"><a href="#5-数组排序sort" class="headerlink" title="(5).数组排序sort()"></a>(5).数组排序sort()</h4><pre><code>arrayObject.sort(方法函数)
</code></pre><p><strong>注意</strong></p>
<p>1.如果不指定&lt;方法函数&gt;，则按unicode码顺序排列。</p>
<p>2.如果指定&lt;方法函数&gt;，则按&lt;方法函数&gt;所指定的排序方法排序。</p>
<pre><code>排序函数：

&lt;script type=&quot;text/javascript&quot;&gt;
  function sortNum(a,b) {
  return a - b;
 //升序，如降序，把“a - b”该成“b - a”
}
 var myarr = new Array(&quot;80&quot;,&quot;16&quot;,&quot;50&quot;,&quot;6&quot;,&quot;100&quot;,&quot;1&quot;);
  document.write(myarr + &quot;&lt;br&gt;&quot;);
  document.write(myarr.sort(sortNum));
&lt;/script&gt;


80,16,50,6,100,1
1,6,16,50,80,100
</code></pre><h1 id="五、浏览器对象"><a href="#五、浏览器对象" class="headerlink" title="五、浏览器对象"></a>五、浏览器对象</h1><p>window对象是BOM的核心，window对象指当前的浏览器窗口。</p>
<p>window对象方法:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/535483720001a54506670563.jpg" alt=""></p>
<h3 id="1-计时器"><a href="#1-计时器" class="headerlink" title="1.计时器"></a>1.计时器</h3><p>在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。<br>计时器类型：</p>
<p>一次性计时器：仅在指定的延迟时间之后触发一次。</p>
<p>间隔性触发计时器：每隔一定的时间间隔就触发一次。</p>
<p>计时器方法：</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/56976e1700014fc504090143.jpg" alt=""></p>
<h4 id="1-setInterval"><a href="#1-setInterval" class="headerlink" title="(1).setInterval()"></a>(1).setInterval()</h4><p>在执行时,从载入页面后每隔指定的时间执行代码。</p>
<pre><code>setInterval(代码,交互时间);
</code></pre><p>参数说明：</p>
<ol>
<li>代码：要调用的函数或要执行的代码串。</li>
<li>交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。</li>
</ol>
<p>返回值:<br>一个可以传递给 clearInterval() 从而取消对”代码”的周期性执行的值。</p>
<pre><code>调用函数格式(假设有一个clock()函数):
setInterval(&quot;clock()&quot;,1000)
或
setInterval(clock,1000)
</code></pre><p>我们设置一个计时器，每隔100毫秒调用clock()函数，并将时间显示出来，代码如下:</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
&lt;title&gt;计时器&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var int=setInterval(clock, 100)
  function clock(){
    var time=new Date();
    document.getElementById(&quot;clock&quot;).value = time;
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;clock&quot; size=&quot;50&quot;  /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="2-取消计时器clearInterval"><a href="#2-取消计时器clearInterval" class="headerlink" title="(2).取消计时器clearInterval()"></a>(2).取消计时器clearInterval()</h3><p>clearInterval() 方法可取消由 setInterval() 设置的交互时间。</p>
<pre><code>clearInterval(id_of_setInterval)
</code></pre><p>参数说明:</p>
<p>id_of_setInterval：由 setInterval() 返回的 ID 值。</p>
<p>每隔 100 毫秒调用 clock() 函数,并显示时间。当点击按钮时，停止时间,代码如下:</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
&lt;title&gt;计时器&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
   function clock(){
      var time=new Date();                     
      document.getElementById(&quot;clock&quot;).value = time;
   }
// 每隔100毫秒调用clock函数，并将返回值赋值给i
     var i=setInterval(&quot;clock()&quot;,100);
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;clock&quot; size=&quot;50&quot;  /&gt;
    &lt;input type=&quot;button&quot; value=&quot;Stop&quot; onclick=&quot;clearInterval(i)&quot;  /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="3-计时器setTimeout"><a href="#3-计时器setTimeout" class="headerlink" title="(3).计时器setTimeout()"></a>(3).计时器setTimeout()</h3><p>setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次。</p>
<pre><code>setTimeout(代码,延迟时间);
</code></pre><p>参数说明：</p>
<ol>
<li>要调用的函数或要执行的代码串。</li>
<li>延时时间：在执行代码前需等待的时间，以毫秒为单位（1s=1000ms)。</li>
</ol>
<p>要创建一个运行于无穷循环中的计数器，我们需要编写一个函数来调用其自身。在下面的代码，当按钮被点击后，输入域便从0开始计数。</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var num=0;
function numCount(){
 document.getElementById(&apos;txt&apos;).value=num;
 num=num+1;
 setTimeout(&quot;numCount()&quot;,1000);
 }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form&gt;
&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;
&lt;input type=&quot;button&quot; value=&quot;Start&quot; onClick=&quot;numCount()&quot; /&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="4-取消计时器clearTimeout"><a href="#4-取消计时器clearTimeout" class="headerlink" title="(4).取消计时器clearTimeout()"></a>(4).取消计时器clearTimeout()</h3><p>setTimeout()和clearTimeout()一起使用，停止计时器。</p>
<pre><code>clearTimeout(id_of_setTimeout)
</code></pre><hr>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var num=0,i;
  function timedCount(){
    document.getElementById(&apos;txt&apos;).value=num;
    num=num+1;
    i=setTimeout(timedCount,1000);
  }
    setTimeout(timedCount,1000);
  function stopCount(){
    clearTimeout(i);
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form&gt;
    &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;Stop&quot; onClick=&quot;stopCount()&quot;&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="2-History对象"><a href="#2-History对象" class="headerlink" title="2.History对象"></a>2.History对象</h3><p>history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。</p>
<p><strong>注意:</strong></p>
<p>从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。</p>
<p>window.history.[属性|方法]（window可以省略。）</p>
<p>History 对象属性</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/53548c030001759e05840068.jpg" alt=""></p>
<p>History 对象方法</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/53548c200001228206210123.jpg" alt=""></p>
<h4 id="1-返回前一个浏览的页面"><a href="#1-返回前一个浏览的页面" class="headerlink" title="(1).返回前一个浏览的页面"></a>(1).返回前一个浏览的页面</h4><p>back()方法，加载 history 列表中的前一个 URL。</p>
<pre><code>window.history.back();
</code></pre><p>比如，返回前一个浏览的页面，代码如下：<br>window.history.back();</p>
<p>注意：等同于点击浏览器的倒退按钮。</p>
<p>back()相当于go(-1),代码如下:</p>
<pre><code>window.history.go(-1);
</code></pre><h4 id="2-返回下一个浏览的页面"><a href="#2-返回下一个浏览的页面" class="headerlink" title="(2).返回下一个浏览的页面"></a>(2).返回下一个浏览的页面</h4><p>forward()方法，加载 history 列表中的下一个 URL。</p>
<p>如果倒退之后，再想回到倒退之前浏览的页面，则可以使用forward()方法,代码如下:</p>
<pre><code>window.history.forward();
</code></pre><p>注意：等价点击前进按钮。</p>
<p>forward()相当于go(1),代码如下:</p>
<pre><code>window.history.go(1);
</code></pre><h4 id="3-返回浏览历史中的其他页面"><a href="#3-返回浏览历史中的其他页面" class="headerlink" title="(3).返回浏览历史中的其他页面"></a>(3).返回浏览历史中的其他页面</h4><p>go()方法，根据当前所处的页面，加载 history 列表中的某个具体的页面。</p>
<pre><code>window.history.go(number);

go(1)等价forward()
go(0)等价当前页面
go(-1)等价back()
</code></pre><h3 id="3-Location对象"><a href="#3-Location对象" class="headerlink" title="3.Location对象"></a>3.Location对象</h3><p>location用于获取或设置窗体的URL，并且可以用于解析URL。</p>
<pre><code>location.[属性|方法]
</code></pre><p>location对象属性图示:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/53605c5a0001b26909900216.jpg" alt=""></p>
<p>location 对象属性：</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/5354b1d00001c4ec06220271.jpg" alt=""></p>
<p>location 对象方法:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/5354b1eb00016a2405170126.jpg" alt=""></p>
<h3 id="4-Navigator对象"><a href="#4-Navigator对象" class="headerlink" title="4.Navigator对象"></a>4.Navigator对象</h3><p>Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。</p>
<p>对象属性:<br><img src="http://oncweb6po.bkt.clouddn.com/5354cff70001428b06880190.jpg" alt=""></p>
<h3 id="5-screen对象"><a href="#5-screen对象" class="headerlink" title="5.screen对象"></a>5.screen对象</h3><p>screen对象用于获取用户的屏幕信息。</p>
<pre><code>window.screen.属性
</code></pre><p>对象属性:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/5354d2810001a47706210213.jpg" alt=""></p>
<h4 id="1-屏幕分辨率的高和宽"><a href="#1-屏幕分辨率的高和宽" class="headerlink" title="(1).屏幕分辨率的高和宽"></a>(1).屏幕分辨率的高和宽</h4><p>window.screen 对象包含有关用户屏幕的信息。</p>
<ol>
<li>screen.height 返回屏幕分辨率的高</li>
<li>screen.width 返回屏幕分辨率的宽</li>
</ol>
<p><strong>注意:</strong></p>
<p>1.单位以像素计。</p>
<ol>
<li>window.screen 对象在编写时可以不使用 window 这个前缀。</li>
</ol>
<h4 id="2-屏幕可用高和宽度"><a href="#2-屏幕可用高和宽度" class="headerlink" title="(2).屏幕可用高和宽度"></a>(2).屏幕可用高和宽度</h4><ol>
<li><p>screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如任务栏。</p>
</li>
<li><p>screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如任务栏。</p>
</li>
</ol>
<p><strong>注意:</strong><br>不同系统的任务栏默认高度不一样，及任务栏的位置可在屏幕上下左右任何位置，所以有可能可用宽度和高度不一样。</p>
<h1 id="六、DOM"><a href="#六、DOM" class="headerlink" title="六、DOM"></a>六、DOM</h1><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p>
<p>HTML文档可以说由节点构成的集合，DOM节点有:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170719160326.png" alt=""></p>
<ol>
<li>元素节点：上图中<html>、<body>、<p>等都是元素节点，即标签。</p></body></html></li>
<li><p>文本节点:向用户展示的内容，如<li\>…</li\>中的JavaScript、DOM、CSS等文本。</p>
</li>
<li><p>属性节点:元素属性，如<a\>标签的链接属性href=”<a href="http://www.imooc.com&quot;。" target="_blank" rel="external">http://www.imooc.com&quot;。</a></a\></p>
</li>
</ol>
<p>节点属性:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/5375c953000117ee05240129.jpg" alt=""></p>
<p>遍历节点树:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/53f17a6400017d2905230219.jpg" alt=""></p>
<p>DOM操作:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/538d29da000152db05360278.jpg" alt=""></p>
<p>注意:前两个是document方法。</p>
<h4 id="1-getElementsByName-方法"><a href="#1-getElementsByName-方法" class="headerlink" title="(1).getElementsByName()方法"></a>(1).getElementsByName()方法</h4><p><strong>注意:</strong></p>
<ol>
<li>因为文档中的 name 属性可能不唯一，所有 getElementsByName() 方法返回的是元素的数组，而不是一个元素。</li>
<li>和数组类似也有length属性，可以和访问数组一样的方法来访问，从0开始。</li>
</ol>
<h4 id="2-getElementsByTagName-方法"><a href="#2-getElementsByTagName-方法" class="headerlink" title="(2).getElementsByTagName()方法"></a>(2).getElementsByTagName()方法</h4><p>返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。</p>
<p><strong>说明:</strong></p>
<ol>
<li>Tagname是标签的名称，如p、a、img等标签名。</li>
<li>和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。</li>
</ol>
<h4 id="3-getAttribute-方法"><a href="#3-getAttribute-方法" class="headerlink" title="(3).getAttribute()方法"></a>(3).getAttribute()方法</h4><p>通过元素节点的属性名称获取属性的值。</p>
<pre><code>elementNode.getAttribute(name)
</code></pre><h4 id="4-setAttribute"><a href="#4-setAttribute" class="headerlink" title="(4).setAttribute()"></a>(4).setAttribute()</h4><p>setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。</p>
<pre><code>elementNode.setAttribute(name,value)
</code></pre><p><strong>说明：</strong></p>
<p>1.name: 要设置的属性名。</p>
<p>2.value: 要设置的属性值。</p>
<p><strong>注意：</strong></p>
<p>1.把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。</p>
<p>2.类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。</p>
<h4 id="5-节点属性"><a href="#5-节点属性" class="headerlink" title="5.节点属性"></a>5.节点属性</h4><p>在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：</p>
<ol>
<li>nodeName : 节点的名称</li>
<li>nodeValue ：节点的值</li>
<li>nodeType ：节点的类型</li>
</ol>
<p>一、nodeName 属性: 节点的名称，是只读的。</p>
<ol>
<li>元素节点的 nodeName 与标签名相同</li>
<li>属性节点的 nodeName 是属性的名称</li>
<li>文本节点的 nodeName 永远是 #text</li>
<li>文档节点的 nodeName 永远是 #document</li>
</ol>
<p>二、nodeValue 属性：节点的值</p>
<ol>
<li>元素节点的 nodeValue 是 undefined 或 null</li>
<li>文本节点的 nodeValue 是文本自身</li>
<li>属性节点的 nodeValue 是属性的值</li>
</ol>
<p>三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型:</p>
<p>元素类型    节点类型</p>
<ul>
<li>元素          1</li>
</ul>
<ul>
<li>属性          2</li>
</ul>
<ul>
<li>文本          3</li>
</ul>
<ul>
<li>注释          8</li>
</ul>
<ul>
<li>文档          9</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170719161333.png" alt=""></p>
<h4 id="6-访问子节点childNodes"><a href="#6-访问子节点childNodes" class="headerlink" title="6.访问子节点childNodes"></a>6.访问子节点childNodes</h4><p>访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，他具有length属性。</p>
<pre><code>elementNode.childNodes
</code></pre><p><strong>注意：</strong><br>如果选定的节点没有子节点，则该属性返回不包含节点的 NodeList。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/538405fa00010e6c05630357.jpg" alt=""></p>
<pre><code>运行结果:
IE:
  UL子节点个数:3
  节点类型:1
其它浏览器:
   UL子节点个数:7
   节点类型:3
</code></pre><p><strong>注意:</strong></p>
<ol>
<li>IE全系列、firefox、chrome、opera、safari兼容问题</li>
<li>节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点，所以IE是3，其它浏览器是7，如下图所示:</li>
</ol>
<p><img src="http://oncweb6po.bkt.clouddn.com/538d2b8a000163e303430127.jpg" alt=""></p>
<p>如果把代码改成这样:</p>
<p><ul\><li\>javascript</li\><li\>jQuery</li\><li\>PHP</li\></ul\></p>
<pre><code>运行结果:（IE和其它浏览器结果是一样的）
  UL子节点个数:3
  节点类型:1
</code></pre><h4 id="7-访问子节点的第一和最后项"><a href="#7-访问子节点的第一和最后项" class="headerlink" title="7.访问子节点的第一和最后项"></a>7.访问子节点的第一和最后项</h4><p>一、firstChild 属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。</p>
<pre><code>node.firstChild
</code></pre><p>说明：与elementNode.childNodes[0]是同样的效果。 </p>
<p>二、 lastChild 属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。</p>
<pre><code>node.lastChild
</code></pre><p>说明：与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 </p>
<h4 id="8-访问父节点parentNode"><a href="#8-访问父节点parentNode" class="headerlink" title="8.访问父节点parentNode"></a>8.访问父节点parentNode</h4><p>获取指定节点的父节点</p>
<pre><code>elementNode.parentNode
</code></pre><p><strong>注意</strong>:父节点只能有一个。</p>
<h4 id="9-访问兄弟节点"><a href="#9-访问兄弟节点" class="headerlink" title="9.访问兄弟节点"></a>9.访问兄弟节点</h4><ol>
<li><p>nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。</p>
<p> nodeObject.nextSibling</p>
</li>
</ol>
<p>说明：如果无此节点，则该属性返回 null。</p>
<ol>
<li><p>previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。</p>
<p> nodeObject.previousSibling  </p>
</li>
</ol>
<p>说明：如果无此节点，则该属性返回 null。</p>
<p>注意: 两个属性获取的是节点。Internet Explorer 会忽略节点间生成的空白文本节点（例如，换行符号），而其它浏览器不会忽略。</p>
<h4 id="10-插入节点appendChild"><a href="#10-插入节点appendChild" class="headerlink" title="10.插入节点appendChild()"></a>10.插入节点appendChild()</h4><p>在指定节点的最后一个子节点列表之后添加一个新的子节点。</p>
<pre><code>appendChild(newnode)
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/5398fd020001ad4905890193.jpg" alt=""></p>
<pre><code>运行结果:
HTML
JavaScript
This is a new p
</code></pre><h4 id="11-插入节点insertBefore"><a href="#11-插入节点insertBefore" class="headerlink" title="11.插入节点insertBefore()"></a>11.插入节点insertBefore()</h4><p>insertBefore() 方法可在已有的子节点前插入一个新的子节点。</p>
<pre><code>insertBefore(newnode,node);
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/5395318100010c6806960431.jpg" alt=""></p>
<pre><code>运行结果:
This is a new p
JavaScript
HTML
</code></pre><h4 id="12-删除节点removeChild"><a href="#12-删除节点removeChild" class="headerlink" title="12.删除节点removeChild()"></a>12.删除节点removeChild()</h4><p>removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。</p>
<pre><code>nodeObject.removeChild(node)
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/5399744d000153a306060342.jpg" alt=""></p>
<pre><code>运行结果:
HTML
删除节点的内容: javascript
</code></pre><p><strong>注意:</strong> 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。<br>如果要完全删除对象，给 x 赋 null 值，代码如下:</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/539975a800017c8e04790082.jpg" alt=""></p>
<h4 id="13-替换元素节点replaceChild"><a href="#13-替换元素节点replaceChild" class="headerlink" title="13.替换元素节点replaceChild()"></a>13.替换元素节点replaceChild()</h4><p>replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。</p>
<pre><code>node.replaceChild (newnode,oldnew ) 
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/539557d70001c3ee07190429.jpg" alt=""></p>
<pre><code>效果: 将文档中的 Java 改为 JavaScript。
</code></pre><p><strong>注意:</strong></p>
<ol>
<li>当 oldnode 被替换时，所有与之相关的属性内容都将被移除。 </li>
<li>newnode 必须先被建立。</li>
<li>只有父结点才能调用  replaceChild(newnode,oldnode).这个方法，所以，要想替换当前结点的内容或者属性，那么首先得获得父节点，才可以操作，这就是为什么 oldnode.parentNode.replaceChild(newnode,oldnode); 这句代码的写法。。</li>
</ol>
<h4 id="14-创建元素节点createElement"><a href="#14-创建元素节点createElement" class="headerlink" title="14.创建元素节点createElement"></a>14.创建元素节点createElement</h4><p>createElement()方法可创建元素节点。此方法可返回一个 Element 对象。</p>
<pre><code>document.createElement(tagName)
</code></pre><p>tagName：字符串值，这个字符串用来指明创建元素的类型。</p>
<p><strong>注意</strong>：要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。</p>
<h4 id="15-创建文本节点createTextNode"><a href="#15-创建文本节点createTextNode" class="headerlink" title="15.创建文本节点createTextNode"></a>15.创建文本节点createTextNode</h4><p>createTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。</p>
<pre><code>document.createTextNode(data)
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/53951c200001d32d07130554.jpg" alt=""></p>
<h4 id="16-浏览器窗口可视区域大小"><a href="#16-浏览器窗口可视区域大小" class="headerlink" title="16.浏览器窗口可视区域大小"></a>16.浏览器窗口可视区域大小</h4><p>获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法:</p>
<p>一、对于IE9+、Chrome、Firefox、Opera 以及 Safari：</p>
<p>•  window.innerHeight - 浏览器窗口的内部高度</p>
<p>•  window.innerWidth - 浏览器窗口的内部宽度</p>
<p>二、对于 Internet Explorer 8、7、6、5：</p>
<p>•  document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。</p>
<p>•  document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。</p>
<p>或者</p>
<p>Document对象的body属性对应HTML文档的<body>标签</body></p>
<p>•  document.body.clientHeight</p>
<p>•  document.body.clientWidth</p>
<pre><code>在不同浏览器都实用的 JavaScript 方案：
var w= document.documentElement.clientWidth
      || document.body.clientWidth;
var h= document.documentElement.clientHeight
      || document.body.clientHeight;
</code></pre><h4 id="17-网页尺寸scrollHeight"><a href="#17-网页尺寸scrollHeight" class="headerlink" title="17.网页尺寸scrollHeight"></a>17.网页尺寸scrollHeight</h4><p>scrollHeight和scrollWidth，获取网页内容高度和宽度。</p>
<p>一、针对IE、Opera:<br>scrollHeight 是网页内容实际高度，可以小于 clientHeight。</p>
<p>二、针对NS、FF:<br>scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。</p>
<p>三、浏览器兼容性</p>
<pre><code>var w=document.documentElement.scrollWidth
   || document.body.scrollWidth;
var h=document.documentElement.scrollHeight
   || document.body.scrollHeight;
</code></pre><p>注意:区分大小写<br>scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。</p>
<h4 id="18-网页尺寸offsetHeight"><a href="#18-网页尺寸offsetHeight" class="headerlink" title="18.网页尺寸offsetHeight"></a>18.网页尺寸offsetHeight</h4><p>offsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。<br>一、值<br>offsetHeight = clientHeight + 滚动条 + 边框。<br>二、浏览器兼容性</p>
<pre><code>var w= document.documentElement.offsetWidth
    || document.body.offsetWidth;
var h= document.documentElement.offsetHeight
    || document.body.offsetHeight;
</code></pre><h4 id="19-网页卷去的距离与偏移量"><a href="#19-网页卷去的距离与偏移量" class="headerlink" title="19.网页卷去的距离与偏移量"></a>19.网页卷去的距离与偏移量</h4><p><img src="http://oncweb6po.bkt.clouddn.com/5347b2b10001e1a307520686.jpg" alt=""></p>
<p><strong>scrollLeft</strong>:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。</p>
<p><strong>scrollTop</strong>:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。</p>
<p><strong>offsetLeft</strong>:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。</p>
<p><strong>offsetTop</strong>:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。</p>
<p><strong>注意:</strong></p>
<ol>
<li>区分大小写</li>
<li>offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/px-em-rem单位/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/px-em-rem单位/" itemprop="url">px em rem单位</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:21:17+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.px</p>
<p>相对长度单位。像素px是相对于显示器屏幕分辨率而言的</p>
<blockquote>
<p>但是IE无法调整那些使用px作为单位的字体大小</p>
</blockquote>
<p>2.em</p>
<p>相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。（即相对父元素）</p>
<p>浏览器默认字体字体行高16px，1em=16px。在css中的body选择器中声明Font-size=62.5%，只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p>
<blockquote>
<p>会继承父级元素的字体大小</p>
</blockquote>
<p>3.rem</p>
<p>相对长度单位，但相对的只是HTML根元素。</p>
<pre><code>p {font-size:14px; font-size:.875rem;}
</code></pre><p>14px = 0.875em</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/px-pd-pid-等移动端知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/px-pd-pid-等移动端知识/" itemprop="url">px pd pid 等移动端知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:21:03+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-PX（css-pixels）——虚拟像素"><a href="#1-PX（css-pixels）——虚拟像素" class="headerlink" title="1.PX（css pixels）——虚拟像素"></a>1.PX（css pixels）——虚拟像素</h1><p>px是一个相对单位，相对的是设备像素</p>
<p>显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为ppi和dpi：</p>
<p>ppi：每英寸多少像素数，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。</p>
<p>dpi：每英寸多少点。</p>
<h1 id="2-DP-device-pixels-——设备像素（物理像素）"><a href="#2-DP-device-pixels-——设备像素（物理像素）" class="headerlink" title="2.DP(device pixels)——设备像素（物理像素）"></a>2.DP(device pixels)——设备像素（物理像素）</h1><p>pt在css单位中属于真正的绝对单位，1pt = 1/72(inch),inch及英寸，而1英寸等于2.54厘米。</p>
<blockquote>
<p>屏幕普遍采用RGB色域(红、绿、蓝三个子像素构成),而印刷行业普遍使用CMYK色域(青、品红、黄和黑)</p>
</blockquote>
<h1 id="3-设备像素-DP-与CSS像素之间的关系"><a href="#3-设备像素-DP-与CSS像素之间的关系" class="headerlink" title="3.设备像素(DP)与CSS像素之间的关系"></a>3.设备像素(DP)与CSS像素之间的关系</h1><pre><code>DPR = 设备像素/CSS像素
</code></pre><p>当这个比率为1:1时，使用1个设备像素显示1个CSS像素。当这个比率为2:1时，使用4个设备像素显示1个CSS像素，当这个比率为3:1时，使用9（3*3）个设备像素显示1个CSS像素。</p>
<p>window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。</p>
<h1 id="4-DIP-Device-independent-Pixel"><a href="#4-DIP-Device-independent-Pixel" class="headerlink" title="4.DIP(Device independent Pixel)"></a>4.DIP(Device independent Pixel)</h1><p>设备独立像素，也称为逻辑像素，简称dip。</p>
<blockquote>
<p>CSS像素 =设备独立像素 = 逻辑像素</p>
</blockquote>
<h1 id="5-PPI-pixels-per-inch"><a href="#5-PPI-pixels-per-inch" class="headerlink" title="5.PPI(pixels per inch)"></a>5.PPI(pixels per inch)</h1><blockquote>
<p>每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。</p>
</blockquote>
<h1 id="6-ppi和dpr到底什么关系？"><a href="#6-ppi和dpr到底什么关系？" class="headerlink" title="6.ppi和dpr到底什么关系？"></a>6.ppi和dpr到底什么关系？</h1><p>设备像素比与ppi相关，一般是ppi/160的整数倍：</p>
<h1 id="7-分辨率、像素和屏幕尺寸"><a href="#7-分辨率、像素和屏幕尺寸" class="headerlink" title="7.分辨率、像素和屏幕尺寸"></a>7.分辨率、像素和屏幕尺寸</h1><p>PPI 说的是像素密度，而分辨率说的是块屏幕的像素尺寸，譬如说 1334*750 就是 iPhone（6~7）的分辨率，说 iPhone（6~7）的分辨率是 326 是错误的表述，326 是它的像素密度，单位是 PPI。</p>
<h1 id="8-Viewport"><a href="#8-Viewport" class="headerlink" title="8.Viewport"></a>8.Viewport</h1><blockquote>
<p>ppk认为，移动设备上有三个viewport。</p>
<ol>
<li>layout viewport  document.documentElement.clientWidth 来获取</li>
<li>visual viewport的宽度可以通过window.innerWidth 来获取</li>
<li>viewport——移动设备的理想viewport。根据不同的设备有不同的宽度</li>
</ol>
</blockquote>
<h3 id="1-怎么让layout-viewport-visual-viewport？"><a href="#1-怎么让layout-viewport-visual-viewport？" class="headerlink" title="(1).怎么让layout viewport=visual viewport？"></a>(1).怎么让layout viewport=visual viewport？</h3><blockquote>
<meta name="viewport" content="width=device-width, initial-scale=1">

</blockquote>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170723080857.png" alt=""></p>
<h3 id="2-关于缩放以及initial-scale的默认值"><a href="#2-关于缩放以及initial-scale的默认值" class="headerlink" title="(2).关于缩放以及initial-scale的默认值"></a>(2).关于缩放以及initial-scale的默认值</h3><pre><code>visual viewport宽度 = ideal viewport宽度 / 当前缩放值
当前缩放值 = ideal viewport宽度 / visual viewport宽度
</code></pre><p>在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/两个viewport的故事-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/两个viewport的故事-二/" itemprop="url">两个viewport的故事(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:20:44+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-两个viewport"><a href="#1-两个viewport" class="headerlink" title="1.两个viewport"></a>1.两个viewport</h1><h3 id="1-visual-viewport"><a href="#1-visual-viewport" class="headerlink" title="(1).visual viewport"></a>(1).visual viewport</h3><p>visual viewport是页面当前显示在屏幕上的部分。用户可以通过滚动来改变他所看到的页面的部分，或者通过缩放来改变visual viewport的大小。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722214021.png" alt=""></p>
<h3 id="2-layout-viewport"><a href="#2-layout-viewport" class="headerlink" title="(2).layout viewport"></a>(2).layout viewport</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214137.png" alt=""></p>
<h3 id="3-度量visual-viewport"><a href="#3-度量visual-viewport" class="headerlink" title="(3).度量visual viewport"></a>(3).度量visual viewport</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214430.png" alt=""></p>
<h3 id="4-滚动距离Scrolling-offset"><a href="#4-滚动距离Scrolling-offset" class="headerlink" title="(4).滚动距离Scrolling offset"></a>(4).滚动距离Scrolling offset</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214525.png" alt=""></p>
<p>你还需知道的是visual viewport当前相对于layout viewport的位置。这是滚动距离，并且就像在桌面一样，它被存储在window.pageX/YOffset之中。</p>
<h3 id="5-元素"><a href="#5-元素" class="headerlink" title="(5). 元素"></a>(5).<html> 元素</html></h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214558.png" alt=""></p>
<p>就像在桌面上一样，document.documentElement.offsetWidth/Height提供了以CSS像素为单位的<html>元素的整个尺寸。</html></p>
<h3 id="6-媒体查询Media-queries"><a href="#6-媒体查询Media-queries" class="headerlink" title="(6).媒体查询Media queries"></a>(6).媒体查询Media queries</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214709.png" alt=""></p>
<p>媒体查询和其在桌面环境上的工作方式一样。width/height使用layout　viewport做为参照物，并且以CSS像素进行度量，device-width/height使用设备屏幕，并且以设备像素进行度量。</p>
<p>换句话说，width/height是document.documentElement.clientWidth/Height值的镜像，同时device-width/height是screen.width/height值的镜像。（它们在所有浏览器中实际上就是这么做的，即使这个镜像的值不正确。）</p>
<h3 id="7-事件坐标"><a href="#7-事件坐标" class="headerlink" title="(7).事件坐标"></a>(7).事件坐标</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722214758.png" alt=""></p>
<p>pageX/Y仍然是相对于页面，以CSS像素为单位，并且它是目前为止三个属性对中最有用的，就像它在桌面环境上的那样。</p>
<p>clientX/Y是相对于visual viewport来计算，以CSS像素为单位的。这有道理的，即使我还不能完全指出这么做的好处。</p>
<p>screenX/Y是相对于屏幕来计算，以设备像素为单位。当然，这和clientX/Y用的参照系是一样的，并且设备像素在这没有用处。所以我们不需要担心screenX/Y；跟在桌面环境上一样没有用处。</p>
<h3 id="8-viewport-meta标签"><a href="#8-viewport-meta标签" class="headerlink" title="(8).viewport meta标签"></a>(8).viewport meta标签</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/两个viewport的故事-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/两个viewport的故事-一/" itemprop="url">两个viewport的故事(一))</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:20:24+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、设备像素和css像素"><a href="#一、设备像素和css像素" class="headerlink" title="一、设备像素和css像素"></a>一、设备像素和css像素</h1><h3 id="1-设备像素dp-device-pixels"><a href="#1-设备像素dp-device-pixels" class="headerlink" title="(1).设备像素dp(device pixels)"></a>(1).设备像素dp(device pixels)</h3><p>设备像素又称物理像素（physical pixel），设备能控制显示的最小单位，我们可以把这些像素看作成显示器上一个个的点。</p>
<h3 id="2-CSS像素"><a href="#2-CSS像素" class="headerlink" title="(2).CSS像素"></a>(2).CSS像素</h3><p>CSS像素是Web编程的概念，独立于设备的用于逻辑上衡量像素的单位，也就是说我们在做网页时用到的CSS像素单位，是抽象的，而不是实际存在的。</p>
<h3 id="设备独立像素比"><a href="#设备独立像素比" class="headerlink" title="设备独立像素比"></a>设备独立像素比</h3><p>独立于设备的用于逻辑上衡量像素的单位。（(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”，<strong>两个基本一样</strong>）</p>
<p>不管是移动端还是PC端通过screen.width/height获取的这个值是设备独立像素（CSS 像素），而不是设备的屏幕分辨率</p>
<h3 id="3-PPI"><a href="#3-PPI" class="headerlink" title="(3).PPI"></a>(3).PPI</h3><p>PPI就是设备像素dp的单位</p>
<p>pixel per inch 翻译下就是每英寸内有多少个像素点,这个像素点指的是设备像素点（物理像素），说得接地气点PPI就是像素密度（pixel density）。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722111500.png" alt=""></p>
<h3 id="4-设备像素比"><a href="#4-设备像素比" class="headerlink" title="(4).设备像素比"></a>(4).设备像素比</h3><pre><code>设备像素比 = 设备像素/设备独立像素 // 在某一方向上，x方向或者y方向
</code></pre><p>可以通过JavaScript 中的window.devicePixelRatio来获取设备中的像素比值。</p>
<p>它可以告诉我们，一个设备像素对应多少个css像素</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722112006.png" alt=""></p>
<blockquote>
<p>科普：什么是Retina视网膜屏幕？PPI 值超过 300 的叫做超高密度屏幕，只是 Apple 给它换了个高大尚的名称：Retina 视网膜屏幕而已。</p>
</blockquote>
<h3 id="5-屏幕尺寸"><a href="#5-屏幕尺寸" class="headerlink" title="(5).屏幕尺寸"></a>(5).屏幕尺寸</h3><p>意义：用户屏幕的整体大小。</p>
<p>度量单位：设备像素。</p>
<p>screen.width和screen.height</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722204008.png" alt=""></p>
<h3 id="6-窗口尺寸"><a href="#6-窗口尺寸" class="headerlink" title="(6).窗口尺寸"></a>(6).窗口尺寸</h3><p>意义：浏览器窗口的整体大小，包括滚动条。</p>
<p>度量单位：CSS像素。</p>
<p>它告诉了你用户到底有多少空间可以用来做CSS布局。你可以通过window.innerWidth和window.innerHeight来获取这些尺寸。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722204315.png" alt=""></p>
<h3 id="7-滚动距离"><a href="#7-滚动距离" class="headerlink" title="(7).滚动距离"></a>(7).滚动距离</h3><p>意义：页面滚动的距离。</p>
<p>度量单位：CSS像素。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722204457.png" alt=""></p>
<h3 id="8-viewport"><a href="#8-viewport" class="headerlink" title="(8).viewport"></a>(8).viewport</h3><p>viewport的功能是用来约束你网站中最顶级包含块元素（containing block）<html\>的。</html\></p>
<p>viewport，接着，实际上等于浏览器窗口：它就是那么定义的。</p>
<h3 id="9-度量viewport"><a href="#9-度量viewport" class="headerlink" title="(9).度量viewport"></a>(9).度量viewport</h3><p>document.documentElement.clientWidth/Height</p>
<p>意义：Viewport尺寸。</p>
<p>度量单位：CSS像素。</p>
<p>不等于html的尺寸</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722205640.png" alt=""></p>
<h3 id="10-度量元素"><a href="#10-度量元素" class="headerlink" title="(10).度量元素"></a>(10).度量<html>元素</html></h3><p>document.documentElement.offsetWidth/Height</p>
<p>意义：<html>元素（也就是页面）的尺寸。</html></p>
<p>度量单位：CSS像素。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722210037.png" alt=""></p>
<h3 id="11-事件中的坐标"><a href="#11-事件中的坐标" class="headerlink" title="(11).事件中的坐标"></a>(11).事件中的坐标</h3><ol>
<li>pageX/Y提供了相对于<html>元素的以CSS像素度量的坐标。(IEb不支持)</html></li>
</ol>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722210548.png" alt=""></p>
<ol>
<li>clientX/Y提供了相对于viewport的以CSS像素度量的坐标。</li>
</ol>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722210555.png" alt=""></p>
<ol>
<li>screenX/Y提供了相对于屏幕的以设备像素进行度量的坐标。</li>
</ol>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170722210607.png" alt=""></p>
<p>90%的时间你将会使用pageX/Y；通常情况下你想知道的是相对于文档的事件坐标。其他的10%时间你将会使用clientX/Y。你永远不需要知道事件相对于屏幕的坐标。</p>
<h3 id="12-媒体查询"><a href="#12-媒体查询" class="headerlink" title="(12).媒体查询"></a>(12).媒体查询</h3><p>关于媒体查询的事。原理很简单：你可以声明「只在页面宽度大于，等于或者小于一个特定尺寸的时候才会被执行」的特殊的CSS规则。比如：</p>
<pre><code>div.sidebar {
    width: 300px;
}

@media all and (max-width: 400px) {
    // styles assigned when width is smaller than 400px;
    div.sidebar {
        width: 100px;
    }

}
</code></pre><p>当前sidebar是300px宽，除了当宽度小于400px的时候，在那种情况下sidebar变得100px宽。</p>
<p>这个宽度是 viewport的宽高</p>
<p>width/height使用和documentElement .clientWidth/Height（换句话说就是viewport宽高）一样的值。它是工作在CSS像素下的。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170722211808.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/浏览器页面加载解析渲染机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/浏览器页面加载解析渲染机制/" itemprop="url">浏览器页面加载解析渲染机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:19:57+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。"><a href="#一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。" class="headerlink" title="一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。"></a>一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。</h1><ul>
<li><p>了解浏览器如何进行<strong>加载</strong>，我们可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。</p>
</li>
<li><p>了解浏览器如何进行<strong>解析</strong>，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。</p>
</li>
<li><p>了解浏览器如何进行<strong>渲染</strong>，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少”重绘“”重新布局“的消耗。</p>
</li>
</ul>
<h1 id="二：用户访问网页都发生了什么。"><a href="#二：用户访问网页都发生了什么。" class="headerlink" title="二：用户访问网页都发生了什么。"></a>二：用户访问网页都发生了什么。</h1><ol>
<li><p>用户访问网页，DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址，找到后，系统会向对应IP地址的网络服务器发送一个http请求。</p>
</li>
<li><p>网络服务器解析请求，并发送请求给数据库服务器。</p>
</li>
<li><p>数据库服务器将请求的资源返回给网络服务器，网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器。</p>
</li>
<li><p>浏览器解析 http response。</p>
</li>
<li><p>浏览器解析 http response后，需要下载html文件，以及html文件内包含的外部引用文件，及文件内涉及的图片或者多媒体文件。（这里进入主题了也就是下面的第三大点）</p>
</li>
</ol>
<blockquote>
<p>1~4步骤HTTP协议的一些内容，访问服务器端可能遭遇的问题：如果网络服务器无法获取数据库服务器返回的资源文件（http response 404），或者由于并发原因暂时无法处理用户的http请求（http response 500）。</p>
</blockquote>
<h1 id="三：浏览器加载页面机制"><a href="#三：浏览器加载页面机制" class="headerlink" title="三：浏览器加载页面机制"></a>三：浏览器加载页面机制</h1><p>加载，即为获取资源文件的过程，不同浏览器，以及他们的不同版本在实现这一过程时，会有不同的实现效果(资源间互相阻塞，可以用timeline来做测试)。这里先说下浏览器的<strong>5个常驻线程</strong>：</p>
<ol>
<li><p>浏览器GUI渲染线程</p>
</li>
<li><p>javascript引擎线程</p>
</li>
<li><p>浏览器定时器触发线程（setTimeout）</p>
</li>
<li><p>浏览器事件触发线程</p>
</li>
<li><p>浏览器http异步请求线程（.jpg <link>这类请求）</p>
</li>
</ol>
<blockquote>
<p>备注：现代浏览器存在 prefetch 优化，浏览器会另外开启线程，提前下载js、css文件，需要注意的是，预加载js并不会改变dom结构，他将这个工作留给主加载。</p>
<p>注意：这里也涉及到 阻塞 的现象，当js引擎线程（第二个）进行时，会挂起其他一切线程，这个时候3、4、5这三类线程也会产生不同的异步事件，由于 javascript引擎线程为单线程，所以代码都是先压到队列，采用先进先出的方式运行，事件处理函数，timer函数也会压在队列中，不断的从队头取出事件，这就叫：javascript-event-loop。简单点说应该是当在进行第二线程的时候，1，3，4，5都会挂起，比如这时候触发click事件，即使先前JS已经加载完成，click事件会压在队列里，这里也要先完成第二线程才会执行click事件。</p>
</blockquote>
<p><strong>加载顺序：</strong></p>
<ol>
<li><p>浏览器解析http response 下载html文件会”自上而下“加载，并在加载过程中进行解析渲染。“自上而下”加载时遇到图片、视频之类资源时便会进入第5个线程，这是异步请求，并不会影响html文档进行加载。</p>
</li>
<li><p>加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。这里也是第5个线程，这里css解析会生成一个rule tree（规则树），这个以后会更新。</p>
</li>
<li><p>当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。</p>
</li>
</ol>
<blockquote>
<p>原因：JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。</p>
<p>办法：可以将外部引用的js文件放在前。</p>
</blockquote>
<p> 4、  css可能影响js的执行造成阻塞。</p>
<p>原因：如js里面var width = $(‘#id’).width();这里js执行前，浏览器必须保证之前的css文件已下载和解析完成(后面的不会影响)，这也是css阻塞后续js的根本原因。当js文件不需要依赖css文件时，可以将js文件放在头部css的前面。</p>
<p>5、 预加载网页，利用空余时间来提前加载该网页的后续网页。</p>
<pre><code>&lt;link rel=&quot;prefetch&quot; href=&quot;http://&quot;&gt;
</code></pre><p>6、为js脚本添加defer属性，其不会阻塞后续DOM的的渲染。但是因为这个defer只是IE专用，所以一般用得比较少。</p>
<p>而我们标准的的HTML5也加入了一个异步载入javascript的属性：async，无论你对它赋什么样的值，只要它出现，它就开始异步加载js文件。</p>
<p>但是， async的异步加载会有一个比较严重的问题，那就是它忠实地践行着“载入后马上执行”这条军规，所以，虽然它并不阻塞页面的渲染，但是你也无法控制他执行的次序和时机。</p>
<h1 id="四、浏览器解析渲染机制"><a href="#四、浏览器解析渲染机制" class="headerlink" title="四、浏览器解析渲染机制"></a>四、浏览器解析渲染机制</h1><h3 id="1-浏览器是如何对网页进行渲染的"><a href="#1-浏览器是如何对网页进行渲染的" class="headerlink" title="1.浏览器是如何对网页进行渲染的"></a>1.浏览器是如何对网页进行渲染的</h3><p>（1）.浏览器将从服务器获取的HTML文档构建成文档对象模型DOM(Document Object Model)</p>
<p>（2）.样式将被载入和解析，构成层叠样式表模型CSSOM(CSS Object Model)</p>
<p>（3）.在DOM和CSSOM之上，渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象（这在Webkit内核中被称为renderer或者渲染对象render object，在Gecko内核中被称为框架frame）。<strong>渲染树映射除了不可见元素（例如<head>或者含有display:none;的标签）外的所有DOM结构。</head></strong>每一段文本字符串都将划分在不同的渲染对象中，每一个渲染对象都包含了它相应的DOM对象以及计算后的样式。换句话讲，渲染树是DOM的直观表示。</p>
<p>（4）.渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout.浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素（tables需要多次pass绘制，pass表示像素处理和顶点处理）。</p>
<p>（5）.最后布局完成，渲染树将转化为屏幕上的实际内容，这一步被称为绘制painting。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170714155844.png" alt=""></p>
<h3 id="DOM-CSSOM-rendering-tree-layout-painting"><a href="#DOM-CSSOM-rendering-tree-layout-painting" class="headerlink" title="DOM-CSSOM-rendering tree-layout-painting"></a>DOM-CSSOM-rendering tree-layout-painting</h3><h3 id="2-重绘Repaint"><a href="#2-重绘Repaint" class="headerlink" title="2.重绘Repaint"></a>2.重绘Repaint</h3><p>当页面元素样式的改变不影响元素在文档流中的位置时（例如background-color, border-color,visibility）,浏览器只会将新样式赋予元素并进行重绘操作。</p>
<h3 id="3-回流Reflow"><a href="#3-回流Reflow" class="headerlink" title="3.回流Reflow"></a>3.回流Reflow</h3><p>当改变影响文档内容或者结构，或者元素位置时，回流操作就会被触发，一般有以下几种情况：</p>
<ol>
<li><p>DOM操作（对元素的增删改，顺序变化等）</p>
</li>
<li><p>内容变化，包括表单区域内的文本改变</p>
</li>
<li><p>CSS属性的更改或重新计算</p>
</li>
<li><p>增删样式表内容</p>
</li>
<li><p>修改class属性</p>
</li>
<li><p>浏览器窗口变化（滚动或缩放）</p>
</li>
<li><p>伪类样式激活（:hover等）</p>
</li>
</ol>
<h3 id="4-浏览器如何优化渲染"><a href="#4-浏览器如何优化渲染" class="headerlink" title="4.浏览器如何优化渲染"></a>4.浏览器如何优化渲染</h3><p>浏览器本身会尽可能地减少其重绘或回流的次数，只更改必要的元素。例如一个position设置为absolute/fixed的元素的更改只会影响其本身和其子元素，而static的元素变化则会影响其之后的所有页面元素。</p>
<p>另外一项优化的技术则是在JavaScript代码运行时，浏览器会缓存所有的变化，然后只通过一次pass绘制操作来应用这些更改。例如下面这段代码只会触发一次重绘和回流：</p>
<pre><code>var $body = $(&apos;body&apos;);
$body.css(&apos;padding&apos;, &apos;1px&apos;); // 触发重绘与回流
$body.css(&apos;color&apos;, &apos;red&apos;); // 触发重绘
$body.css(&apos;margin&apos;, &apos;2px&apos;); // 触发重绘与回流
// 最终只有一次重绘和回流被触发
</code></pre><p>然而，根据我们之前提到过的，获取某个元素的属性将会触发强制回流。比如我们在刚才的代码中加上一句读取元素属性的操作：</p>
<pre><code>var $body = $(&apos;body&apos;);
$body.css(&apos;padding&apos;, &apos;1px&apos;);
$body.css(&apos;padding&apos;); // 此处触发强制回流
$body.css(&apos;color&apos;, &apos;red&apos;);
$body.css(&apos;margin&apos;, &apos;2px&apos;);
</code></pre><p>结果就会有两次回流发生。因此，我们应该尽量合并读取元素属性的操作来优化性能。</p>
<p>当然也有我们不得不触发强制回流的情况。比如说对同一个元素的margin-left属性进行两次操作——开始的时候赋值100px的距离，之后为了实现动画效果，再加上transition属性将距离改变到50px.</p>
<p>我们先定义一个CSS类：</p>
<pre><code>.has-transition {
   -webkit-transition: margin-left 1s ease-out;
      -moz-transition: margin-left 1s ease-out;
        -o-transition: margin-left 1s ease-out;
           transition: margin-left 1s ease-out;
}
</code></pre><p>之后再对页面元素进行操作：</p>
<pre><code>// 我们的元素开始默认含有 &quot;has-transition&quot; 的class属性
var $targetElem = $(&apos;#targetElemId&apos;);

// 移除默认的 &quot;has-transition&quot;
$targetElem.removeClass(&apos;has-transition&apos;);

// 此处的属性改变没有动画效果
$targetElem.css(&apos;margin-left&apos;, 100);

// 再加上原来的属性名
$targetElem.addClass(&apos;has-transition&apos;);

// 这次改变有动画效果
$targetElem.css(&apos;margin-left&apos;, 50);
</code></pre><p>但事实上这段代码并不会像注释描述的那样运作，每条语句的操作将被缓存，只有结果会在页面上显示，所以我们就需要手动进行一次强制回流：</p>
<pre><code>// 移除默认的 &quot;has-transition&quot;
$(this).removeClass(&apos;has-transition&apos;);

// 此处的属性改变没有动画效果
$(this).css(&apos;margin-left&apos;, 100);

// 触发强制回流，上述两条语句的效果会马上在页面中显示
$(this)[0].offsetHeight; // 只是举个例子，别的触发方法也可以

// 再加上原来的属性名
$(this).addClass(&apos;has-transition&apos;);

// 这次改变有动画效果
$(this).css(&apos;margin-left&apos;, 50);
</code></pre><h3 id="5-优化渲染效率的几条最佳实践"><a href="#5-优化渲染效率的几条最佳实践" class="headerlink" title="5.优化渲染效率的几条最佳实践"></a>5.优化渲染效率的几条最佳实践</h3><ol>
<li><p>合法地书写HTML和CSS，不要忘了文档编码类型。样式文件应当在 <head> 标签中，脚本文件在 </head><body> 结束前。</body></p>
</li>
<li><p>简化并优化你的CSS选择器（有些人可能CSS预处理器用习惯了从来不关注这一点）。将嵌套层减少到最小。CSS选择器根据其优先级具有不同的运行效率（从快到慢）：</p>
</li>
</ol>
<ul>
<li>ID选择器： #id</li>
</ul>
<ul>
<li>类选择器： .class</li>
</ul>
<ul>
<li>标签选择器： div</li>
</ul>
<ul>
<li>相邻选择器： a + i</li>
</ul>
<ul>
<li>子元素选择器： ul &gt; li</li>
</ul>
<ul>
<li>通用选择器： *</li>
</ul>
<ul>
<li>属性选择器： input[type=”text”]</li>
</ul>
<ul>
<li>伪类选择器： a:hover</li>
</ul>
<p>浏览器中CSS选择器是从右到左进行匹配的（为什么浏览器要从右到左匹配样式选择器），这也是为什么越短的选择器运行越快的原因（别提通用选择器，它会遍历所有元素）：</p>
<pre><code>div * {...} // ×
.list li {...} // ×
.list-item {...} // √
#list .list-item {...} // √
</code></pre><p>3.在你的脚本代码中，尽量减少DOM操作。缓存所有的内容，包括属性和对象（如果他们需要被复用的话）。尽量将元素缓存到本地之后再进行操作，最后再添加到DOM当中。</p>
<p>4.如果你使用jQuery进行DOM操作的话，最好遵循jQuery最佳实践。</p>
<p>5.修改元素样式时，更改其class属性是性能最高的方法。你的选择器越有针对性越好（这同样也有助于分离页面样式和逻辑）。</p>
<p>6.尽量只对 position 为 absolute/fixed 的元素设置动画。</p>
<p>7.在页面滚动时禁用 :hover 样式效果：</p>
<pre><code>.disable-hover {
  pointer-events: none;
}
var body = document.body,
    timer;

window.addEventListener(&apos;scroll&apos;, function() {
  clearTimeout(timer);
  if(!body.classList.contains(&apos;disable-hover&apos;)) {
    body.classList.add(&apos;disable-hover&apos;)
  }

  timer = setTimeout(function(){
    body.classList.remove(&apos;disable-hover&apos;)
  },500);
}, false);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/vuex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/vuex/" itemprop="url">vuex</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:18:08+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>vuex是一个专门为vue.js设计的集中式状态管理架构。状态？我把它理解为在data中的属性需要共享给其他vue组件使用的部分，就叫做状态。简单的说就是data中需要共用的属性。比如：我们有几个页面要显示用户名称和用户等级，或者显示用户的地理位置。如果我们不把这些属性设置为状态，那每个页面遇到后，都会到服务器进行查找计算，返回后再显示。在中大型项目中会有很多共用的数据，所以尤大神给我们提供了vuex。</p>
<h1 id="第1节：初出茅庐-来个小Demo"><a href="#第1节：初出茅庐-来个小Demo" class="headerlink" title="第1节：初出茅庐 来个小Demo"></a>第1节：初出茅庐 来个小Demo</h1><h2 id="引入vuex"><a href="#引入vuex" class="headerlink" title="引入vuex"></a>引入vuex</h2><p>1.利用npm包管理工具，进行安装 vuex。在控制命令行中输入下边的命令就可以了。</p>
<pre><code>npm install vuex --save
</code></pre><p>需要注意的是这里一定要加上 –save，因为你这个包我们在生产环境中是要使用的。</p>
<p>2.新建一个vuex文件夹（这个不是必须的），并在文件夹下新建store.js文件，文件中引入我们的vue和vuex。</p>
<pre><code>import Vue from &apos;vue&apos;;
import Vuex from &apos;vuex&apos;;
</code></pre><p>3.使用我们vuex，引入之后用Vue.use进行引用。</p>
<pre><code>Vue.use(Vuex);
</code></pre><h2 id="一个demo：加减按钮"><a href="#一个demo：加减按钮" class="headerlink" title="一个demo：加减按钮"></a>一个demo：加减按钮</h2><p>这次要用的是vuex来进行制作，并实现数据的共享。</p>
<p>1.现在我们store.js文件里增加一个常量对象。store.js文件就是我们在引入vuex时的那个文件。</p>
<pre><code>const state={
    count:1
}
</code></pre><p>2.用export default 封装代码，让外部可以引用。</p>
<pre><code>export default new Vuex.Store({
    state

})
</code></pre><p>3.新建一个vue的模板，位置在components文件夹下，名字叫count.vue。在模板中我们引入我们刚建的store.js文件，并在模板中用输出count 的值。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{msg}}&lt;/h2&gt;
        &lt;hr/&gt;
        &lt;h3&gt;{{$store.state.count}}&lt;/h3&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import store from &apos;@/vuex/store&apos;
    export default{
        data(){
            return{
                msg:&apos;Hello Vuex&apos;,

            }
        },
        store

    }
&lt;/script&gt;
</code></pre><p>4.在store.js文件中加入两个改变state的方法。</p>
<pre><code>const mutations={
    add(state){
        state.count++;
    },
    reduce(state){
        state.count--;
    }
}
</code></pre><p>这里的mutations是固定的写法，意思是改变的，我们到时候会用一节课专门讲这个mutations，所以你先不用着急，只知道我们要改变state的数值的方法，必须写在mutations里就可以了。</p>
<p>5.在count.vue模板中加入两个按钮，并调用mutations中的方法。</p>
<pre><code>&lt;div&gt;
    &lt;button @click=&quot;$store.commit(&apos;add&apos;)&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;$store.commit(&apos;reduce&apos;)&quot;&gt;-&lt;/button&gt;
&lt;/div&gt;
</code></pre><h1 id="第2节：state访问状态对象"><a href="#第2节：state访问状态对象" class="headerlink" title="第2节：state访问状态对象"></a>第2节：state访问状态对象</h1><p>在第1节我们已经写了一个 const state ，这个就是我们说的访问状态对象，它就是我们SPA（单页应用程序）中的共享值。今天我们主要学习状态对象赋值给内部对象，也就是把stroe.js中的值，赋值给我们模板里data中的值。我们有三种赋值方式，我们一个一个来学习一下。</p>
<h2 id="一、通过computed的计算属性直接赋值"><a href="#一、通过computed的计算属性直接赋值" class="headerlink" title="一、通过computed的计算属性直接赋值"></a>一、通过computed的计算属性直接赋值</h2><p>computed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。</p>
<pre><code>computed:{
    count(){
        return this.$store.state.count;
    }
}
</code></pre><p>这里需要注意的是return this.$store.state.count这一句，一定要写this，要不你会找不到$store的。这种写法很好理解，但是写起来是比较麻烦的，那我们来看看第二种写法。</p>
<h2 id="二、通过mapState的对象来赋值"><a href="#二、通过mapState的对象来赋值" class="headerlink" title="二、通过mapState的对象来赋值"></a>二、通过mapState的对象来赋值</h2><p>我们首先要用import引入mapState。</p>
<pre><code>import {mapState} from &apos;vuex&apos;;
</code></pre><p>然后还在computed计算属性里写如下代码：</p>
<pre><code>computed:mapState({
        count:state=&gt;state.count
 })
</code></pre><p>这里我们使用ES6的箭头函数来给count赋值。</p>
<h2 id="三、通过mapState的数组来赋值"><a href="#三、通过mapState的数组来赋值" class="headerlink" title="三、通过mapState的数组来赋值"></a>三、通过mapState的数组来赋值</h2><pre><code>computed:mapState([&quot;count&quot;])
</code></pre><p>这个算是最简单的写法了，在实际项目开发当中也经常这样使用。</p>
<p>这就是三种赋值方式，是不是很简单，虽然简单，但是在实际项目中经常使用，一定要自己动手练习两遍啊。</p>
<h1 id="第4节：getters计算过滤操作"><a href="#第4节：getters计算过滤操作" class="headerlink" title="第4节：getters计算过滤操作"></a>第4节：getters计算过滤操作</h1><p>getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工。你可以把它看作store.js的计算属性。</p>
<h2 id="getters基本用法："><a href="#getters基本用法：" class="headerlink" title="getters基本用法："></a>getters基本用法：</h2><p>比如我们现在要对store.js文件中的count进行一个计算属性的操作，就是在它输出前，给它加上100.</p>
<p>我们首先要在store.js里用const声明我们的getters属性。</p>
<pre><code>const getters = {
    count:function(state){
        return state.count +=100;
    }
}
</code></pre><p>写好了gettters之后，我们还需要在Vuex.Store()里引入，由于之前我们已经引入了state盒mutations，所以引入里有三个引入属性。代码如下，</p>
<pre><code>export default new Vuex.Store({
    state,mutations,getters
})
</code></pre><p>在store.js里的配置算是完成了，我们需要到模板页对computed进行配置。在vue 的构造器里边只能有一个computed属性，如果你写多个，只有最后一个computed属性可用，所以要对上节课写的computed属性进行一个改造。改造时我们使用ES6中的展开运算符”…”。</p>
<pre><code>computed:{
    ...mapState([&quot;count&quot;]),
    count(){
        return this.$store.getters.count;
    }
},
</code></pre><p>需要注意的是，你写了这个配置后，在每次count 的值发生变化的时候，都会进行加100的操作。</p>
<h2 id="用mapGetters简化模板写法："><a href="#用mapGetters简化模板写法：" class="headerlink" title="用mapGetters简化模板写法："></a>用mapGetters简化模板写法：</h2><p>我们都知道state和mutations都有map的引用方法把我们模板中的编码进行简化，我们的getters也是有的，我们来看一下代码。</p>
<p>首先用import引入我们的mapGetters</p>
<pre><code>import { mapState,mapMutations,mapGetters } from &apos;vuex&apos;;
</code></pre><p>在computed属性中加入mapGetters</p>
<pre><code>...mapGetters([&quot;count&quot;])
</code></pre><h1 id="第5节：actions异步修改状态"><a href="#第5节：actions异步修改状态" class="headerlink" title="第5节：actions异步修改状态"></a>第5节：actions异步修改状态</h1><p>actions和之前讲的Mutations功能基本一样，不同点是，actions是异步的改变state状态，而Mutations是同步改变状态。至于什么是异步什么是同步这里我就不做太多解释了，如果你不懂自己去百度查一下吧。（视频中有讲解）</p>
<h2 id="在store-js中声明actions"><a href="#在store-js中声明actions" class="headerlink" title="在store.js中声明actions"></a>在store.js中声明actions</h2><p>actions是可以调用Mutations里的方法的，我们还是继续在上节课的代码基础上进行学习，在actions里调用add和reduce两个方法。</p>
<pre><code>const actions ={
    addAction(context){
        context.commit(&apos;add&apos;,10)
    },
    reduceAction({commit}){
        commit(&apos;reduce&apos;)
    }
}
</code></pre><p>在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。细心的小伙伴会发现这两个方法传递的参数也不一样。</p>
<ul>
<li>context：上下文对象，这里你可以理解称store本身。</li>
</ul>
<ul>
<li>{commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。</li>
</ul>
<h2 id="模板中的使用"><a href="#模板中的使用" class="headerlink" title="模板中的使用"></a>模板中的使用</h2><p>我们需要在count.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的actions里的方法名，分别是：addAction和reduceAction。</p>
<pre><code>&lt;p&gt;
  &lt;button @click=&quot;addAction&quot;&gt;+&lt;/button&gt;
  &lt;button @click=&quot;reduceAction&quot;&gt;-&lt;/button&gt;
&lt;/p&gt;
</code></pre><p>改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。</p>
<pre><code>methods:{
    ...mapMutations([  
        &apos;add&apos;,&apos;reduce&apos;
    ]),
    ...mapActions([&apos;addAction&apos;,&apos;reduceAction&apos;])
},
</code></pre><p>你还要记得用import把我们的mapActions引入才可以使用。</p>
<h2 id="增加异步检验"><a href="#增加异步检验" class="headerlink" title="增加异步检验"></a>增加异步检验</h2><p>我们现在看的效果和我们用Mutations作的一模一样，肯定有的小伙伴会好奇，那actions有什么用，我们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用setTimeOut进行延迟执行。</p>
<pre><code>setTimeOut(()=&gt;{context.commit(reduce)},3000);
console.log(&apos;我比reduce提前执行&apos;);
</code></pre><p>我们可以看到在控制台先打印出了‘我比reduce提前执行’这句话。</p>
<h1 id="第6节：module模块组"><a href="#第6节：module模块组" class="headerlink" title="第6节：module模块组"></a>第6节：module模块组</h1><p>随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。那今天我们就学习一下module：状态管理器的模块组操作。</p>
<h2 id="声明模块组："><a href="#声明模块组：" class="headerlink" title="声明模块组："></a>声明模块组：</h2><p>在vuex/store.js中声明模块组，我们还是用我们的const常量的方法声明模块组。代码如下：</p>
<pre><code>const moduleA={
    state,mutations,getters,actions
}
</code></pre><p>声明好后，我们需要修改原来 Vuex.Stroe里的值：</p>
<pre><code>export default new Vuex.Store({
    modules:{a:moduleA}
})
</code></pre><h2 id="在模板中使用"><a href="#在模板中使用" class="headerlink" title="在模板中使用"></a>在模板中使用</h2><p>现在我们要在模板中使用count状态，要用插值的形式写入。</p>
<pre><code>&lt;h3&gt;{{$store.state.a.count}}&lt;/h3&gt;
</code></pre><p>如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。写法如下：</p>
<pre><code>computed:{
    count(){
        return this.$store.state.a.count;
    }
},
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/vue-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/vue-router/" itemprop="url">vue-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:17:13+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于Vue在开发时对路由支持的不足，后来官方补充了vue-router插件，它在Vue的生态环境中非常重要，在实际开发中只要编写一个页面就会操作vue-router。要学习vue-router就要先知道这里的路由是什么？这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是我们WebApp的链接路径管理系统。</p>
<p>有的小伙伴会有疑虑，为什么我们不能像原来一样直接用<a></a>标签编写链接哪？因为我们用Vue作的都是单页应用，就相当于只有一个主的index.html页面，所以你写的<a></a>标签是不起作用的，你必须使用vue-router来进行管理。</p>
<h1 id="第1节：Vue-router入门"><a href="#第1节：Vue-router入门" class="headerlink" title="第1节：Vue-router入门"></a>第1节：Vue-router入门</h1><h2 id="安装vue-router"><a href="#安装vue-router" class="headerlink" title="安装vue-router"></a>安装vue-router</h2><p>vue-router是一个插件包，所以我们还是需要用npm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。</p>
<pre><code>npm install vue-router --save-dev
</code></pre><p>如果你安装很慢，也可以用cnpm进行安装，如果你在使用vue-cli中已经选择安装了vue-router，那这里不需要重复安装了。</p>
<h2 id="解读router-index-js文件"><a href="#解读router-index-js文件" class="headerlink" title="解读router/index.js文件"></a>解读router/index.js文件</h2><p>我们用vue-cli生产了我们的项目结构，你可以在src/router/index.js文件，这个文件就是路由的核心文件，我们先解读一下它。</p>
<pre><code>import Vue from &apos;vue&apos;   //引入Vue
import Router from &apos;vue-router&apos;  //引入vue-router
import Hello from &apos;@/components/Hello&apos;  //引入根目录下的Hello.vue组件

Vue.use(Router)  //Vue全局使用Router

export default new Router({
  routes: [              //配置路由，这里是个数组
    {                    //每一个链接都是一个对象
      path: &apos;/&apos;,         //链接路径
      name: &apos;Hello&apos;,     //路由名称，
      component: Hello   //对应的组件模板
    }
  ]
})
</code></pre><p>上边的代码中已经对每行都进行了注释，其实在这个路由文件里只配置了一个功能，就是在进入项目时，显示Hello.vue里边的内容代码。</p>
<h2 id="增加一个Hi的路由和页面"><a href="#增加一个Hi的路由和页面" class="headerlink" title="增加一个Hi的路由和页面"></a>增加一个Hi的路由和页面</h2><ul>
<li>在src/components目录下，新建 Hi.vue 文件。</li>
</ul>
<ul>
<li><p>编写文件内容，和我们之前讲过的一样，文件要包括三个部分<template><script>和<style>。文件很简单，只是打印一句话。</p>
  <template><br>    <div class="hello"><br>      <h1></h1><br>    </div><br>  </template>

  <script>
  export default {
    name: 'hi',
    data () {
      return {
        msg: 'Hi, I am JSPang'
      }
    }
  }
  </script>


</template></p></li>
</ul>
<pre><code>&lt;style scoped&gt;

&lt;/style&gt;
</code></pre><ul>
<li>引入 Hi组件：我们在router/index.js文件的上边引入Hi组件</li>
</ul>
<ul>
<li><p>增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。</p>
<p>  {</p>
<pre><code>path:&apos;/hi&apos;,
name:&apos;Hi&apos;,
component:Hi
</code></pre><p>  }</p>
<p>  import Vue from ‘vue’   //引入Vue<br>  import Router from ‘vue-router’  //引入vue-router<br>  import Hello from ‘@/components/Hello’  //引入根目录下的Hello.vue组件<br>  import Hi from ‘@/components/Hi’ </p>
<p>  Vue.use(Router)  //Vue全局使用Router</p>
<p>  export default new Router({</p>
<pre><code>routes: [              //配置路由，这里是个数组
  {                    //每一个链接都是一个对象
    path: &apos;/&apos;,         //链接路径
    name: &apos;Hello&apos;,     //路由名称，
    component: Hello   //对应的组件模板
  },{
    path:&apos;/hi&apos;,
    name:&apos;Hi&apos;,
    component:Hi
  }
]
</code></pre><p>  })</p>
</li>
</ul>
<h2 id="router-link制作导航"><a href="#router-link制作导航" class="headerlink" title="router-link制作导航"></a>router-link制作导航</h2><p>现在通过在地址栏改变字符串地址，已经可以实现页面内容的变化了。这并不满足需求，我们需要的是在页面上有个像样的导航链接，我们只要点击就可以实现页面内容的变化。制作链接需要<router-link>标签，我们先来看一下它的语法。</router-link></p>
<pre><code>&lt;router-link to=&quot;/&quot;&gt;[显示字段]&lt;/router-link&gt;
</code></pre><ul>
<li>to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成  to=”/”  ，</li>
<li>[显示字段] ：就是我们要显示给用户的导航名称，比如首页  新闻页。</li>
</ul>
<p>明白了router-link的基本语法，我们在 src/App.vue文件中的template里加入下面代码，实现导航。</p>
<pre><code>&lt;p&gt;导航 ：
   &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;
   &lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt;
&lt;/p&gt;
</code></pre><h1 id="第2节：vue-router配置子路由"><a href="#第2节：vue-router配置子路由" class="headerlink" title="第2节：vue-router配置子路由"></a>第2节：vue-router配置子路由</h1><p>我们上节课初步了解Vue-router的初步知识，也学会了基本的跳转，那我们这节课学习一下子菜单的路由方式，也叫子路由。子路由的情况一般用在一个页面有他的基础模版，然后它下面的页面都隶属于这个模版，只是部分改变样式。我们接着第一节课的实例，在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。</p>
<h2 id="一、改造App-vue的导航代码"><a href="#一、改造App-vue的导航代码" class="headerlink" title="一、改造App.vue的导航代码"></a>一、改造App.vue的导航代码</h2><p>我们需要先改造app.vue的导航代码，来实现基本的导航功能。我们用<router-link>标签增加了两个新的导航链接。</router-link></p>
<h2 id="App-vue代码"><a href="#App-vue代码" class="headerlink" title="App.vue代码"></a>App.vue代码</h2><pre><code>&lt;p&gt;导航 ：
      &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; | 
      &lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt; |
      &lt;router-link to=&quot;/hi/hi1&quot;&gt;-Hi页面1&lt;/router-link&gt; |
      &lt;router-link to=&quot;/hi/hi2&quot;&gt;-Hi页面2&lt;/router-link&gt;
&lt;/p&gt;
</code></pre><h2 id="二、改写components-Hi-vue页面"><a href="#二、改写components-Hi-vue页面" class="headerlink" title="二、改写components/Hi.vue页面"></a>二、改写components/Hi.vue页面</h2><p>把Hi.vue改成一个通用的模板，加入<router-view>标签，给子模板提供插入位置。“Hi页面1”   和 “Hi页面2”  都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入<router-view>标签。</router-view></router-view></p>
<p>components/Hi.vue,就是第5行的代码，其他代码不变。</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;

    &lt;router-view class=&quot;aaa&quot;&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;hi&apos;,
  data () {
    return {
      msg: &apos;Hi, I am JSPang&apos;
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;

&lt;/style&gt;
</code></pre><h2 id="三、在components目录下新建两个组件模板-Hi1-vue-和-Hi2-vue"><a href="#三、在components目录下新建两个组件模板-Hi1-vue-和-Hi2-vue" class="headerlink" title="三、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue"></a>三、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue</h2><p>新建的模板和Hi.vue没有太多的差别，知识改变了data中message的值，也就是输出的结果不太一样了。</p>
<p>Hi1.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &apos;hi&apos;,
  data () {
    return {
      msg: &apos;Hi, I am Hi1!&apos;
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;

&lt;/style&gt;
</code></pre><p>Hi2.vue</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;hello&quot;&gt;
    &lt;h1&gt;{{ msg }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &apos;hi&apos;,
  data () {
    return {
      msg: &apos;Hi, I am Hi2&apos;
    }
  }
}
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre><h2 id="四、修改router-index-js代码"><a href="#四、修改router-index-js代码" class="headerlink" title="四、修改router/index.js代码"></a>四、修改router/index.js代码</h2><p>我们现在导航有了，母模板和子模板也有了，只要改变我们的路由配置文件就可以了。子路由的写法是在原有的路由配置下加入children字段。</p>
<pre><code>children:[
{path:&apos;/&apos;,component:xxx},
{path:&apos;xx&apos;,component:xxx},
]
</code></pre><p>children字段后边跟的是个数组，数组里和其他配置路由基本相同，需要配置path和component。具体看一下这个子路由的配置写法。</p>
<pre><code>import Vue from &apos;vue&apos;   
import Router from &apos;vue-router&apos;  
import Hello from &apos;@/components/Hello&apos;  
import Hi from &apos;@/components/Hi&apos; 
import Hi1 from &apos;@/components/Hi1&apos; 
import Hi2 from &apos;@/components/Hi2&apos; 

Vue.use(Router) 

export default new Router({
  routes: [             
    {                    
      path: &apos;/&apos;,        
      name: &apos;Hello&apos;,     
      component: Hello   
    },{
      path:&apos;/hi&apos;,
      component:Hi,
      children:[
        {path:&apos;/&apos;,component:Hi},
        {path:&apos;hi1&apos;,component:Hi1},
        {path:&apos;hi2&apos;,component:Hi2},
      ]
    }
  ]
})
</code></pre><p>需要注意的是，在配置路由文件前，需要先用import引入Hi1和Hi2。</p>
<h1 id="第3节：vue-router如何参数传递"><a href="#第3节：vue-router如何参数传递" class="headerlink" title="第3节：vue-router如何参数传递"></a>第3节：vue-router如何参数传递</h1><p>开发中，参数的传递是个最基本的业务需求。通过URL地址来传递参数是一个形式，这节课我们就看看vue-router为我们提供了那些传递参数的功能。我们先想象一个基本需求，就是在我们点击导航菜单时，跳转页面上能显示出当前页面的路径，来告诉用户你想在所看的页面位置（类似于面包屑导航）。</p>
<h2 id="一、用name传递参数"><a href="#一、用name传递参数" class="headerlink" title="一、用name传递参数"></a>一、用name传递参数</h2><p>前两节课一直出现name的选项，但是我们都没有讲，这节课我们讲name的一种作用，传递参数。接着上节课的程序继续编写。</p>
<p>两步完成用name传值并显示在模板里：</p>
<ul>
<li><p>在路由文件src/router/index.js里配置name属性。</p>
<pre><code>routes: [
   {
     path: &apos;/&apos;,
     name: &apos;Hello&apos;,
     component: Hello
   }
]
</code></pre></li>
</ul>
<ul>
<li><p>模板里(src/App.vue)用$router.name的形势接收，比如直接在模板中显示：</p>
<pre><code>&lt;p&gt;{{ $route.name}}&lt;/p&gt;
</code></pre></li>
</ul>
<h2 id="二、通过-标签中的to传参"><a href="#二、通过-标签中的to传参" class="headerlink" title="二、通过 标签中的to传参"></a>二、通过<router-link> 标签中的to传参</router-link></h2><p>也许你也会觉的上边的传参很不正规，也不方便，其实我们多数传参是不用name进行传参的，我们用<router-link>标签中的to属性进行传参，需要您注意的是这里的to要进行一个绑定，写成:to。先来看一下这种传参方法的基本语法：</router-link></p>
<pre><code>&lt;router-link :to=&quot;{name:xxx,params:{key:value}}&quot;&gt;valueString&lt;/router-link&gt;
</code></pre><p>这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串.</p>
<ul>
<li>name：就是我们在路由配置文件中起的name值。</li>
</ul>
<ul>
<li>params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。</li>
<li>了解基本的语法后，我们改造一下我们的src/App.vue里的<router-link>标签,我们把hi1页面的<router-link>进行修改。</router-link></router-link></li>
</ul>
<pre><code>&lt;router-link :to=&quot;{name:&apos;hi1&apos;,params:{username:&apos;jspang&apos;}}&quot;&gt;Hi页面1&lt;/router-link&gt;
</code></pre><p>把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1.</p>
<pre><code>{path:&apos;/hi1&apos;,name:&apos;hi1&apos;,component:Hi1},
</code></pre><p>最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收.</p>
<pre><code>{{$route.params.username}}
</code></pre><h1 id="第4节：单页面多路由区域操作"><a href="#第4节：单页面多路由区域操作" class="headerlink" title="第4节：单页面多路由区域操作"></a>第4节：单页面多路由区域操作</h1><p>这节课我们讲“单页面多路由区域操作”，实际需求是这样的，在一个页面里我们有2个以上<router-view>区域，我们通过配置路由的js文件，来操作这些区域的内容。例如我们在src/App.vue里加上两个<router-view>标签。我们用vue-cli建立了新的项目，并打开了src目录下的App.vue文件，在<router-view>下面新写了两行<router-view>标签,并加入了些CSS样式。</router-view></router-view></router-view></router-view></p>
<pre><code>&lt;router-view &gt;&lt;/router-view&gt;
&lt;router-view name=&quot;left&quot; style=&quot;float:left;width:50%;background-color:#ccc;height:300px;&quot;&gt;&lt;/router-view&gt;
&lt;router-view name=&quot;right&quot; style=&quot;float:right;width:50%;background-color:#c0c;height:300px;&quot;&gt;&lt;/router-view&gt;
</code></pre><p>现在的页面中有了三个<router-view>标签，也就是说我们需要在路由里配置这三个区域，配置主要是在components字段里进行。</router-view></p>
<pre><code>import Vue from &apos;vue&apos;
import Router from &apos;vue-router&apos;
import Hello from &apos;@/components/Hello&apos;
import Hi1 from &apos;@/components/Hi1&apos;
import Hi2 from &apos;@/components/Hi2&apos;

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: &apos;/&apos;,
      components: {
        default:Hello,
        left:Hi1,
        right:Hi2
      }
    },{
      path: &apos;/Hi&apos;,
      components: {
        default:Hello,
        left:Hi2,
        right:Hi1
      }
    }

  ]
})
</code></pre><p>上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是’/Hi’.在两个路径下的components里面，我们对三个区域都定义了显示内容。</p>
<p>定义好后，我们需要在component文件夹下，新建Hi1.vue和Hi2.vue页面就可以了。</p>
<p>Hi1.vue</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{ msg }}&lt;/h2&gt; 
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;hi1&apos;,
  data () {
    return {
      msg: &apos;I am Hi1 page.&apos;
    }
  }
}
&lt;/script&gt;
</code></pre><p>Hi2.vue</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{ msg }}&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;hi2&apos;,
  data () {
    return {
      msg: &apos;I am Hi2 page.&apos;
    }
  }
}
&lt;/script&gt;
</code></pre><p>最后在App.vue中配置我们的<router-link>就可以了</router-link></p>
<pre><code>&lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; | 
&lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt; |
</code></pre><h1 id="第5节：vue-router-利用url传递参数"><a href="#第5节：vue-router-利用url传递参数" class="headerlink" title="第5节：vue-router 利用url传递参数"></a>第5节：vue-router 利用url传递参数</h1><p>我们在第3节虽然已经学会传递参数，但是我们这些老程序员的情怀还是利用url来传值，因为我们以前在前后端没有分开开发的时候，经常这样做。在实际开发也是有很多用URL传值的需求，比如我们在新闻列表中有很多新闻标题整齐的排列，我们需要点击每个新闻标题打开不同的新闻内容，这时在跳转路由时跟上新闻编号就十分实用。</p>
<h2 id="冒号的形式传递参数"><a href="#冒号的形式传递参数" class="headerlink" title=":冒号的形式传递参数"></a>:冒号的形式传递参数</h2><p>我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。</p>
<ul>
<li><p>在配置文件里以冒号的形式设置参数。我们在/src/router/index.js文件里配置路由。</p>
<pre><code>{
    path:&apos;/params/:newsId/:newsTitle&apos;,
     component:Params
}
</code></pre></li>
</ul>
<p>我们需要传递参数是新闻ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。</p>
<ul>
<li><p>在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{ msg }}&lt;/h2&gt;
        &lt;p&gt;新闻ID：{{ $route.params.newsId}}&lt;/p&gt;
        &lt;p&gt;新闻标题：{{ $route.params.newsTitle}}&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;params&apos;,
  data () {
    return {
      msg: &apos;params page&apos;
    }
  }
}
&lt;/script&gt;
</code></pre></li>
</ul>
<ul>
<li><p>在App.vue文件里加入我们的<router-view>标签。这时候我们可以直接利用url传值了。</router-view></p>
<pre><code>&lt;router-link to=&quot;/params/198/jspang website is very good&quot;&gt;params&lt;/router-link&gt; |
</code></pre></li>
</ul>
<p>我们已经实现了以url方式进行传值，这在实际开发中经常使用，必须完全了解。我希望你看完视频后或者学完文章后能多练习两边，并在实际项目中充分使用。</p>
<h2 id="正则表达式在URL传值中的应用"><a href="#正则表达式在URL传值中的应用" class="headerlink" title="正则表达式在URL传值中的应用"></a>正则表达式在URL传值中的应用</h2><p>上边的例子，我们传递了新闻编号，现在需求升级了，我们希望我们传递的新闻ID只能是数字的形式，这时候我们就需要在传递时有个基本的类型判断，vue是支持正则的。</p>
<p>加入正则需要在路由配置文件里（/src/router/index.js）以圆括号的形式加入。</p>
<pre><code>path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;,
</code></pre><p>加入了正则，我们再传递数字之外的其他参数，params.vue组件就没有办法接收到。</p>
<p>#第6节 ：vue-router 的重定向-redirect</p>
<p>开发中有时候我们虽然设置的路径不一致，但是我们希望跳转到同一个页面，或者说是打开同一个组件。这时候我们就用到了路由的重新定向redirect参数。</p>
<h2 id="redirect基本重定向"><a href="#redirect基本重定向" class="headerlink" title="redirect基本重定向"></a>redirect基本重定向</h2><p>我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。</p>
<pre><code>export default new Router({
  routes: [
    {
      path: &apos;/&apos;,
      component: Hello
    },{
      path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;,
      component:Params
    },{
      path:&apos;/goback&apos;,
      redirect:&apos;/&apos;
    }

  ]
})
</code></pre><p>这里我们设置了goback路由，但是它并没有配置任何component（组件），而是直接redirect到path:’/’下了，这就是一个简单的重新定向。</p>
<h2 id="重定向时传递参数"><a href="#重定向时传递参数" class="headerlink" title="重定向时传递参数"></a>重定向时传递参数</h2><p>我们已经学会了通过url来传递参数，那我们重定向时如果也需要传递参数怎么办？其实vue也已经为我们设置好了，我们只需要在ridirect后边的参数里复制重定向路径的path参数就可以了。可能你看的有点晕，我们来看一段代码：</p>
<pre><code>{
  path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;,
  component:Params
},{
  path:&apos;/goParams/:newsId(\\d+)/:newsTitle&apos;,
  redirect:&apos;/params/:newsId(\\d+)/:newsTitle&apos;
}
</code></pre><p>已经有了一个params路由配置，我们在设置一个goParams的路由重定向，并传递了参数。这时候我们的路由参数就可以传递给params.vue组件了。参数接收方法和正常的路由接收方法一样。</p>
<h1 id="第7节：alias别名的使用"><a href="#第7节：alias别名的使用" class="headerlink" title="第7节：alias别名的使用"></a>第7节：alias别名的使用</h1><p>上节学习了路由的重定向，我相信大家已经可以熟练使用redirect进行重定向了。使用alias别名的形式，我们也可以实现类似重定向的效果。</p>
<ul>
<li>1.首先我们在路由配置文件里（/src/router/index.js），给上节课的Home路径起一个别名，jspang。</li>
</ul>
<pre><code>{
    path: &apos;/hi1&apos;,
    component: Hi1,
    alias:&apos;/jspang&apos;
 }
</code></pre><ul>
<li>2.配置我们的<router-link>，起过别名之后，可以直接使用<router-link>标签里的to属性，进行重新定向。</router-link></router-link></li>
</ul>
<pre><code>&lt;router-link to=&quot;/jspang&quot;&gt;jspang&lt;/router-link&gt;
</code></pre><p><strong>redirect和alias的区别</strong></p>
<p>redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。</p>
<p>alias：URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了<router-view>中的内容。</router-view></p>
<h3 id="填个小坑："><a href="#填个小坑：" class="headerlink" title="填个小坑："></a>填个小坑：</h3><p>别名请不要用在path为’/’中，如下代码的别名是不起作用的。</p>
<pre><code>{
  path: &apos;/&apos;,
  component: Hello,
  alias:&apos;/home&apos;
}
</code></pre><p>在实际项目中我们遇到了这样的坑，开始以为是自己的代码写的有问题，找了两个小时作用。后来发现不是代码问题，只是vue不支持这样使用。我们犯过错误，踩过了坑，希望大家就不要踩了。</p>
<h1 id="第8节：路由的过渡动画"><a href="#第8节：路由的过渡动画" class="headerlink" title="第8节：路由的过渡动画"></a>第8节：路由的过渡动画</h1><p>在开发中有一种需求叫高端、大气、上档次。所以作为一个大前端有责任让你的程序开起来更酷炫。可以在页面切换时我们加入一些动画效果，提升我们程序的动效设计。这节课我们就学习一下路由的过渡动画效果制作</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a><transition>标签</transition></h2><p>想让路由有过渡动画，需要在<router-view>标签的外部添加<transition>标签，标签还需要一个name属性。</transition></router-view></p>
<pre><code>&lt;transition name=&quot;fade&quot;&gt;
  &lt;router-view &gt;&lt;/router-view&gt;
&lt;/transition&gt;
</code></pre><p>我们在/src/App.vue文件里添加了<transition>标签，并给标签起了一个名字叫fade。</transition></p>
<h2 id="css过渡类名："><a href="#css过渡类名：" class="headerlink" title="css过渡类名："></a>css过渡类名：</h2><p>组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名：</p>
<ul>
<li>fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。</li>
</ul>
<ul>
<li>fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。</li>
</ul>
<ul>
<li>fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。</li>
</ul>
<ul>
<li>fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。</li>
</ul>
<p>从上面四个类名可以看出，fade-enter-active和<br>fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。</p>
<p>那我们就在App.vue页面里加入四种CSS样式效果，并利用CSS3的transition属性控制动画的具体效果。代码如下：</p>
<pre><code>.fade-enter {
  opacity:0;
}
.fade-leave{
  opacity:1;
}
.fade-enter-active{
  transition:opacity .5s;
}
.fade-leave-active{
  opacity:0;
  transition:opacity .5s;
}
</code></pre><p>上边的代码设置了改变透明度的动画过渡效果，但是默认的mode模式in-out模式，这并不是我们想要的。下面我们学一下mode模式。</p>
<h2 id="过渡模式mode："><a href="#过渡模式mode：" class="headerlink" title="过渡模式mode："></a>过渡模式mode：</h2><ul>
<li>in-out:新元素先进入过渡，完成之后当前元素过渡离开。</li>
</ul>
<ul>
<li>out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。</li>
</ul>
<p>这节课只能算是一个简单的过渡入门，教会大家原理，如果想做出实用酷炫的过渡效果，你需要有较强的动画制作能力，我们下节课继续学习动画的知识。</p>
<h1 id="第9节：mode的设置和404页面的处理"><a href="#第9节：mode的设置和404页面的处理" class="headerlink" title="第9节：mode的设置和404页面的处理"></a>第9节：mode的设置和404页面的处理</h1><p>在学习过渡效果的时候，我们学了mode的设置，但是在路由的属性中还有一个mode。这节课我们就学习一下另一个mode模式和404页面的设置。</p>
<h2 id="mode的两个值"><a href="#mode的两个值" class="headerlink" title="mode的两个值"></a>mode的两个值</h2><ul>
<li>histroy:当你使用 history 模式时，URL 就像正常的 url，例如 <a href="http://jsapng.com/lms/，也好看！" target="_blank" rel="external">http://jsapng.com/lms/，也好看！</a></li>
</ul>
<ul>
<li>hash:默认’hash’值，但是hash看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。</li>
</ul>
<p>具体的效果我在视频中会有所掩饰，不理解的小伙伴可以到视频中进行查看。</p>
<h2 id="404页面的设置："><a href="#404页面的设置：" class="headerlink" title="404页面的设置："></a>404页面的设置：</h2><p>用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。vue-router也为我们提供了这样的机制.</p>
<ul>
<li>1.设置我们的路由配置文件（/src/router/index.js）：</li>
</ul>
<pre><code>{
   path:&apos;*&apos;,
   component:Error
}
</code></pre><p>这里的path:’*’就是找不到页面时的配置，component是我们新建的一个Error.vue的文件。</p>
<ul>
<li>2.新建404页面：</li>
</ul>
<p>在/src/components/文件夹下新建一个Error.vue的文件。简单输入一些有关错误页面的内容。</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;{{ msg }}&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data () {
    return {
      msg: &apos;Error:404&apos;
    }
  }
}
&lt;/script&gt;
</code></pre><ul>
<li>3.我们在用<router-link>瞎写一个标签的路径。</router-link></li>
</ul>
<pre><code>&lt;router-link to=&quot;/bbbbbb&quot;&gt;我是瞎写的&lt;/router-link&gt; |
</code></pre><p>预览一下我们现在的结果，就已经实现404页面的效果。</p>
<h1 id="第10节：路由中的钩子"><a href="#第10节：路由中的钩子" class="headerlink" title="第10节：路由中的钩子"></a>第10节：路由中的钩子</h1><p>我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节课就介绍这两种钩子函数的写法。</p>
<h2 id="路由配置文件中的钩子函数"><a href="#路由配置文件中的钩子函数" class="headerlink" title="路由配置文件中的钩子函数"></a>路由配置文件中的钩子函数</h2><p>我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节课就介绍这两种钩子函数的写法。</p>
<h2 id="路由配置文件中的钩子函数-1"><a href="#路由配置文件中的钩子函数-1" class="headerlink" title="路由配置文件中的钩子函数"></a>路由配置文件中的钩子函数</h2><p>我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。先来看一段具体的代码：</p>
<pre><code>{
      path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;,
      component:Params,
      beforeEnter:(to,from,next)=&gt;{
        console.log(&apos;我进入了params模板&apos;);
        console.log(to);
        console.log(from);
        next();
},
</code></pre><p>我们在params路由里配置了bdforeEnter得钩子函数，函数我们采用了ES6的箭头函数，需要传递三个参数。我们并在箭头函数中打印了to和from函数。具体打印内容可以在控制台查看object。</p>
<p>三个参数：</p>
<ul>
<li>to:路由将要跳转的路径信息，信息是包含在对像里边的。</li>
</ul>
<ul>
<li>from:路径跳转前的路径信息，也是一个对象的形式。</li>
</ul>
<ul>
<li>next:路由的控制参数，常用的有next(true)和next(false)。</li>
</ul>
<h2 id="写在模板中的钩子函数"><a href="#写在模板中的钩子函数" class="headerlink" title="写在模板中的钩子函数"></a>写在模板中的钩子函数</h2><p>在配置文件中的钩子函数，只有一个钩子-beforeEnter，如果我们写在模板中就可以有两个钩子函数可以使用：</p>
<ul>
<li>beforeRouteEnter：在路由进入前的钩子函数。</li>
</ul>
<ul>
<li><p>beforeRouteLeave：在路由离开前的钩子函数。</p>
<pre><code>export default {
  name: &apos;params&apos;,
  data () {
    return {
      msg: &apos;params page&apos;
    }
  },
  beforeRouteEnter:(to,from,next)=&gt;{
    console.log(&quot;准备进入路由模板&quot;);
    next();
  },
  beforeRouteLeave: (to, from, next) =&gt; {
    console.log(&quot;准备离开路由模板&quot;);
    next();
  }
}
&lt;/script&gt;
</code></pre></li>
</ul>
<p>这是我们写在params.vue模板里的路由钩子函数。它可以监控到路由的进入和路由的离开，也可以轻易的读出to和from的值。</p>
<h1 id="第11节：编程式导航"><a href="#第11节：编程式导航" class="headerlink" title="第11节：编程式导航"></a>第11节：编程式导航</h1><p>这是这篇文章的最后一节，前10节课的导航都是用<router-link>标签或者直接操作地址栏的形式完成的，那如果在业务逻辑代码中需要跳转页面我们如何操作？这就是我们要说的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。</router-link></p>
<h2 id="this-router-go-1-和-this-router-go-1"><a href="#this-router-go-1-和-this-router-go-1" class="headerlink" title="this.$router.go(-1) 和 this.$router.go(1)"></a>this.$router.go(-1) 和 this.$router.go(1)</h2><p>这两个编程式导航的意思是后退和前进，功能跟我们浏览器上的后退和前进按钮一样，这在业务逻辑中经常用到。比如条件不满足时，我们需要后退。</p>
<p>router.go(-1)代表着后退，我们可以让我们的导航进行后退，并且我们的地址栏也是有所变化的。</p>
<ul>
<li><p>1.我们先在app.vue文件里加入一个按钮，按钮并绑定一个goback( )方法。</p>
<pre><code>&lt;button @click=&quot;goback&quot;&gt;后退&lt;/button&gt;
</code></pre></li>
<li><p>2.在我们的script模块中写入goback()方法，并使用this.$router.go(-1),进行后退操作。</p>
<pre><code>&lt;script&gt;
export default {
  name: &apos;app&apos;,
  methods:{
    goback(){
      this.$router.go(-1);
    }
  }
}
&lt;/script&gt;
</code></pre></li>
</ul>
<p>打开浏览器进行预览，这时我们的后退按钮就可以向以前的网页一样后退了。</p>
<p>router.go(1):代表着前进，用法和后退一样，我在这里就不重复码字了（码字辛苦希望大家理解）。</p>
<h2 id="this-router-push-‘-xxx-‘"><a href="#this-router-push-‘-xxx-‘" class="headerlink" title="this.$router.push(‘/xxx ‘)"></a>this.$router.push(‘/xxx ‘)</h2><p>这个编程式导航都作用就是跳转，比如我们判断用户名和密码正确时，需要跳转到用户中心页面或者首页，都用到这个编程的方法来操作路由。</p>
<p>我们设置一个按钮，点击按钮后回到站点首页。</p>
<ul>
<li><p>1.先编写一个按钮，在按钮上绑定goHome( )方法。</p>
<pre><code>&lt;button @click=&quot;goHome&quot;&gt;回到首页&lt;/button&gt;
</code></pre></li>
</ul>
<ul>
<li><p>2.在<script>模块里加入goHome方法，并用this.$router.push(‘/’)导航到首页</p>
<pre><code>export default {
  name: &apos;app&apos;,
  methods:{
    goback(){
      this.$router.go(-1);
    },
    goHome(){
      this.$router.push(&apos;/&apos;);
    }
  }
}
</code></pre></li>
</ul>
</script></p></li></ul>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/person.jpg"
               alt="ZhangWei2222" />
          <p class="site-author-name" itemprop="name">ZhangWei2222</p>
           
              <p class="site-description motion-element" itemprop="description">Dream high</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangWei2222</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
