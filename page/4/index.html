<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="Dream high">
<meta property="og:type" content="website">
<meta property="og:title" content="ZhangWei2222">
<meta property="og:url" content="http://super-wei.xyz/page/4/index.html">
<meta property="og:site_name" content="ZhangWei2222">
<meta property="og:description" content="Dream high">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZhangWei2222">
<meta name="twitter:description" content="Dream high">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://super-wei.xyz/page/4/"/>





  <title>ZhangWei2222</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhangWei2222</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/21/hexo搭建个人博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/21/hexo搭建个人博客/" itemprop="url">hexo搭建个人博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-21T18:38:55+08:00">
                2017-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-安装Git-Bash"><a href="#1-安装Git-Bash" class="headerlink" title="1. 安装Git Bash"></a>1. 安装Git Bash</h3><p>我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。</p>
<ul>
<li><p>下载地址<a href="https://git-for-windows.github.io/" target="_blank" rel="external">https://git-for-windows.github.io/</a></p>
</li>
<li><p>安装步骤：双击下载好的exe文件，一路next就好啦</p>
</li>
<li>安装好后，打开gitbash，查看版本：</li>
</ul>
<pre><code>- 命令：git version 
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821184316.png" alt=""></p>
<ul>
<li>然后你就可以在这里发挥你的聪明才智了</li>
</ul>
<h3 id="2-安装NodeJs"><a href="#2-安装NodeJs" class="headerlink" title="2. 安装NodeJs"></a>2. 安装NodeJs</h3><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧</p>
<ul>
<li>下载地址<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a>(说明：LTS为长期支持版，Current为当前最新版)</li>
</ul>
<ul>
<li>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</li>
</ul>
<ul>
<li>查看版本：<ul>
<li>命令：node -v</li>
</ul>
</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821184437.png" alt=""></p>
<ul>
<li>又到自由发挥的时候了</li>
</ul>
<h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h3><p>看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。</p>
<ul>
<li>先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。</li>
</ul>
<ul>
<li>安装hexo命令：npm i -g hexo</li>
</ul>
<ul>
<li>安装完成后，查看版本：</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821184512.png" alt=""></p>
<ul>
<li>初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件：</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821184526.png" alt=""></p>
<ul>
<li>解释一下：</li>
</ul>
<pre><code>- node_modules：是依赖包


- public：存放的是生成的页面


- scaffolds：命令生成文章等的模板


- source：用命令创建的各种文章


- themes：主题


- _config.yml：整个博客的配置

- db.json：source解析所得到的


- package.json：项目所需模块项目的配置信息
</code></pre><ul>
<li>做好这些前置工作之后接下来的就是各种配配配置了。</li>
</ul>
<h3 id="4-搭桥到github"><a href="#4-搭桥到github" class="headerlink" title="4. 搭桥到github"></a>4. 搭桥到github</h3><ul>
<li>没账号的创建账号，有账号的看下面。</li>
</ul>
<pre><code>- 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下：
</code></pre><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821184628.png" alt=""></p>
<ul>
<li>回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）：</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821184703.png" alt=""></p>
<ul>
<li>创建SSH<br>在gitbash中输入：ssh-keygen -t rsa -C “youremail@example.com，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821184708.png" alt=""></p>
<ul>
<li>将上面获取的ssh放到github中：</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821184727.png" alt=""></p>
<ul>
<li>添加一个 New SSH key ，title随便取，key就填刚刚那一段。</li>
</ul>
<ul>
<li>在gitbash中验证是否添加成功：ssh -T git@github.com</li>
</ul>
<ul>
<li>完成下一步你就成功啦！</li>
</ul>
<h3 id="5-一步之遥"><a href="#5-一步之遥" class="headerlink" title="5. 一步之遥"></a>5. 一步之遥</h3><ul>
<li><p>用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)：</p>
<pre><code>deploy:
  type: git
  repo: https://github.com/YourgithubName/YourgithubName.github.io.git
  branch: master
</code></pre></li>
</ul>
<ul>
<li><p>回到gitbash中，进入你的blog目录，分别执行以下命令：</p>
<pre><code>hexo clean
hexo generate
hexo server
</code></pre></li>
</ul>
<p>注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。</p>
<ul>
<li>打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></li>
</ul>
<ul>
<li>接着你就可以遇见天使的微笑了~</li>
</ul>
<h3 id="6-上传到github"><a href="#6-上传到github" class="headerlink" title="6. 上传到github"></a>6. 上传到github</h3><ul>
<li>先安装一波：npm install hexo-deployer-git –save（这样才能将你写好的文章部署到github服务器上并让别人浏览到）</li>
</ul>
<ul>
<li><p>执行命令(建议每次都按照如下步骤部署)：</p>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre><p>注意deploy的过程中要输入你的username及passward。如下：</p>
</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821185032.png" alt=""></p>
<ul>
<li>在浏览器中输入<a href="http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！" target="_blank" rel="external">http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！</a></li>
</ul>
<ul>
<li>感觉gitbash中东西太多的时候输入clear命令清空。</li>
</ul>
<h3 id="7-绑定个人域名"><a href="#7-绑定个人域名" class="headerlink" title="7. 绑定个人域名"></a>7. 绑定个人域名</h3><ul>
<li>登录进入万网的域名控制台，点击”域名和网站”中的”云DNS”</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/898529-20170111145433135-704685146.png" alt=""></p>
<ul>
<li>点击对应域名的”解析”</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/898529-20170111155446931-105689503.png" alt=""></p>
<ul>
<li>点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是whitescholars.github.io。</li>
</ul>
<p><img src="http://oncweb6po.bkt.clouddn.com/898529-20170111155934166-1006871703%20%281%29.png" alt=""></p>
<p>这些全部设置完成后，此时你并不能要申请的域名访问你的博客。</p>
<ul>
<li>接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：penglei.com。</li>
</ul>
<p>运行hexo指令使配置修改起效：</p>
<pre><code>hexo g  //会在public中生成一个GNAME文件
hexo d  //修改内容提交到github博客上
</code></pre><ul>
<li>域名绑定：</li>
</ul>
<p>这是比较重要的一步，打开博客在Github中的地址，然后切换到 Settings页，设置Custom domain内容为我们自己的域名值（例如：我的域名是linshuhe.tech），点击Save按钮保存</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170821190613.png" alt=""></p>
<p>实践证明如果此时你填写的是www.penglei.top那么以后你只能用www.penglei.top访问，而如果你填写的是penglei.top。那么用www.penglei.top和penglei.top访问都是可以的。重新清理hexo,并发布即可用新的域名访问。</p>
<p><strong>搭建完成访问出现404 可能的原因是：</strong></p>
<ol>
<li>绑定了个人域名，但是域名解析错误。</li>
<li>域名解析正确但你的域名是通过国内注册商注册的，你的域名因没有实名制而无法访问。</li>
<li>你认为配置没有问题，那么可能只是你的浏览器在捣鬼，可尝试清除浏览器缓存再访问或者换个浏览器访问。</li>
<li>也有可能是你的路由器缓存导致的错觉，所以也可以尝试换个局域网访问你的网站。</li>
<li>最有可能的原因是你下载的hexo有问题，导致所有的东西都上传到了github,而导致index页面在主域名的下一级目录。你可以尝试查看上传的内容，找到index页面，在域名后面添加下一级目录。若能访问index页面（此时样式可能是乱的），则证明是hexo安装有问题，笔者当时遇到的就是这个问题。可卸载重新安装。</li>
</ol>
<ul>
<li>注：1，2默认你的CNAME文件配置没有问题，如果没有绑定个人域名，则不需要CNAME文件。</li>
</ul>
<h3 id="8-修改主题"><a href="#8-修改主题" class="headerlink" title="8.修改主题"></a>8.修改主题</h3><ul>
<li>下载主题到theme</li>
<li>站点配置文件中(根目录下的_config.yml)，把theme改成对应的名字</li>
<li>hexo clean </li>
<li>hexo g &amp;&amp; hexo d</li>
</ul>
<h4 id="如何配置标签？"><a href="#如何配置标签？" class="headerlink" title="如何配置标签？"></a>如何配置标签？</h4><pre><code>title: 标签测试文章
tags:
  - Testing
  - Another Tag
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/懒加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/懒加载/" itemprop="url">懒加载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:30:27+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-后台分页（异步）"><a href="#1-后台分页（异步）" class="headerlink" title="1.后台分页（异步）"></a>1.后台分页（异步）</h1><p>jq Ajax</p>
<pre><code>$(document).ready(function () {
  $.ajax({
    url: url, //必需。规定把请求发送到哪个 URL
    type: &apos;GET&apos;,  //提交类型：GET POST
    dataType: &apos;dataType&apos;,  //可选。规定预期的服务器响应的数据类型。默认执行智能判断（xml、json、script 或 html）。
    data:data,  //可选。规定连同请求发送到服务器的数据。
    success: function (data) {


    },

    error: function (error) {
          alert(error);
    }

  });
})
</code></pre><blockquote>
<p>他那边的数据是一个个写好了的（比如page=1），比如一个页面20个图片，然后第一页就是20个图片地址，我们传入地址url（url+page=1）获取里面的图片地址，再把原来div中的图片地址用js替换（像推书那样）。</p>
</blockquote>
<h1 id="2-js实现加载"><a href="#2-js实现加载" class="headerlink" title="2.js实现加载"></a>2.js实现加载</h1><blockquote>
<p>首先，在页面中准备一个id为div1的div,在这个div中放一个ul,ul中准备了一些li,然而这些li都有一个data-src的属性，准备着图片的地址，具体结构如下：</p>
</blockquote>
<pre><code>&lt;div id=&quot;div1&quot;&gt;
    &lt;ul&gt;
        &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt;
        &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt;
        &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt;
        &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt;
        &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><blockquote>
<p>图片的动态加载就是通过读取li元素，然后获得li元素的data-src属性的值赋予动态创建的图片的src，从而实现了图片的创建。</p>
</blockquote>
<pre><code>function setImg(index){
                var oDiv=document.getElementById(&quot;div1&quot;)
                var oUl=oDiv.children[0];
                var aLi=oUl.children;
                if (aLi[index].dataset) {
                    var src=aLi[index].dataset.src;
                } else{
                    var src=aLi[index].getAttribute(&apos;data-src&apos;);
                }
                var oImg=document.createElement(&apos;img&apos;);
                oImg.src=src;
                if (aLi[index].children.length==0) {
                    aLi[index].appendChild(oImg); 
                }
            }
</code></pre><blockquote>
<p>那么怎么识别是否在可视区域呢？这里需要一个函数，能够实现获得当前元素距离网页顶部的距离！</p>
</blockquote>
<pre><code>//获得对象距离页面顶端的距离  
function getH(obj) {  
    var h = 0;  
    while (obj != window.document.body&amp;&amp;obj != null) {  
        h += obj.offsetTop;  
        obj = obj.offsetParent;  
    }  
    return h;  
}  //就是沿着dom树一层层往上找，把相对于offsetParent的偏移累加，直到body，这样就可以得到当前元素相对于顶端的偏移量。
</code></pre><blockquote>
<p>当网页的滚动条滚动时要时时判断当前li的位置！</p>
</blockquote>
<pre><code>window.onscroll = function () {
    var oDiv = document.getElementById(&apos;div1&apos;);
    var oUl = oDiv.children[0];
    var aLi = oUl.children;

    for (var i = 0, l = aLi.length; i &lt; l; i++) {
        var oLi = aLi[i];
        //检查oLi是否在可视区域
        var t = document.documentElement.clientHeight + (document.documentElement.scrollTop || document.body.scrollTop);
        var h = getH(oLi);
        if (h &lt; t) {
            setTimeout(&quot;setImg(&quot; + i + &quot;)&quot;, 500);
        }
    }
}; // document.documentElement.clientHeight ==&gt; 可见区域高度
</code></pre><blockquote>
<p>当页面加载完成以后要主动运行一下window.onscroll，从而获得当前可视范围内的图片</p>
<p>另外，像这样的页面，障眼法和美化都是必须的，比如给每个li一个loading的图片作为背景，从而实现了当前图片正在加载的效果，美化工作就是做好合理的布局。</p>
</blockquote>
<pre><code>* {
    margin: 0;
    padding: 0;
}

#div1 {
    width: 520px;
    margin: 30px auto;
    border: 1px solid red;
    overflow: hidden;
}

li {
    width: 160px;
    height: 160px;
    float: left;
    list-style: none;
    margin: 5px;
    background: url(loading.gif) center center no-repeat;
    border: 1px dashed green;
}
img{
width:100%
}
</code></pre><blockquote>
<p>data- ,可以设置我们需要的自定义属性。如果想获取某个属性的值：</p>
</blockquote>
<pre><code>如 data-src:dataset.src
注意：带连字符连接的名称在使用的时候需要命名驼峰化： data-meal-time ：dataset.mealTime
</code></pre><h1 id="3-jq插件-lazyload"><a href="#3-jq插件-lazyload" class="headerlink" title="3.jq插件 lazyload"></a>3.jq插件 lazyload</h1><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><p>引用jquery和jquery.lazyload.js到你的页面</p>
 <script src="jquery-1.11.0.min.js"></script>
 <script src="jquery.lazyload.js?v=1.9.1"></script>
</li>
<li><p>为图片加入样式lazy  图片路径引用方法用data-original</p>
<p> <img class="lazy" data-original="img/bmw_m1_hood.jpg"><br> <img class="lazy" data-original="img/bmw_m1_side.jpg"><br> <img class="lazy" data-original="img/viper_1.jpg"><br> <img class="lazy" data-original="img/viper_corner.jpg"><br> <img class="lazy" data-original="img/bmw_m3_gt.jpg"><br> <img class="lazy" data-original="img/corvette_pitstop.jpg"></p>
</li>
<li><p>js出始化lazyload并设置图片显示方式</p>
 <script type="text/javascript" charset="utf-8">
   $(function() {
       $("img.lazy").lazyload({effect: "fadeIn"});
   });
 </script>

</li>
</ol>
<p>在图片中也可以不使用 class=”lazy”，初始化时使用：</p>
<pre><code>$(&quot;img&quot;).lazyload({effect: &quot;fadeIn&quot;});
</code></pre><p>这样就可以对全局的图片都有效！</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre><code>$(&quot;img.lazy&quot;).lazyload({
  placeholder : &quot;img/grey.gif&quot;, //用图片提前占位
    // placeholder,值为某一图片路径.此图片用来占据将要加载的图片的位置,待图片加载时,占位图则会隐藏
  effect: &quot;fadeIn&quot;, // 载入使用何种效果
    // effect(特效),值有show(直接显示),fadeIn(淡入),slideDown(下拉)等,常用fadeIn
  threshold: 200, // 提前开始加载
    // threshold,值为数字,代表页面高度.如设置为200,表示滚动条在离目标位置还有200的高度时就开始加载图片,可以做到不让用户察觉
  event: &apos;click&apos;,  // 事件触发时才加载
    // event,值有click(点击),mouseover(鼠标划过),sporty(运动的),foobar(…).可以实现鼠标莫过或点击图片才开始加载,后两个值未测试…
  container: $(&quot;#container&quot;),  // 对某容器中的图片实现效果
    // container,值为某容器.lazyload默认在拉动浏览器滚动条时生效,这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片
  failurelimit : 10 // 图片排序混乱时
     // failurelimit,值为数字.lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况,failurelimit意在加载N张可见区域外的图片,以避免出现这个问题.
});
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/三种居中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/三种居中/" itemprop="url">三种居中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:28:59+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、垂直居中"><a href="#一、垂直居中" class="headerlink" title="一、垂直居中"></a>一、垂直居中</h1><h2 id="用绝对定位实现垂直居中"><a href="#用绝对定位实现垂直居中" class="headerlink" title="用绝对定位实现垂直居中"></a>用绝对定位实现垂直居中</h2><p>1.创建一个div包裹图片</p>
<p>2.对父元素添加</p>
<pre><code>position: relative;
</code></pre><p>3.对子元素添加</p>
<pre><code>position: absolute;
  top: 50%;
  margin-top: -50px; /* half the size of image */
</code></pre><h2 id="利用Display-table-来实现垂直居中"><a href="#利用Display-table-来实现垂直居中" class="headerlink" title="利用Display: table;来实现垂直居中"></a>利用Display: table;来实现垂直居中</h2><p>1.创建一个div元素以及另外一个包含图片的div元素</p>
<p>2.为父元素设置 display 为table</p>
<p>3.把包裹图片的那个div元素的display属性设置为table-cell。为了垂直居中，给包裹图片的div元素设置vertical-align: middle;属性。</p>
<h2 id="使用flex实现垂直居中（IE8-IE9不支持）"><a href="#使用flex实现垂直居中（IE8-IE9不支持）" class="headerlink" title="使用flex实现垂直居中（IE8 IE9不支持）"></a>使用flex实现垂直居中（IE8 IE9不支持）</h2><p>1.创建一个包裹着图片的div元素</p>
<p>2.把div元素的display属性设置为flex</p>
<p>3.div添加另外一条属性align-items: center;</p>
<h1 id="二、水平居中"><a href="#二、水平居中" class="headerlink" title="二、水平居中"></a>二、水平居中</h1><h2 id="采用margin的方法实现水平居中"><a href="#采用margin的方法实现水平居中" class="headerlink" title="采用margin的方法实现水平居中"></a>采用margin的方法实现水平居中</h2><pre><code>margin： 0 auto;
</code></pre><p>需要满足三个条件：</p>
<p>1.元素定宽</p>
<p>2.元素为块级元素或行内元素设置 display:block</p>
<p>3.元素的margin-left 和margin-right 都必须设置为auto</p>
<h2 id="以文本对齐实现水平居中"><a href="#以文本对齐实现水平居中" class="headerlink" title="以文本对齐实现水平居中"></a>以文本对齐实现水平居中</h2><pre><code>父级元素设置 text-align:center;
子元素设置为内嵌块元素 display:inline-block;
</code></pre><p>使用于文本/内嵌块元素，所要居中的所有元素的父级应该是“块”或“内嵌块”级元素</p>
<p>对于单行文字来说，直接使用text-align: center即可。</p>
<p>多行文字可以看作一个块级元素参考margin法和定位法。</p>
<h2 id="定位法"><a href="#定位法" class="headerlink" title="定位法"></a>定位法</h2><p>父级：relative</p>
<p>子级：<br>position：absolute;<br>left:50%;<br>magin-left: -自己宽度的一半；</p>
<p>三个条件：</p>
<p>1.元素定宽</p>
<p>2.元素绝对定位，并设置left:50%</p>
<p>3.元素负左边距margin-left为宽度的一半</p>
<p>如果不定宽，此时需要用到<strong>css3中的transform属性中的translate</strong>，可以使元素移动时相对于自身的宽度和高度。<strong>需要注意</strong>，这种方法需要IE9+才可以实现。</p>
<h1 id="三、绝对垂直居中"><a href="#三、绝对垂直居中" class="headerlink" title="三、绝对垂直居中"></a>三、绝对垂直居中</h1><h2 id="绝对垂直居中"><a href="#绝对垂直居中" class="headerlink" title="绝对垂直居中"></a>绝对垂直居中</h2><p>父级：relative</p>
<p>子级：</p>
<pre><code>position: absolute;
top: 0;
right: 0;
bottom: 0;
left: 0;
margin: auto;
</code></pre><h2 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h2><ol>
<li><p>块级</p>
<p> .md-warp{</p>
<pre><code>display:flex;
</code></pre><p> }<br> .md-main{</p>
<pre><code>margin: auto;
</code></pre><p> }</p>
</li>
<li><p>文字</p>
<p> .md-warp{</p>
<pre><code>display:flex;
</code></pre><p> }<br> .md-main{</p>
<pre><code>display: flex;
</code></pre><p>   align-items: center;<br>   justify-content: center;</p>
<pre><code>margin: auto;
</code></pre><p> }</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/滚动事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/滚动事件/" itemprop="url">滚动事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:28:36+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>实现滚动超过一定高度，出现图标，点击回到顶部</p>
<ol>
<li><p>window.onscroll函数，获取document.body.scrollTop即滚动条高度，当滚动条高度超过特定高度，小图标显示，否则隐藏（一定要设置else)</p>
<pre><code>window.onscroll = function(){
    var top = document.body.scrollTop;
    var triangle = document.getElementById(&apos;triangle bottom&apos;);
    if( top &gt;500 ){
        triangle.style.display = &apos;block&apos;;
    }else{
        triangle.style.display = &apos;none&apos;;
    }
}
</code></pre></li>
<li>点击盒子，window.scroll(0,0)  回到顶端</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/常用网页进度条/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/常用网页进度条/" itemprop="url">常用网页进度条</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:27:58+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;div class = &quot;loading&quot;&gt; //覆盖层
    &lt;div class = &quot;pic&quot;&gt; //loading图片/动画
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><h1 id="一、用定时器的方法实现加载"><a href="#一、用定时器的方法实现加载" class="headerlink" title="一、用定时器的方法实现加载"></a>一、用定时器的方法实现加载</h1><pre><code>$(function(){
    setInterval(function(){
        $(&quot;.loading&quot;).fadeOut();
    },3000)
})
</code></pre><p>获取loading图片的网站：<a href="https://preloaders.net/" target="_blank" rel="external">https://preloaders.net/</a></p>
<h1 id="二、通过加载状态事件实现加载"><a href="#二、通过加载状态事件实现加载" class="headerlink" title="二、通过加载状态事件实现加载"></a>二、通过加载状态事件实现加载</h1><pre><code>document.onreadystatechange = function(){
    if(document.readyState == &quot;complete&quot;){
        $(&quot;.loading&quot;).fadeOut();
    }
}
</code></pre><p>document.onreadystatechange 页面加载状态改变时的事件</p>
<p>document.readyState 返回当前文档的状态</p>
<ol>
<li>uninitialized 还未开始载入</li>
<li>loading 载入中</li>
<li>interactive 已加载，文档与用户可以开始交互</li>
<li>complete 载入完成</li>
</ol>
<h1 id="三、css3进度条小动画"><a href="#三、css3进度条小动画" class="headerlink" title="三、css3进度条小动画"></a>三、css3进度条小动画</h1><p>主要依靠 transform,animation,@keyframes实现</p>
<p>可以将代码兼容的网站：<a href="http://autoprefixer.github.io/" target="_blank" rel="external">http://autoprefixer.github.io/</a></p>
<p>loading动画直接生成css的网站:<a href="https://loading.io/" target="_blank" rel="external">https://loading.io/</a></p>
<h1 id="四、定位在头部的加载"><a href="#四、定位在头部的加载" class="headerlink" title="四、定位在头部的加载"></a>四、定位在头部的加载</h1><p>通过向特定的一段html后面加入</p>
<pre><code>&lt;script&gt;
    $(&quot;.loading .pic&quot;).animate({width:&quot;30%&quot;},100)
&lt;/script&gt;
</code></pre><p>最后</p>
<pre><code>$(&quot;.loading .pic&quot;).animate({width:&quot;100%&quot;},100,function(){
    $(&quot;.loading&quot;).fadeOut();
})
</code></pre><h1 id="五、实时获取加载数据的进度条"><a href="#五、实时获取加载数据的进度条" class="headerlink" title="五、实时获取加载数据的进度条"></a>五、实时获取加载数据的进度条</h1><pre><code>$(function(){
    var img = $(&quot;img&quot;);
    var num = 0;

    img.each(function(i){
        var oImg = new Image(); //建立图像对象

        oImg.onload = function(){
            oImg.onload = null;
            num++;
            $(&quot;.loading b&quot;).html(parseInt(num/$(&quot;img&quot;).size()*100)+&quot;%&quot;);
            if(num&gt;=i){
                $(&quot;.loading&quot;).fadeOut();
            }
        }
        oImg.src = img[i].src; //src属性一定要写到onload的后面，否则程序在IE中会出错
    });
})
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/webpack/" itemprop="url">webpack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:27:27+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、Hello-Webpack"><a href="#一、Hello-Webpack" class="headerlink" title="一、Hello Webpack"></a>一、Hello Webpack</h1><h3 id="1-webpack介绍"><a href="#1-webpack介绍" class="headerlink" title="1.webpack介绍"></a>1.webpack介绍</h3><p>webpack是一个现代的JavaScript应用模块打包器（module bundler），它能把各种资源，例如JS（含JSX）、coffee、样式（less/sass）、图片等都作为模块来处理和使用。它有着难以置信的配置和神奇的效果，大大提高了我们程序员的工作效率。举个例子：我们可以直接使用require（xxx）的形式来引入各模块，即使他们可能需要经过编译（比如JSX和sass），但我们无须再上面花费太多心思，webpack有着各种健全的加载器（loader）在默默处理这些事情。它可以部分代替Grunt和gulp的功能。</p>
<h3 id="2-webpack的安装"><a href="#2-webpack的安装" class="headerlink" title="2.webpack的安装"></a>2.webpack的安装</h3><ol>
<li><p>全局安装</p>
<pre><code>$npm install webpack -g
</code></pre></li>
<li><p>直接安装到项目的依赖里，也就是写入package.json</p>
<p> npm init<br> npm install webpack –save-dev</p>
</li>
</ol>
<h3 id="3-配置文件webpack-config-js"><a href="#3-配置文件webpack-config-js" class="headerlink" title="3.配置文件webpack.config.js"></a>3.配置文件webpack.config.js</h3><p>重点:什么是入口文件？模块打包的起点称之为入口起点（entry point）。入口起点告诉webpack从哪里开始，并遵循着依赖关系进行打包。可以将您的应用入口起点认为是根上下文（contextual root）或app第一个启动文件。</p>
<h3 id="4-我们来作一个实例（Hello-World！）"><a href="#4-我们来作一个实例（Hello-World！）" class="headerlink" title="4.我们来作一个实例（Hello World！）"></a>4.我们来作一个实例（Hello World！）</h3><p>1.建立index.html文件</p>
<p>2.建立main.js文件</p>
<p>3.建立webpack.config.js文件</p>
<p>4.命令行输入webpack</p>
<p>5.安装live-server 并预览程序</p>
<p>index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

&lt;/head&gt;

&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>main.js</p>
<pre><code>document.write(&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;);
</code></pre><p>webpack.config.js</p>
<pre><code>module.exports = {
    entry: &quot;./main.js&quot;,
    output: {
        filename: &apos;bundle.js&apos;
    }
};
</code></pre><p>安装live-server,只要用npm install就可以安装了。</p>
<pre><code>npm install live-server -g
</code></pre><h1 id="二、多入口文件（Multiple-entry-files）"><a href="#二、多入口文件（Multiple-entry-files）" class="headerlink" title="二、多入口文件（Multiple entry files）"></a>二、多入口文件（Multiple entry files）</h1><h3 id="1-webpack配置多路口文件"><a href="#1-webpack配置多路口文件" class="headerlink" title="1.webpack配置多路口文件"></a>1.webpack配置多路口文件</h3><p>当我们需要时webpack 是允许我们有多个输出文件的。也就是说，我们可以在html文件中引入2个js文件或者其他的文件。</p>
<p>我们来做个多入口文件的例子：</p>
<p>1、首先我们建立两个JavaScript文件，分别是main1.js 和main2.js。然后在里边输出 Hello world  和 Hello webpack 。</p>
<p>main1.js</p>
<pre><code>document.write(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);
</code></pre><p>main2.js</p>
<pre><code>document.write(&quot;&lt;h2&gt;Hello Webpack!&lt;/h2&gt;&quot;);
</code></pre><p>2、建立indx.html文件，引入bundle1.js和bundle2.js，这两个文件就是我们要打包的两个js文件。</p>
<p>index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;title&gt;webpack example02&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

&lt;/head&gt;

&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./bundle1.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./bundle2.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>3、建立webpack.config.js配置文件。</p>
<pre><code>module.exports = {
    entry: {
        bundle1: &apos;./main1.js&apos;,
        bundle2: &apos;./main2.js&apos;
    },
    output: {
        filename: &apos;[name].js&apos;
    }
};
</code></pre><h1 id="三、使用Webpack-CSS-loader加载器"><a href="#三、使用Webpack-CSS-loader加载器" class="headerlink" title="三、使用Webpack CSS  loader加载器"></a>三、使用Webpack CSS  loader加载器</h1><h3 id="1-什么是loader"><a href="#1-什么是loader" class="headerlink" title="1.什么是loader"></a>1.什么是loader</h3><p>loader用于转换应用程序的资源文件，他们是运行在nodejs下的函数，使用参数来获取一个资源的来源并且返回一个新的来源（资源的位置），例如：你可以使用loader来告诉webpack去加载一个coffeeScript或者Babel文件。</p>
<h3 id="2-loader的解析"><a href="#2-loader的解析" class="headerlink" title="2.loader的解析"></a>2.loader的解析</h3><p>loader的解析类似模块，一个loader模块会导出一个方法并且可被nodejs写为可兼容的JavaScript,通常情况下通过npm来管理loader,但你也可以把loader放在自己的应用里。</p>
<h3 id="3-安装loader"><a href="#3-安装loader" class="headerlink" title="3.安装loader"></a>3.安装loader</h3><p>你可以通过npm来安装loader</p>
<pre><code>$ npm install xxx-loader --save-dev
</code></pre><p>或者</p>
<pre><code>$ npm install xxx-loader --save
</code></pre><h3 id="4-CSS-loader-实例"><a href="#4-CSS-loader-实例" class="headerlink" title="4.CSS-loader 实例"></a>4.CSS-loader 实例</h3><p>1、先建立一个html文件，并引入bundle.js文件。</p>
<p>index.html</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

&lt;/head&gt;

&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>2、建立main.js文件，并用require引入app.css文件。然后写一句话。</p>
<p>main.js</p>
<pre><code>require(&apos;./app.css&apos;);
document.write(&apos;&lt;h1&gt;Hello Webpack!&lt;/h1&gt;&apos;);
</code></pre><p>3、建立app.css文件，把body 的背景设置为红色。</p>
<p>app.css</p>
<pre><code>body {
    background-color: red;
}
</code></pre><p>4、建立webpack.config.js配置文件，在里边加入加载器。</p>
<pre><code>module.exports = {
    entry: &apos;./main.js&apos;,
    output: {
        filename: &apos;bundle.js&apos;
    },
    module: {
        loaders: [
            { test: /\.css$/, loader: &apos;style-loader!css-loader!stylus-loader&apos; },
        ]
    }
};
</code></pre><p>5、用npm 安装  css-loader  和style-loader</p>
<pre><code>$ npm install style-loader --save-dev

$ npm install css-loader --save-dev

npm install stylus-loader stylus --save-dev
</code></pre><p>6、在控制台输入 webpack 进行打包</p>
<pre><code>$ webpack
</code></pre><p>这样就用webpack的加载器成功打包了css样式文件。以后我们的html里就可以不用看到css的引入语句了。</p>
<h1 id="四、使用webpack-Image-loader-加载图片"><a href="#四、使用webpack-Image-loader-加载图片" class="headerlink" title="四、使用webpack Image loader 加载图片"></a>四、使用webpack Image loader 加载图片</h1><p>直接用一个例子说明<br>1、新建main.js文件， 创建img标签后，把src的值用require引进来。然后插入标签。</p>
<pre><code>var img1 = document.createElement(&quot;img&quot;);
img1.src = require(&quot;./small.png&quot;);
document.body.appendChild(img1);

var img2 = document.createElement(&quot;img&quot;);
img2.src = require(&quot;./big.png&quot;);
document.body.appendChild(img2);
</code></pre><p>2、建立index.html文件，引入bundle.js</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

&lt;/head&gt;

&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre><p>3、建立webpack.config.js配置文件</p>
<pre><code>module.exports = {
    entry: &apos;./main.js&apos;,
    output: {
        filename: &apos;bundle.js&apos;
    },
    module: {
        loaders: [
            { test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos; },
        ]
    }
};
</code></pre><p>这里需要说明的是limit ，它的左右是如果图片的大小，小于8192bytes就以Data URL的形式引入图片，大于就用图片地址引用。</p>
<p>4、打开命令行，用cnpm 安装url-loader包。</p>
<pre><code>$ cnpm install url-loader --save-dev
</code></pre><p>5、用webpack命令进行打包</p>
<pre><code>$ webpack
</code></pre><h1 id="五、使用uglify-js-压缩打包JS代码"><a href="#五、使用uglify-js-压缩打包JS代码" class="headerlink" title="五、使用uglify-js 压缩打包JS代码"></a>五、使用uglify-js 压缩打包JS代码</h1><h3 id="1-webpack-插件机制介绍："><a href="#1-webpack-插件机制介绍：" class="headerlink" title="1.webpack 插件机制介绍："></a>1.webpack 插件机制介绍：</h3><p>插件可以完成更多loader不能完成的功能。插件的使用一般是在webpack的配置信息 plugins选定中指定。Webpack本身内置了一些常用的插件，还可以通过npm安装第三方插件。</p>
<h3 id="2-uglify-js介绍："><a href="#2-uglify-js介绍：" class="headerlink" title="2.uglify-js介绍："></a>2.uglify-js介绍：</h3><p>ugligy-js是一个用npm安装的JavaScript代码压工具，我们在grunt和gulp中经常使用。</p>
<p>用npm命令进行安装：</p>
<pre><code>npm install uglify-js g
</code></pre><p>最常用的方法：</p>
<pre><code>uglifyjs [input files] [options]

uglifyjs demo.js -o demo-min.js -c
</code></pre><h3 id="3-用Webpack中的uglify-js压缩Demo"><a href="#3-用Webpack中的uglify-js压缩Demo" class="headerlink" title="3.用Webpack中的uglify-js压缩Demo"></a>3.用Webpack中的uglify-js压缩Demo</h3><p>这里我就不贴出index.html和main.js的代码了，我只贴出webpack.config.js的代码。如果你想完整的做出例子，可以按照视频步骤一步一步的操作。</p>
<pre><code>var webpack = require(&apos;webpack&apos;);
module.exports = {
    entry: &apos;./main.js&apos;,
    output: {
        path: __dirname,
        filename: &apos;bundle.js&apos;
    },
    plugins: [
        new webpack.optimize.UglifyJsPlugin({
            compress: {
                warnings: false
            }
        })
    ]
};
</code></pre><h1 id="六、使用webpack构建本地服务器"><a href="#六、使用webpack构建本地服务器" class="headerlink" title="六、使用webpack构建本地服务器"></a>六、使用webpack构建本地服务器</h1><p>我们之前一直都在用live-server充当本地服务器，其实它和webpack是不搭的，我们可以利用webpack自带的webpack-dev-server来构建一个本地服务器。它让你的浏览器检测你的代码修改，并自动刷新修改后的结果，它是基于node.js构建。webpack-dev-server是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。</p>
<p>1、安装webpack-dev-server</p>
<p>本地依赖</p>
<pre><code>npm install --save-dev webpack-dev-server
</code></pre><p>全局安装</p>
<pre><code>npm install -g webpack-dev-server
</code></pre><p>2、在webpack.config.js中配置devserver选项：</p>
<ul>
<li>contentBase : 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录。</li>
</ul>
<ul>
<li>port ：设置默认监听端口，如果省略，默认为”8080″</li>
</ul>
<ul>
<li>inline : 设置为true，当源文件改变时会自动刷新页面</li>
</ul>
<ul>
<li>colors ： 设置为true，使终端输出的文件为彩色的</li>
</ul>
<ul>
<li>historyApiFallback ：在开发单页时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html</li>
</ul>
<ul>
<li>host ： 主机地址，如果是开发本机搭建，需要使用本机IP地址，否则会报错。</li>
</ul>
<p>配置文件如下：</p>
<pre><code>module.exports = {
    entry: __dirname + &apos;/main.js&apos;,
    output: {
        path: __dirname + &apos;/&apos;,
        filename: &apos;bundle.js&apos;
    },
    devServer: {
        contentBase: &apos;./&apos;, //本地服务器所加载的页面所在的目录
        host: &apos;192.168.1.158&apos;, //本地IP地址
        colors: true, //终端输出结果为彩色
        historyApiFallback: true, //不跳转
        inline: true, //实时刷新
        port: &apos;3333&apos; //端口号

    }
}
</code></pre><p>3、在终端中输入命令，开启运行本地服务器。它不仅提供了服务器，还会监视我们的文件变化自动更新效果，但是它不是真正的打包，它类似于在内存中进行了打包。所以本地文件并没有变化。</p>
<pre><code>webpack-dev-server
</code></pre><p>其实webpack构建服务器才是正道，如果你使用了webpack，那么尽量使用webpack-dev-server吧，这能大大提高您的工作效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/stylus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/stylus/" itemprop="url">stylus</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:27:12+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h1><h3 id="1-使用缩排和凹排代替花括号-以及"><a href="#1-使用缩排和凹排代替花括号-以及" class="headerlink" title="(1).使用缩排和凹排代替花括号{以及}"></a>(1).使用缩排和凹排代替花括号{以及}</h3><pre><code>body
  color white

body {
  color: #fff;
}

body
  color: white
</code></pre><h3 id="2-允许你使用逗号为多个选择器同时定义属性"><a href="#2-允许你使用逗号为多个选择器同时定义属性" class="headerlink" title="(2).允许你使用逗号为多个选择器同时定义属性"></a>(2).允许你使用逗号为多个选择器同时定义属性</h3><pre><code>textarea, input
  border 1px solid #eee

textarea,
input {
  border: 1px solid #eee;
}
</code></pre><blockquote>
<p>唯一的例外就是长得像属性的选择器。例如，下面的foo bar baz可能是个属性或者是选择器。</p>
</blockquote>
<pre><code>foo bar baz
&gt; input
  border 1px solid
</code></pre><blockquote>
<p>为解决这个原因，我们可以在尾部加个逗号：</p>
</blockquote>
<pre><code>foo bar baz,
form input,
&gt; a
  border 1px solid
</code></pre><h3 id="3-字符-amp-指向父选择器。"><a href="#3-字符-amp-指向父选择器。" class="headerlink" title="(3).字符&amp;指向父选择器。"></a>(3).字符&amp;指向父选择器。</h3><pre><code>textarea
input
  color #A7A7A7
  &amp;:hover
    color #000

textarea,
input {
  color: #a7a7a7;
}
textarea:hover,
input:hover {
  color: #000;
}
</code></pre><h3 id="4-unquote-处理Stylus无法处理的属性值"><a href="#4-unquote-处理Stylus无法处理的属性值" class="headerlink" title="(4).unquote()  处理Stylus无法处理的属性值"></a>(4).unquote()  处理Stylus无法处理的属性值</h3><pre><code>filter unquote(&apos;progid:DXImageTransform.Microsoft.BasicImage(rotation=1)&apos;)

filter progid:DXImageTransform.Microsoft.BasicImage(rotation=1)
</code></pre><h1 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h1><h3 id="1-可以指定表达式为变量，然后在我们的样式中贯穿使用"><a href="#1-可以指定表达式为变量，然后在我们的样式中贯穿使用" class="headerlink" title="(1).可以指定表达式为变量，然后在我们的样式中贯穿使用"></a>(1).可以指定表达式为变量，然后在我们的样式中贯穿使用</h3><pre><code>font-size = 14px
body
  font font-size Arial, sans-seri

body {
  font: 14px Arial, sans-serif;
}
</code></pre><h3 id="2-变量甚至可以组成一个表达式列表"><a href="#2-变量甚至可以组成一个表达式列表" class="headerlink" title="(2).变量甚至可以组成一个表达式列表"></a>(2).变量甚至可以组成一个表达式列表</h3><pre><code>font-size = 14px
font = font-size &quot;Lucida Grande&quot;, Arial
body
  font font sans-serif

body {
  font: 14px &quot;Lucida Grande&quot;, Arial sans-serif;
}
</code></pre><h3 id="3-不需要分配值给变量就可以定义引用属性。"><a href="#3-不需要分配值给变量就可以定义引用属性。" class="headerlink" title="(3).不需要分配值给变量就可以定义引用属性。"></a>(3).不需要分配值给变量就可以定义引用属性。</h3><pre><code>#logo
  position: absolute
  top: 50%
  left: 50%
  width: 150px
  height: 80px
  margin-left: -(@width / 2)
  margin-top: -(@height / 2)
</code></pre><h1 id="三、插值"><a href="#三、插值" class="headerlink" title="三、插值"></a>三、插值</h1><p>通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。</p>
<pre><code>table
  for row in 1 2 3 4 5
    tr:nth-child({row})
      height: 10px * row

table tr:nth-child(1) {
  height: 10px;
}
table tr:nth-child(2) {
  height: 20px;
}
table tr:nth-child(3) {
  height: 30px;
}
table tr:nth-child(4) {
  height: 40px;
}
table tr:nth-child(5) {
  height: 50px;
}
</code></pre><h1 id="四、运算符"><a href="#四、运算符" class="headerlink" title="四、运算符"></a>四、运算符</h1><h3 id="1-当在属性值内使用-时候，你必须用括号包住。"><a href="#1-当在属性值内使用-时候，你必须用括号包住。" class="headerlink" title="(1).当在属性值内使用/时候，你必须用括号包住。"></a>(1).当在属性值内使用/时候，你必须用括号包住。</h3><pre><code>font: (14px/1.5);
</code></pre><h3 id="2"><a href="#2" class="headerlink" title="(2)."></a>(2).</h3><h1 id="五、Mixins-混合书写"><a href="#五、Mixins-混合书写" class="headerlink" title="五、Mixins 混合书写"></a>五、Mixins 混合书写</h1><p>混入和函数定义方法一致，但是应用却大相径庭。</p>
<blockquote>
<p>下面有定义的border-radius(n)方法，其却作为一个mixin（如，作为状态调用，而非表达式）调用。</p>
<p>当border-radius()选择器中调用时候，属性会被扩展并复制在选择器中。</p>
</blockquote>
<pre><code>border-radius(n)
  -webkit-border-radius n
  -moz-border-radius n
  border-radius 
form input[type=button]
  border-radius(5px)

编译成：
form input[type=button] {
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

注意到我们混合书写中的border-radius当作了属性，而不是一个递归函数调用

border-radius()
  -webkit-border-radius arguments
  -moz-border-radius arguments
  border-radius arguments
</code></pre><h1 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h1><h3 id="1-返回值"><a href="#1-返回值" class="headerlink" title="(1).返回值"></a>(1).返回值</h3><pre><code>很简单的例子，两数值相加的方法：

add(a, b)
  a + b
我们可以在特定条件下使用该方法，如在属性值中：

body 
  padding add(10px, 5)

渲染：
body {
  padding: 15px;
}
</code></pre><h3 id="2-默认参数"><a href="#2-默认参数" class="headerlink" title="(2).默认参数"></a>(2).默认参数</h3><p>可选参数往往有个默认的给定表达。在Stylus中，我们甚至可以超越默认参数。</p>
<pre><code>例如：
add(a, b = a)
  a + b

add(10, 5)
// =&gt; 15

add(10)
// =&gt; 20

注意：因为参数默认是赋值，我们可可以使用函数调用作为默认值。

add(a, b = unit(a, px))
  a + b
</code></pre><h3 id="3-函数体"><a href="#3-函数体" class="headerlink" title="(3).函数体"></a>(3).函数体</h3><p>通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。</p>
<pre><code>add(a, b = a)
  a = unit(a, px)
  b = unit(b, px)
  a + b

add(15%, 10deg)
// =&gt; 25
</code></pre><h3 id="4-变量函数"><a href="#4-变量函数" class="headerlink" title="(4).变量函数"></a>(4).变量函数</h3><p>我们可以把函数当作变量传递到新的函数中。例如，invoke()接受函数作为参数，因此，我们可以传递add()以及sub().</p>
<pre><code>invoke(a, b, fn)
  fn(a, b)

add(a, b)
  a + b

body
  padding invoke(5, 10, add)
  padding invoke(5, 10, sub)

结果：
body {
  padding: 15;
  padding: -5;
}
</code></pre><h3 id="5-参数"><a href="#5-参数" class="headerlink" title="(5).参数"></a>(5).参数</h3><pre><code>arguments是所有函数体都有的局部变量，包含传递的所有参数。

例如：
sum()
  n = 0
  for num in arguments
    n = n + num

sum(1,2,3,4,5)
// =&gt; 15
</code></pre><h1 id="七、关键字"><a href="#七、关键字" class="headerlink" title="七、关键字"></a>七、关键字</h1><p>Stylus支持关键字参数，或”kwargs”. 允许你根据相关参数名引用参数。</p>
<pre><code>body {
  color: rgba(255, 200, 100, 0.5);
  color: rgba(red: 255, green: 200, blue: 100, alpha: 0.5);
  color: rgba(alpha: 0.5, blue: 100, red: 255, 200);
  color: rgba(alpha: 0.5, blue: 100, 255, 200);
}
等同于：
body {
   color: rgba(255,200,100,0.5);
   color: rgba(255,200,100,0.5);
   color: rgba(255,200,100,0.5);
   color: rgba(255,200,100,0.5);
}
</code></pre><p>查看函数或混合书写中接受的参数，可以使用p()方法。</p>
<pre><code>p(rgba)
生成：
inspect: rgba(red, green, blue, alpha)
</code></pre><h1 id="八、内置方法"><a href="#八、内置方法" class="headerlink" title="八、内置方法"></a>八、内置方法</h1><p>Stylus支持name…形式的其余参数。这些参数可以消化传递给混写或函数的参数们。这在处理浏览器私有属性，如-moz或-webkit的时候很管用。</p>
<pre><code>box-shadow()
  -webkit-box-shadow arguments
  -moz-box-shadow arguments
  box-shadow arguments

body
  box-shadow #ddd 1px 1px, #eee 2px 2px

body {
  -webkit-box-shadow: #ddd 1px 1px, #eee 2px 2px;
  -moz-box-shadow: #ddd 1px 1px, #eee 2px 2px;
  box-shadow: #ddd 1px 1px, #eee 2px 2px;
}
</code></pre><h1 id="九、注释"><a href="#九、注释" class="headerlink" title="九、注释"></a>九、注释</h1><p>Stylus支持三种注释，单行注释，多行注释，以及多行缓冲注释。</p>
<h3 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="(1).单行注释"></a>(1).单行注释</h3><p>跟JavaScript一样，双斜杠，CSS中不输出。</p>
<pre><code>// 我是注释!
body
  padding 5px // 蛋疼的padding
</code></pre><h3 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="(2).多行注释"></a>(2).多行注释</h3><p>多行注释看起来有点像CSS的常规注释。然而，它们只有在compress选项未启用的时候才会被输出。</p>
<pre><code>/*
 * 给定数值合体
 */

add(a, b)
      a + b
</code></pre><h3 id="3-多行缓冲注释"><a href="#3-多行缓冲注释" class="headerlink" title="(3).多行缓冲注释"></a>(3).多行缓冲注释</h3><p>跟多行注释类似，不同之处在于开始的时候，这里是/*!. 这个相当于告诉Stylus压缩的时候这段无视直接输出。</p>
<pre><code>/*!
 * 给定数值合体
 */

add(a, b)
  a + b
</code></pre><h1 id="十、条件"><a href="#十、条件" class="headerlink" title="十、条件"></a>十、条件</h1><h1 id="十一、迭代"><a href="#十一、迭代" class="headerlink" title="十一、迭代"></a>十一、迭代</h1><h1 id="十二、-import"><a href="#十二、-import" class="headerlink" title="十二、@import"></a>十二、@import</h1><h1 id="十三、-media"><a href="#十三、-media" class="headerlink" title="十三、@media"></a>十三、@media</h1><pre><code>@media print
  #header
  #footer
    display none

生成为：
@media print {
  #header,
  #footer {
    display: none;
  }
}
</code></pre><h1 id="十四、-font-face"><a href="#十四、-font-face" class="headerlink" title="十四、@font-face"></a>十四、@font-face</h1><pre><code>@font-face
  font-family Geo
  font-style normal
  src url(fonts/geo_sans_light/GensansLight.ttf)

.ingeo
  font-family Geo
生成为：
@font-face {
  font-family: Geo;
  font-style: normal;
  src: url(&quot;fonts/geo_sans_light/GensansLight.ttf&quot;);
}
.ingeo {
  font-family: Geo;
}
</code></pre><h1 id="十五、-keyframes"><a href="#十五、-keyframes" class="headerlink" title="十五、@keyframes"></a>十五、@keyframes</h1><pre><code>@keyframes pulse
0%
  background-color red
  opacity 1.0
  -webkit-transform scale(1.0) rotate(0deg)
33%
  background-color blue
  opacity 0.75
  -webkit-transform scale(1.1) rotate(-5deg)
67%
  background-color green
  opacity 0.5
  -webkit-transform scale(1.1) rotate(5deg)
100%
  background-color red
  opacity 1.0
  -webkit-transform scale(1.0) rotate(0deg)
生成为：
@-webkit-keyframes pulse {
  0% {
  background-color: red;
  opacity: 1;
    -webkit-transform: scale(1) rotate(0deg);
  }

  33% {
    background-color: blue;
    opacity: 0.75;
    -webkit-transform: scale(1.1) rotate(-5deg);
  }

  67% {
    background-color: green;
    opacity: 0.5;
    -webkit-transform: scale(1.1) rotate(5deg);
  }

  100% {
    background-color: red;
    opacity: 1;
    -webkit-transform: scale(1) rotate(0deg);
  }

}
</code></pre><h1 id="十六、-extend"><a href="#十六、-extend" class="headerlink" title="十六、@extend"></a>十六、@extend</h1><pre><code>message,
.warning {
  padding: 10px;
  border: 1px solid #eee;
}

.warning {
  color: #E2E21E;
}

.message {
  padding: 10px;
  border: 1px solid #eee;
}

.warning {
  @extend .message;
  color: #E2E21E;
}
</code></pre><h1 id="十七、url"><a href="#十七、url" class="headerlink" title="十七、url()"></a>十七、url()</h1><h1 id="十八、字面量css"><a href="#十八、字面量css" class="headerlink" title="十八、字面量css"></a>十八、字面量css</h1><p>如果遇到Stylus搞不定的特殊需求，你可以使用@css使其作为CSS字面量解决之。</p>
<pre><code>@css {
  body {
    font: 14px;
  }
}
编译为：
body {
  font: 14px;
}
</code></pre><h1 id="十九、CSS样式解析"><a href="#十九、CSS样式解析" class="headerlink" title="十九、CSS样式解析"></a>十九、CSS样式解析</h1><p>支持css,stylus</p>
<h1 id="二十、使用"><a href="#二十、使用" class="headerlink" title="二十、使用"></a>二十、使用</h1><pre><code>#npm -g stylus

在.styl文件夹中 stylus &lt;demo.styl&gt; demo.css
stylus -w demo.styl -o demo.css
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/jquery-四-动画篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/jquery-四-动画篇/" itemprop="url">jquery(四)动画篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:26:35+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-jQuery中隐藏元素的hide方法"><a href="#1-jQuery中隐藏元素的hide方法" class="headerlink" title="1.jQuery中隐藏元素的hide方法"></a>1.jQuery中隐藏元素的hide方法</h1><pre><code>.hide( options )
.hide(&quot;fast / slow&quot;)
</code></pre><p>隐藏有动画效果</p>
<h1 id="2-jQuery中显示元素的show方法"><a href="#2-jQuery中显示元素的show方法" class="headerlink" title="2.jQuery中显示元素的show方法"></a>2.jQuery中显示元素的show方法</h1><pre><code>.hide( options )
.hide(&quot;fast / slow&quot;)
</code></pre><p><strong>注意事项：</strong></p>
<p>如果使用!important在你的样式中，比如display: none !important，如果你希望.show()方法正常工作，必须使用.css(‘display’, ‘block !important’)重写样式</p>
<h1 id="3-jQuery中显示与隐藏切换toggle方法"><a href="#3-jQuery中显示与隐藏切换toggle方法" class="headerlink" title="3.jQuery中显示与隐藏切换toggle方法"></a>3.jQuery中显示与隐藏切换toggle方法</h1><pre><code>toggle();
toggle( [duration ] [, complete ] )
</code></pre><ol>
<li>如果元素是最初显示，它会被隐藏</li>
</ol>
<ol>
<li>如果隐藏的，它会显示出来</li>
</ol>
<h1 id="4-jQuery中下拉动画slideDown"><a href="#4-jQuery中下拉动画slideDown" class="headerlink" title="4.jQuery中下拉动画slideDown"></a>4.jQuery中下拉动画slideDown</h1><p>.slideDown()：用滑动动画显示一个匹配元素</p>
<p>.slideDown( [duration ] [, complete ] )</p>
<p>持续时间（duration）是以毫秒为单位的，数值越大，动画越慢，不是越快。字符串 ‘fast’ 和 ‘slow’ 分别代表200和600毫秒的延时。如果提供任何其他字符串，或者这个duration参数被省略，那么默认使用400 毫秒的延时。</p>
<pre><code>具体使用：
$(&quot;ele&quot;).slideDown(1000, function() {
    //等待动画执行1秒后,执行别的动作....
});
</code></pre><h1 id="5-jQuery中上卷动画slideUp"><a href="#5-jQuery中上卷动画slideUp" class="headerlink" title="5.jQuery中上卷动画slideUp"></a>5.jQuery中上卷动画slideUp</h1><pre><code>$(&quot;elem&quot;).slideUp();

.slideUp( [duration ] [, easing ] [, complete ] )
</code></pre><p>因为动画是异步的，所以要在动画之后执行某些操作就必须要写到回调函数里面，这里要特别注意</p>
<h1 id="6-jQuery中上卷下拉切换slideToggle"><a href="#6-jQuery中上卷下拉切换slideToggle" class="headerlink" title="6.jQuery中上卷下拉切换slideToggle"></a>6.jQuery中上卷下拉切换slideToggle</h1><pre><code>slideToggle();
.slideToggle( [duration ] ,[ complete ] )
</code></pre><h1 id="7-jQuery中淡出动画fadeOut"><a href="#7-jQuery中淡出动画fadeOut" class="headerlink" title="7.jQuery中淡出动画fadeOut"></a>7.jQuery中淡出动画fadeOut</h1><pre><code>.fadeOut( [duration ], [ complete ] )
</code></pre><h1 id="8-jQuery中淡入动画fadeIn"><a href="#8-jQuery中淡入动画fadeIn" class="headerlink" title="8.jQuery中淡入动画fadeIn"></a>8.jQuery中淡入动画fadeIn</h1><pre><code>.fadeIn( [duration ], [ complete ] )
</code></pre><p>淡入的动画原理：操作元素的不透明度从0%逐渐增加到100%</p>
<h1 id="9-jQuery中淡入淡出切换fadeToggle"><a href="#9-jQuery中淡入淡出切换fadeToggle" class="headerlink" title="9.jQuery中淡入淡出切换fadeToggle"></a>9.jQuery中淡入淡出切换fadeToggle</h1><pre><code>.fadeToggle( [duration ] ,[ complete ] )
</code></pre><h1 id="10-jQuery中淡入效果fadeTo"><a href="#10-jQuery中淡入效果fadeTo" class="headerlink" title="10.jQuery中淡入效果fadeTo"></a>10.jQuery中淡入效果fadeTo</h1><pre><code>.fadeTo( duration, opacity ,callback)
</code></pre><p>相比fadeOut,fadeIn,可以改变透明度</p>
<h1 id="11-toggle、sildeToggle以及fadeToggle的区别："><a href="#11-toggle、sildeToggle以及fadeToggle的区别：" class="headerlink" title="11.toggle、sildeToggle以及fadeToggle的区别："></a>11.toggle、sildeToggle以及fadeToggle的区别：</h1><ol>
<li>toggle：切换显示与隐藏效果</li>
</ol>
<ol>
<li>sildeToggle：切换上下拉卷滚效果</li>
</ol>
<ol>
<li>fadeToggle：切换淡入淡出效果</li>
</ol>
<h1 id="12-jQuery中动画animate-上"><a href="#12-jQuery中动画animate-上" class="headerlink" title="12.jQuery中动画animate(上)"></a>12.jQuery中动画animate(上)</h1><pre><code>.animate( properties ,[ duration ], [ easing ], [ complete ] )
</code></pre><p><strong>参数分解：</strong></p>
<ul>
<li>properties：一个或多个css属性的键值对所构成的Object对象。要特别注意所有用于动画的属性必须是数字的，除非另有说明；这些属性如果不是数字的将不能使用基本的jQuery功能。比如常见的，border、margin、padding、width、height、font、left、top、right、bottom、wordSpacing等等这些都是能产生动画效果的。background-color很明显不可以，因为参数是red或者GBG这样的值，非常用插件，否则正常情况下是不能只用动画效果的。注意，CSS 样式使用 DOM 名称（比如 “fontSize”）来设置，而非 CSS 名称（比如 “font-size”）。</li>
</ul>
<p>特别注意单位，属性值的单位像素（px）,除非另有说明。单位em 和 %需要指定使用</p>
<pre><code>.animate({
    left: 50, 
    width: &apos;50px&apos;   
    opacity: &apos;show&apos;,  
    fontSize: &quot;10em&quot;,
}, 500);
</code></pre><p>除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏</p>
<pre><code>.animate({
    width: &quot;toggle&quot;
});
</code></pre><p>如果提供一个以+= 或 -=开始的值，那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的</p>
<pre><code>.animate({ 
    left: &apos;+=50px&apos;
}, &quot;slow&quot;);
</code></pre><ul>
<li>duration时间<br>动画执行的时间，持续时间是以毫秒为单位的；值越大表示动画执行的越慢，不是越快。还可以提供’fast’ 和 ‘slow’字符串，分别表示持续时间为200 和 600毫秒。</li>
</ul>
<ul>
<li>easing动画运动的算法<br>jQuery库中默认调用 swing。如果需要其他的动画算法，请查找相关的插件</li>
</ul>
<ul>
<li>complete回调<br>动画完成时执行的函数，这个可以保证当前动画确定完成后发会触发</li>
</ul>
<h1 id="13-jQuery中动画animate-下"><a href="#13-jQuery中动画animate-下" class="headerlink" title="13.jQuery中动画animate(下)"></a>13.jQuery中动画animate(下)</h1><pre><code>.animate( properties, options )
</code></pre><p><strong>options参数</strong></p>
<ul>
<li>duration - 设置动画执行的时间</li>
</ul>
<ul>
<li>easing - 规定要使用的 easing 函数，过渡使用哪种缓动函数</li>
</ul>
<ul>
<li>step：规定每个动画的每一步完成之后要执行的函数</li>
</ul>
<ul>
<li>progress：每一次动画调用的时候会执行这个回调，就是一个进度的概念</li>
</ul>
<ul>
<li>complete：动画完成回调</li>
</ul>
<p>其中最关键的一点就是：</p>
<blockquote>
<p>如果多个元素执行动画，回调将在每个匹配的元素上执行一次，不是作为整个动画执行一次</p>
</blockquote>
<pre><code>$(&apos;#elem&apos;).animate({
    width: &apos;toggle&apos;,  
    height: &apos;toggle&apos;
  }, {
    duration: 5000,
    specialEasing: {
      width: &apos;linear&apos;,
      height: &apos;easeOutBounce&apos;
    },
    complete: function() {
      $(this).after(&apos;&lt;div&gt;Animation complete.&lt;/div&gt;&apos;);
    }
  });
</code></pre><h1 id="14-jQuery中停止动画stop"><a href="#14-jQuery中停止动画stop" class="headerlink" title="14.jQuery中停止动画stop"></a>14.jQuery中停止动画stop</h1><ol>
<li><p>stop()  停止当前动画</p>
</li>
<li><p>stop(true)  停止当前执行动画元素的所有动画行为</p>
</li>
<li><p>stop(true,true)  停止当前执行动画元素的所有动画行为，并且直接到达动画最后一帧</p>
</li>
</ol>
<h1 id="15-jQuery中each方法的应用"><a href="#15-jQuery中each方法的应用" class="headerlink" title="15.jQuery中each方法的应用"></a>15.jQuery中each方法的应用</h1><p>用来处理对象和数组的遍历</p>
<pre><code>jQuery.each(array, callback )
jQuery.each( object, callback )
</code></pre><hr>
<pre><code>$.each([&quot;Aaron&quot;, &quot;慕课网&quot;], function(index, value) {
   //index是索引,也就是数组的索引
   //value就是数组中的值了
});

$.each([&quot;Aaron&quot;, &quot;慕课网&quot;], function(index, value) {
    return false; //停止迭代
});
</code></pre><p>例子</p>
<pre><code>$.each([&apos;Aaron&apos;, &apos;慕课网&apos;], function(i, item) {
    $aaron.append(&quot;索引=&quot; + i + &quot;; 元素=&quot; + item);
});

$.each({
    name: &quot;张三&quot;,
    age: 18
}, function(property, value) {
    $aaron.append(&quot;属性名=&quot; + property + &quot;; 属性值=&quot; + value);
});
</code></pre><h1 id="16-jQuery中查找数组中的索引inArray"><a href="#16-jQuery中查找数组中的索引inArray" class="headerlink" title="16.jQuery中查找数组中的索引inArray"></a>16.jQuery中查找数组中的索引inArray</h1><p>jQuery.inArray()函数用于在数组中搜索指定的值，并返回其索引值。如果数组中不存在该值，则返回 -1。，可以通过fromIndex规定查找的起始值，默认数组是0开始。</p>
<pre><code>jQuery.inArray( value, array ,[ fromIndex ] )
</code></pre><p>例如：在数组中查找值是5的索引</p>
<pre><code>$.inArray(5,[1,2,3,4,5,6,7]) //返回对应的索引：4
</code></pre><p>注意：</p>
<p>如果要判断数组中是否存在指定值，你需要通过该函数的返回值不等于(或大于)-1来进行判断</p>
<h1 id="17-jQuery中去空格神器trim方法"><a href="#17-jQuery中去空格神器trim方法" class="headerlink" title="17.jQuery中去空格神器trim方法"></a>17.jQuery中去空格神器trim方法</h1><p>jQuery.trim()函数用于去除字符串两端的空白字符</p>
<p>这个函数很简单，没有多余的参数用法</p>
<p>需要注意：</p>
<ol>
<li>移除字符串开始和结尾处的所有换行符，空格(包括连续的空格)和制表符（tab）</li>
</ol>
<ol>
<li>如果这些空白字符在字符串中间时，它们将被保留，不会被移除</li>
</ol>
<h1 id="18-jQuery中DOM元素的获取get方法"><a href="#18-jQuery中DOM元素的获取get方法" class="headerlink" title="18.jQuery中DOM元素的获取get方法"></a>18.jQuery中DOM元素的获取get方法</h1><pre><code>.get( [index ] )

&lt;a&gt;1&lt;/a&gt;
&lt;a&gt;2&lt;/a&gt;
&lt;a&gt;3&lt;/a&gt;
</code></pre><p><strong>注意2点</strong></p>
<ol>
<li>get方法是获取的dom对象，也就是通过document.getElementById获取的对象</li>
</ol>
<ol>
<li>get方法是从0开始索引</li>
</ol>
<p>所以第二个a元素的查找： $(a).get(1)</p>
<p><strong>负索引值参数</strong></p>
<p>get方法还可以从后往前索引，传递一个负索引值，<strong>注意的负值的索引起始值是-1</strong></p>
<p>同样是找到第二元素，可以传递 $(a).get(-2) </p>
<blockquote>
<p>get方法是获取dom对象，eq方法是获取jq对象.那么js取得的元素后面就必须跟js的方法或者属性，既$().get().style()。而不是$().get().css()。因为style是js独有的方法，而css()是jq独有的方法，get()方法后取得的js元素，它只能识别style()，而不能识别css()。</p>
</blockquote>
<h1 id="19-jQuery中DOM元素的获取index方法"><a href="#19-jQuery中DOM元素的获取index方法" class="headerlink" title="19.jQuery中DOM元素的获取index方法"></a>19.jQuery中DOM元素的获取index方法</h1><pre><code>.index()
.index( selector )
.index( element )
</code></pre><ol>
<li>如果不传递任何参数给 .index() 方法，则返回值就是jQuery对象中第一个元素相对于它同辈元素的位置</li>
</ol>
<ol>
<li>如果在一组元素上调用 .index() ，并且参数是一个DOM元素或jQuery对象， .index() 返回值就是传入的元素相对于原先集合的位置</li>
</ol>
<ol>
<li>如果参数是一个选择器， .index() 返回值就是原先元素相对于选择器匹配元素的位置。如果找不到匹配的元素，则 .index() 返回 -1</li>
</ol>
<p>例如</p>
<pre><code>&lt;ul&gt;
    &lt;a&gt;&lt;/a&gt;
    &lt;li id=&quot;test1&quot;&gt;1&lt;/li&gt;
    &lt;li id=&quot;test2&quot;&gt;2&lt;/li&gt;
    &lt;li id=&quot;test3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>$(“li”).index() 没有传递参数，反正的结果是1，它的意思是返回同辈的排列循序，第一个li之前有a元素,同辈元素是a开始为0，所以li的开始索引是1</p>
<p>如果要快速找到第二个li在列表中的索引,可以通过如下2种方式处理</p>
<pre><code>$(&quot;li&quot;).index(document.getElementById(&quot;test2&quot;)) //结果：1
$(&quot;li&quot;).index($(&quot;#test2&quot;))  //结果:1
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/jquery-三-事件篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/jquery-三-事件篇/" itemprop="url">jquery(三)事件篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:26:18+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-jQuery鼠标事件之click与dblclick事件"><a href="#1-jQuery鼠标事件之click与dblclick事件" class="headerlink" title="1.jQuery鼠标事件之click与dblclick事件"></a>1.jQuery鼠标事件之click与dblclick事件</h1><p>前者单击，后者双击</p>
<h1 id="2-jQuery鼠标事件之mousedown与mouseup事件"><a href="#2-jQuery鼠标事件之mousedown与mouseup事件" class="headerlink" title="2.jQuery鼠标事件之mousedown与mouseup事件"></a>2.jQuery鼠标事件之mousedown与mouseup事件</h1><h1 id="3-jQuery鼠标事件之mousemove事件"><a href="#3-jQuery鼠标事件之mousemove事件" class="headerlink" title="3.jQuery鼠标事件之mousemove事件"></a>3.jQuery鼠标事件之mousemove事件</h1><p>移动事件</p>
<h1 id="4-jQuery鼠标事件之mouseover与mouseout事件"><a href="#4-jQuery鼠标事件之mouseover与mouseout事件" class="headerlink" title="4.jQuery鼠标事件之mouseover与mouseout事件"></a>4.jQuery鼠标事件之mouseover与mouseout事件</h1><h1 id="5-jQuery鼠标事件之mouseenter与mouseleave事件"><a href="#5-jQuery鼠标事件之mouseenter与mouseleave事件" class="headerlink" title="5.jQuery鼠标事件之mouseenter与mouseleave事件"></a>5.jQuery鼠标事件之mouseenter与mouseleave事件</h1><p>mouseenter事件只会在绑定它的元素上被调用，而不会在后代节点上被触发</p>
<h1 id="6-jQuery鼠标事件之hover事件"><a href="#6-jQuery鼠标事件之hover事件" class="headerlink" title="6.jQuery鼠标事件之hover事件"></a>6.jQuery鼠标事件之hover事件</h1><pre><code>(selector).hover(handlerIn, handlerOut)
</code></pre><ul>
<li>handlerIn(eventObject)：当鼠标指针进入元素时触发执行的事件函数</li>
</ul>
<ul>
<li>handlerOut(eventObject)：当鼠标指针离开元素时触发执行的事件函数</li>
</ul>
<h1 id="7-jQuery鼠标事件之focusin事件"><a href="#7-jQuery鼠标事件之focusin事件" class="headerlink" title="7.jQuery鼠标事件之focusin事件"></a>7.jQuery鼠标事件之focusin事件</h1><p>当一个元素，或者其内部任何一个元素获得焦点的时候，例如：input元素，用户在点击聚焦的时候，如果开发者需要捕获这个动作的时候，jQuery提供了一个focusin事件</p>
<h1 id="8-jQuery鼠标事件之focusout事件"><a href="#8-jQuery鼠标事件之focusout事件" class="headerlink" title="8.jQuery鼠标事件之focusout事件"></a>8.jQuery鼠标事件之focusout事件</h1><p>当一个元素，或者其内部任何一个元素失去焦点的时候，比如input元素，用户在点击失去焦的时候，如果开发者需要捕获这个动作，jQuery提供了一个focusout事件</p>
<h1 id="9-jQuery表单事件之blur与focus事件"><a href="#9-jQuery表单事件之blur与focus事件" class="headerlink" title="9.jQuery表单事件之blur与focus事件"></a>9.jQuery表单事件之blur与focus事件</h1><p>focus与blur事件：不支持冒泡，focusin与focusout支持冒泡</p>
<h1 id="10-jQuery表单事件之change事件"><a href="#10-jQuery表单事件之change事件" class="headerlink" title="10.jQuery表单事件之change事件"></a>10.jQuery表单事件之change事件</h1><p><input\>元素，<textarea\>和<select\>元素的值都是可以发生改变的，开发者可以通过change事件去监听这些改变的动作</select\></textarea\></input\></p>
<h3 id="1-input元素"><a href="#1-input元素" class="headerlink" title="(1).input元素"></a>(1).input元素</h3><p>监听value值的变化，当有改变时，失去焦点后触发change事件。对于单选按钮和复选框，当用户用鼠标做出选择时，该事件立即触发。</p>
<h3 id="2-select元素"><a href="#2-select元素" class="headerlink" title="(2).select元素"></a>(2).select元素</h3><p>对于下拉选择框，当用户用鼠标作出选择时，该事件立即触发</p>
<h3 id="3-textarea元素"><a href="#3-textarea元素" class="headerlink" title="(3).textarea元素"></a>(3).textarea元素</h3><p>多行文本输入框，当有改变时，失去焦点后触发change事件</p>
<h1 id="11-jQuery表单事件之select事件"><a href="#11-jQuery表单事件之select事件" class="headerlink" title="11.jQuery表单事件之select事件"></a>11.jQuery表单事件之select事件</h1><p>当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。</p>
<pre><code>select事件只能用于&lt;input&gt;元素与&lt;textarea&gt;元素
</code></pre><h1 id="12-jQuery表单事件之submit事件"><a href="#12-jQuery表单事件之submit事件" class="headerlink" title="12.jQuery表单事件之submit事件"></a>12.jQuery表单事件之submit事件</h1><h3 id="1-具体能触发submit事件的行为："><a href="#1-具体能触发submit事件的行为：" class="headerlink" title="(1).具体能触发submit事件的行为："></a>(1).具体能触发submit事件的行为：</h3><ol>
<li><input type="submit" \="">


</li>
</ol>
<ol>
<li><input type="image" \="">


</li>
</ol>
<ol>
<li><button type="submit" \="">


</button></li>
</ol>
<ol>
<li>当某些表单元素获取焦点时，敲击Enter（回车键）</li>
</ol>
<h3 id="2-这里需要特别注意："><a href="#2-这里需要特别注意：" class="headerlink" title="(2).这里需要特别注意："></a>(2).这里需要特别注意：</h3><blockquote>
<p>form元素是有默认提交表单的行为，如果通过submit处理的话，需要禁止浏览器的这个默认行为<br>传统的方式是调用事件对象  e.preventDefault() 来处理， jQuery中可以直接在函数中最后结尾return false即可</p>
</blockquote>
<pre><code>$(&quot;#target&quot;).submit(function(data) { 
   return false; //阻止默认行为，提交表单
});
</code></pre><h1 id="13-jQuery键盘事件之keydown-与keyup-事件"><a href="#13-jQuery键盘事件之keydown-与keyup-事件" class="headerlink" title="13.jQuery键盘事件之keydown()与keyup()事件"></a>13.jQuery键盘事件之keydown()与keyup()事件</h1><h1 id="14-jQuery键盘事件之keypress-事件"><a href="#14-jQuery键盘事件之keypress-事件" class="headerlink" title="14.jQuery键盘事件之keypress()事件"></a>14.jQuery键盘事件之keypress()事件</h1><p>在input元素上绑定keydown事件会发现一个问题：<br>每次获取的内容都是之前输入的，当前输入的获取不到</p>
<p>keypress()可以捕获当前的值，但是中文不可以，e.target.value返回之前所有的输入字符，这个时候中文 就会被提取并打印出来！</p>
<h1 id="15-on-的多事件绑定"><a href="#15-on-的多事件绑定" class="headerlink" title="15.on()的多事件绑定"></a>15.on()的多事件绑定</h1><h3 id="1-基本用法：-on-events-selector-data"><a href="#1-基本用法：-on-events-selector-data" class="headerlink" title="(1).基本用法：.on( events ,[ selector ] ,[ data ] )"></a>(1).基本用法：.on( events ,[ selector ] ,[ data ] )</h3><pre><code>$(&quot;#elem&quot;).click(function(){})  //快捷方式
$(&quot;#elem&quot;).on(&apos;click&apos;,function(){}) //on方式
最大的不同点就是on是可以自定义事件名
</code></pre><h3 id="2-多个事件绑定同一个函数"><a href="#2-多个事件绑定同一个函数" class="headerlink" title="(2).多个事件绑定同一个函数"></a>(2).多个事件绑定同一个函数</h3><pre><code>$(&quot;#elem&quot;).on(&quot;mouseover mouseout&quot;,function(){ });
</code></pre><h3 id="3-多个事件绑定不同函数"><a href="#3-多个事件绑定不同函数" class="headerlink" title="(3).多个事件绑定不同函数"></a>(3).多个事件绑定不同函数</h3><pre><code>$(&quot;#elem&quot;).on({
    mouseover:function(){},  
    mouseout:function(){}
});
</code></pre><h3 id="4-将数据传递到处理程序"><a href="#4-将数据传递到处理程序" class="headerlink" title="(4).将数据传递到处理程序"></a>(4).将数据传递到处理程序</h3><pre><code>function greet( event ) {
  alert( &quot;Hello &quot; + event.data.name ); //Hello 慕课网
}
$( &quot;button&quot; ).on( &quot;click&quot;, {
  name: &quot;慕课网&quot;
}, greet );
</code></pre><p>可以通过第二参数（对象），当一个事件被触发时，要传递给事件处理函数的</p>
<h1 id="16-on-的高级用法"><a href="#16-on-的高级用法" class="headerlink" title="16.on()的高级用法"></a>16.on()的高级用法</h1><p>事件绑定在最上层div元素上，当用户触发在a元素上，事件将往上冒泡，一直会冒泡在div元素上。如果提供了第二参数，那么事件在往上冒泡的过程中遇到了选择器匹配的元素，将会触发事件回调函数</p>
<pre><code>&lt;div class=&quot;left&quot;&gt;
    &lt;p class=&quot;aaron&quot;&gt;
        &lt;a&gt;目标节点&lt;/a&gt; //点击在这个元素上
    &lt;/p&gt;
&lt;/div&gt;

$(&quot;div&quot;).on(&quot;click&quot;,&quot;a&quot;,fn)
</code></pre><h1 id="17-卸载事件off-方法"><a href="#17-卸载事件off-方法" class="headerlink" title="17.卸载事件off()方法"></a>17.卸载事件off()方法</h1><h3 id="1-绑定2个事件"><a href="#1-绑定2个事件" class="headerlink" title="(1).绑定2个事件"></a>(1).绑定2个事件</h3><pre><code>$(&quot;elem&quot;).on(&quot;mousedown mouseup&quot;,fn)
</code></pre><h3 id="2-删除一个事件"><a href="#2-删除一个事件" class="headerlink" title="(2).删除一个事件"></a>(2).删除一个事件</h3><pre><code>$(&quot;elem&quot;).off(&quot;mousedown&quot;)
</code></pre><h3 id="3-删除所有事件"><a href="#3-删除所有事件" class="headerlink" title="(3).删除所有事件"></a>(3).删除所有事件</h3><pre><code>$(&quot;elem&quot;).off(&quot;mousedown mouseup&quot;)
</code></pre><p>快捷方式删除所有事件，这里不需要传递事件名了，节点上绑定的所有事件讲全部销毁</p>
<pre><code>$(&quot;elem&quot;).off()
</code></pre><h1 id="18-jQuery事件对象的作用"><a href="#18-jQuery事件对象的作用" class="headerlink" title="18.jQuery事件对象的作用"></a>18.jQuery事件对象的作用</h1><pre><code>&lt;ul&gt;
    &lt;li class=&quot;even1&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;even2&quot;&gt;&lt;/li&gt;
    &lt;li class=&quot;even2&quot;&gt;&lt;/li&gt;
    .........
&lt;/ul&gt;
</code></pre><p>ul有N个子元素li(这里只写了3个)，如果我要响应每一个li的事件，那么常规的方法就是需要给所有的li都单独绑定一个事件监听，这样写法很符合逻辑，但是同时有显得繁琐</p>
<p>因为li都有一个共同的父元素，而且所有的事件都是一致的，这里我们可以采用要一个技巧来处理，也是常说的”事件委托”</p>
<p>事件没直接和li元素发生关系，而且绑定父元素了。由于浏览器有事件冒泡的这个特性，我们可以在触发li的时候把这个事件往上冒泡到ul上，因为ul上绑定事件响应所以就能够触发这个动作了。唯一的问题怎么才知道触发的li元素是哪个一个？</p>
<p>这里就引出了事件对象了</p>
<blockquote>
<p>事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁</p>
</blockquote>
<p><strong>event.target代表当前触发事件的元素，可以通过当前元素对象的一系列属性来判断是不是我们想要的元素</strong></p>
<h1 id="19-jQuery事件对象的属性和方法"><a href="#19-jQuery事件对象的属性和方法" class="headerlink" title="19.jQuery事件对象的属性和方法"></a>19.jQuery事件对象的属性和方法</h1><p>事件对象的属于与方法有很多，但是我们经常用的只有那么几个，这里我主要说下作用与区别</p>
<h3 id="1-event-type：获取事件的类型"><a href="#1-event-type：获取事件的类型" class="headerlink" title="(1).event.type：获取事件的类型"></a>(1).event.type：获取事件的类型</h3><p>触发元素的事件类型</p>
<pre><code>$(&quot;a&quot;).click(function(event) {
  alert(event.type); // &quot;click&quot;事件
});
</code></pre><h3 id="2-event-pageX-和-event-pageY：获取鼠标当前相对于页面的坐标"><a href="#2-event-pageX-和-event-pageY：获取鼠标当前相对于页面的坐标" class="headerlink" title="(2).event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标"></a>(2).event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标</h3><p>通过这2个属性，可以确定元素在当前页面的坐标值，鼠标相对于文档的左边缘的位置（左边）与 （顶边）的距离，简单来说是从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化</p>
<h3 id="3-event-preventDefault-方法：阻止默认行为"><a href="#3-event-preventDefault-方法：阻止默认行为" class="headerlink" title="(3).event.preventDefault() 方法：阻止默认行为"></a>(3).event.preventDefault() 方法：阻止默认行为</h3><p>这个用的特别多，在执行这个方法后，如果点击一个链接（a标签），浏览器不会跳转到新的 URL 去了。我们可以用 event.isDefaultPrevented() 来确定这个方法是否(在那个事件对象上)被调用过了</p>
<h3 id="4-event-stopPropagation-方法：阻止事件冒泡"><a href="#4-event-stopPropagation-方法：阻止事件冒泡" class="headerlink" title="(4).event.stopPropagation() 方法：阻止事件冒泡"></a>(4).event.stopPropagation() 方法：阻止事件冒泡</h3><p>事件是可以冒泡的，为防止事件冒泡到DOM树上，也就是不触发的任何前辈元素上的事件处理函数</p>
<h3 id="5-event-which：获取在鼠标单击时，单击的是鼠标的哪个键"><a href="#5-event-which：获取在鼠标单击时，单击的是鼠标的哪个键" class="headerlink" title="(5).event.which：获取在鼠标单击时，单击的是鼠标的哪个键"></a>(5).event.which：获取在鼠标单击时，单击的是鼠标的哪个键</h3><p>event.which 将 event.keyCode 和 event.charCode 标准化了。event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3</p>
<h3 id="6-event-currentTarget-在事件冒泡过程中的当前DOM元素"><a href="#6-event-currentTarget-在事件冒泡过程中的当前DOM元素" class="headerlink" title="(6).event.currentTarget : 在事件冒泡过程中的当前DOM元素"></a>(6).event.currentTarget : 在事件冒泡过程中的当前DOM元素</h3><p>冒泡前的当前触发事件的DOM对象, 等同于this.</p>
<h3 id="7-this和event-target的区别："><a href="#7-this和event-target的区别：" class="headerlink" title="(7).this和event.target的区别："></a>(7).this和event.target的区别：</h3><p>js中事件是会冒泡的，所以this是可以变化的，但event.target不会变化，它永远是直接接受事件的目标DOM元素；</p>
<h3 id="8-this和event-target都是dom对象"><a href="#8-this和event-target都是dom对象" class="headerlink" title="(8).this和event.target都是dom对象"></a>(8).this和event.target都是dom对象</h3><p>如果要使用jquey中的方法可以将他们转换为jquery对象。比如this和$(this)的使用、event.target和$(event.target)的使用；</p>
<h1 id="20-jQuery自定义事件之trigger事件"><a href="#20-jQuery自定义事件之trigger事件" class="headerlink" title="20.jQuery自定义事件之trigger事件"></a>20.jQuery自定义事件之trigger事件</h1><p>trigger() 方法触发被选元素的指定事件类型。</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
  $(&quot;input&quot;).select(function(){
    $(&quot;input&quot;).after(&quot;文本被选中！&quot;);
  });
  $(&quot;button&quot;).click(function(){
    $(&quot;input&quot;).trigger(&quot;select&quot;);
  });
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;FirstName&quot; value=&quot;Hello World&quot; /&gt;
&lt;br /&gt;
&lt;button&gt;激活 input 域的 select 事件&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="21-jQuery自定义事件之triggerHandler事件"><a href="#21-jQuery自定义事件之triggerHandler事件" class="headerlink" title="21.jQuery自定义事件之triggerHandler事件"></a>21.jQuery自定义事件之triggerHandler事件</h1><p>triggerHandler() 方法触发被选元素的指定事件类型。但不会执行浏览器默认动作，也不会产生事件冒泡。</p>
<p>triggerHandler() 方法与 trigger() 方法类似。不同的是它不会触发事件（比如表单提交）的默认行为，而且只影响第一个匹配元素。</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function(){
  $(&quot;input&quot;).select(function(){
    $(&quot;input&quot;).after(&quot;发生 Input select 事件！&quot;);
  });
  $(&quot;button&quot;).click(function(){
    $(&quot;input&quot;).triggerHandler(&quot;select&quot;);
  });
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;FirstName&quot; value=&quot;Hello World&quot; /&gt;
&lt;br /&gt;
&lt;button&gt;激活 input 域的 select 事件&lt;/button&gt;
&lt;p&gt;请注意，与 trigger() 方法不同，triggerHandler() 方法不会引起所发生事件的默认行为（文本不会被选中）。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/jquery-二-DOM篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/jquery-二-DOM篇/" itemprop="url">jquery(二)DOM篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:25:59+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-jQuery节点创建与属性的处理"><a href="#1-jQuery节点创建与属性的处理" class="headerlink" title="1.jQuery节点创建与属性的处理"></a>1.jQuery节点创建与属性的处理</h1><h3 id="1-创建元素节点："><a href="#1-创建元素节点：" class="headerlink" title="(1).创建元素节点："></a>(1).创建元素节点：</h3><p>可以有几种方式，后面会慢慢接触。常见的就是直接把这个节点的结构给通过HTML标记字符串描述出来，通过$()函数处理，$(“html结构”)</p>
<pre><code>$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)
</code></pre><h3 id="2-创建为本节点："><a href="#2-创建为本节点：" class="headerlink" title="(2).创建为本节点："></a>(2).创建为本节点：</h3><p>与创建元素节点类似，可以直接把文本内容一并描述</p>
<pre><code>$(&quot;&lt;div&gt;我是文本节点&lt;/div&gt;&quot;)
</code></pre><h3 id="3-创建为属性节点："><a href="#3-创建为属性节点：" class="headerlink" title="(3).创建为属性节点："></a>(3).创建为属性节点：</h3><p>与创建元素节点同样的方式</p>
<pre><code>$(&quot;&lt;div id=&apos;test&apos; class=&apos;aaron&apos;&gt;我是文本节点&lt;/div&gt;&quot;)
</code></pre><hr>
<pre><code>$(&quot;&lt;div class=&apos;right&apos;&gt;&lt;div class=&apos;aaron&apos;&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;&quot;)
</code></pre><h1 id="2-DOM内部插入append-与appendTo"><a href="#2-DOM内部插入append-与appendTo" class="headerlink" title="2.DOM内部插入append()与appendTo()"></a>2.DOM内部插入append()与appendTo()</h1><p><img src="http://oncweb6po.bkt.clouddn.com/56cc12f800017b4104480146.jpg" alt=""></p>
<p>append()前面是被插入的对象，后面是要在对象内插入的元素内容</p>
<p>appendTo()前面是要插入的元素内容，而后面是被插入的对象</p>
<h1 id="3-DOM外部插入after-与before"><a href="#3-DOM外部插入after-与before" class="headerlink" title="3.DOM外部插入after()与before()"></a>3.DOM外部插入after()与before()</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57481b6b00018e3405210197.jpg" alt=""></p>
<ol>
<li>before与after都是用来对相对选中元素外部增加相邻的兄弟节点</li>
</ol>
<ol>
<li>2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面</li>
</ol>
<ol>
<li>2个方法都支持多个参数传递after(div1,div2,….) 可以参考右边案例代码</li>
</ol>
<p><strong>注意点：</strong></p>
<ol>
<li>after向元素的后边添加html代码，如果元素后面有元素了，那将后面的元素后移，然后将html代码插入</li>
</ol>
<ol>
<li>before向元素的前边添加html代码，如果元素前面有元素了，那将前面的元素前移，然后将html代码插</li>
</ol>
<h1 id="4-DOM内部插入prepend-与prependTo"><a href="#4-DOM内部插入prepend-与prependTo" class="headerlink" title="4.DOM内部插入prepend()与prependTo()"></a>4.DOM内部插入prepend()与prependTo()</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57481c3900013c6e05000193.jpg" alt=""></p>
<ol>
<li>append()向每个匹配的元素内部追加内容</li>
</ol>
<ol>
<li>prepend()向每个匹配的元素内部前置内容</li>
</ol>
<ol>
<li>appendTo()把所有匹配的元素追加到另一个指定元素的集合中</li>
</ol>
<ol>
<li>prependTo()把所有匹配的元素前置到另一个指定的元素集合中</li>
</ol>
<h1 id="5-DOM外部插入insertAfter-与insertBefore"><a href="#5-DOM外部插入insertAfter-与insertBefore" class="headerlink" title="5.DOM外部插入insertAfter()与insertBefore()"></a>5.DOM外部插入insertAfter()与insertBefore()</h1><p><img src="http://oncweb6po.bkt.clouddn.com/57481d230001b0f305170241.jpg" alt=""></p>
<ol>
<li>before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。 对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面</li>
</ol>
<ol>
<li>.after()和.insertAfter() 实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面</li>
</ol>
<ol>
<li>before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理</li>
</ol>
<p><strong>注意事项：</strong></p>
<ol>
<li>insertAfter将JQuery封装好的元素插入到指定元素的后面，如果元素后面有元素了，那将后面的元素后移，然后将JQuery对象插入；</li>
</ol>
<ol>
<li>insertBefore将JQuery封装好的元素插入到指定元素的前面，如果元素前面有元素了，那将前面的元素前移，然后将JQuery对象插入；</li>
</ol>
<h1 id="6-DOM节点删除之empty-的基本用法"><a href="#6-DOM节点删除之empty-的基本用法" class="headerlink" title="6.DOM节点删除之empty()的基本用法"></a>6.DOM节点删除之empty()的基本用法</h1><p>empty 顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了 指定元素中的所有子节点。</p>
<p>这个方法不仅移除子元素（和其他后代元素），同样移除元素里的文本。因为，根据说明，元素里任何文本字符串都被看做是该元素的子节点。请看下面的HTML：</p>
<pre><code>&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt;
</code></pre><p>如果我们通过empty方法移除里面div的所有元素，它只是清空内部的html代码，但是标记仍然留在DOM中</p>
<pre><code>//通过empty处理
$(&apos;.hello&apos;).empty()

//结果：&lt;p&gt;慕课网&lt;/p&gt;被移除
&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;
</code></pre><h1 id="7-DOM节点删除之remove-的有参用法和无参用法"><a href="#7-DOM节点删除之remove-的有参用法和无参用法" class="headerlink" title="7.DOM节点删除之remove()的有参用法和无参用法"></a>7.DOM节点删除之remove()的有参用法和无参用法</h1><p>remove与empty一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。</p>
<pre><code>&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt;
$(&apos;.hello&apos;).on(&quot;click&quot;,fn)
</code></pre><p>如果不通过remove方法删除这个节点其实也很简单，但是同时需要把事件给销毁掉，这里是为了防止”内存泄漏”，所以前端开发者一定要注意，绑了多少事件，不用的时候一定要记得销毁</p>
<p>通过remove方法移除div及其内部所有元素，remove内部会自动操作事件销毁方法，所以使用使用起来非常简单</p>
<pre><code>//通过remove处理
$(&apos;.hello&apos;).remove()
//结果：&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt; 全部被移除
//节点不存在了,同事事件也会被销毁
</code></pre><p><strong>remove表达式参数：</strong></p>
<p>remove比empty好用的地方就是可以传递一个选择器表达式用来过滤将被移除的匹配元素集合，可以选择性的删除指定的节点</p>
<p>我们可以通过$()选择一组相同的元素，然后通过remove（）传递筛选的规则，从而这样处理</p>
<pre><code>$(&quot;p&quot;).filter(&quot;:contains(&apos;3&apos;)&quot;).remove()
</code></pre><h1 id="8-DOM节点删除之empty和remove区别"><a href="#8-DOM节点删除之empty和remove区别" class="headerlink" title="8.DOM节点删除之empty和remove区别"></a>8.DOM节点删除之empty和remove区别</h1><h3 id="1-empty方法"><a href="#1-empty方法" class="headerlink" title="(1).empty方法"></a>(1).empty方法</h3><ol>
<li>严格地讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点</li>
</ol>
<ol>
<li>empty不能删除自己本身这个节点<h3 id="2-remove方法"><a href="#2-remove方法" class="headerlink" title="(2).remove方法"></a>(2).remove方法</h3></li>
</ol>
<ol>
<li>该节点与该节点所包含的所有后代节点将同时被删除</li>
</ol>
<ol>
<li>提供传递一个筛选的表达式，删除指定合集中的元素</li>
</ol>
<h1 id="9-DOM节点删除之保留数据的删除操作detach"><a href="#9-DOM节点删除之保留数据的删除操作detach" class="headerlink" title="9.DOM节点删除之保留数据的删除操作detach()"></a>9.DOM节点删除之保留数据的删除操作detach()</h1><p>如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理</p>
<p>detach从字面上就很容易理解。让一个web元素托管。即从当前页面中移除该元素，但保留这个元素的内存模型对象。<br>来看看jquery官方文档的解释：</p>
<blockquote>
<p>这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。</p>
<p>$(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。</p>
</blockquote>
<p>当然这里要特别注意，detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据</p>
<p>参考右边的代码区域，通过 $(“p”).detach()把所有的P元素删除后，再通过append把删除的p元素放到页面上，通过点击文字，可以证明事件没有丢失</p>
<h1 id="10-DOM节点删除之detach-和remove-区别"><a href="#10-DOM节点删除之detach-和remove-区别" class="headerlink" title="10.DOM节点删除之detach()和remove()区别"></a>10.DOM节点删除之detach()和remove()区别</h1><h3 id="1-remove：移除节点"><a href="#1-remove：移除节点" class="headerlink" title="(1).remove：移除节点"></a>(1).remove：移除节点</h3><ol>
<li>无参数，移除自身整个节点以及该节点的内部的所有节点，包括节点上事件与数据</li>
</ol>
<ol>
<li>有参数，移除筛选出的节点以及该节点的内部的所有节点，包括节点上事件与数据<h3 id="2-detach：移除节点"><a href="#2-detach：移除节点" class="headerlink" title="(2).detach：移除节点"></a>(2).detach：移除节点</h3></li>
</ol>
<ol>
<li>移除的处理与remove一致</li>
</ol>
<ol>
<li>与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来</li>
</ol>
<ol>
<li>例如：$(“p”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。</li>
</ol>
<h1 id="11-DOM拷贝clone"><a href="#11-DOM拷贝clone" class="headerlink" title="11.DOM拷贝clone()"></a>11.DOM拷贝clone()</h1><p>克隆节点是DOM的常见操作，jQuery提供一个clone方法，专门用于处理dom的克隆</p>
<blockquote>
<p>.clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。</p>
</blockquote>
<p>clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了</p>
<pre><code>例如：
HTML部分
&lt;div&gt;&lt;/div&gt;

JavaScript部分
$(&quot;div&quot;).on(&apos;click&apos;, function() {//执行操作})

//clone处理一
$(&quot;div&quot;).clone()   //只克隆了结构，事件丢失

//clone处理二
$(&quot;div&quot;).clone(true) //结构、事件与数据都克隆
</code></pre><p>使用上就是这样简单，使用克隆的我们需要额外知道的细节：</p>
<ol>
<li>clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css(‘color’,’red’) 增加了一个颜色</li>
</ol>
<ol>
<li>通过传递true，将所有绑定在原始元素上的事件处理函数复制到克隆元素上</li>
</ol>
<ol>
<li>clone()方法是jQuery扩展的，只能处理通过jQuery绑定的事件与数据</li>
</ol>
<ol>
<li>元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个</li>
</ol>
<h1 id="12-DOM替换replaceWith-和replaceAll"><a href="#12-DOM替换replaceWith-和replaceAll" class="headerlink" title="12.DOM替换replaceWith()和replaceAll()"></a>12.DOM替换replaceWith()和replaceAll()</h1><h3 id="1-replaceWith-newContent-："><a href="#1-replaceWith-newContent-：" class="headerlink" title="(1). .replaceWith( newContent )："></a>(1). .replaceWith( newContent )：</h3><p>用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合</p>
<p>简单来说：用$()选择节点A，调用replaceWith方法，传入一个新的内容B（HTML字符串，DOM元素，或者jQuery对象）用来替换选中的节点A</p>
<p>看个简单的例子：一段HTML代码</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;第一段&lt;/p&gt;
    &lt;p&gt;第二段&lt;/p&gt;
    &lt;p&gt;第三段&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>替换第二段的节点与内容</p>
<pre><code>$(&quot;p:eq(1)&quot;).replaceWith(&apos;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos;)
</code></pre><p>通过jQuery筛选出第二个p元素，调用replaceWith进行替换，结果如下</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;第一段&lt;/p&gt;
    &lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos;
    &lt;p&gt;第三段&lt;/p&gt;
&lt;/div&gt;
</code></pre><h3 id="2-replaceAll-target-："><a href="#2-replaceAll-target-：" class="headerlink" title="(2).replaceAll( target ) ："></a>(2).replaceAll( target ) ：</h3><p>用集合的匹配元素替换每个目标元素</p>
<p>.replaceAll()和.replaceWith()功能类似，但是目标和源相反，用上述的HTML结构，我们用replaceAll处理<br>$(‘<a style="color:red">替换第二段的内容</a>‘).replaceAll(‘p:eq(1)’)</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="(3).总结"></a>(3).总结</h3><ol>
<li>.replaceAll()和.replaceWith()功能类似，主要是目标和源的位置区别</li>
</ol>
<ol>
<li>.replaceWith()与.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序</li>
</ol>
<ol>
<li>.replaceWith()方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用</li>
</ol>
<ol>
<li>.replaceWith()方法返回的jQuery对象引用的是替换前的节点，而不是通过replaceWith/replaceAll方法替换后的节点</li>
</ol>
<h1 id="13-DOM包裹wrap-方法"><a href="#13-DOM包裹wrap-方法" class="headerlink" title="13.DOM包裹wrap()方法"></a>13.DOM包裹wrap()方法</h1><p>如果要将元素用其他元素包裹起来，也就是给它增加一个父元素，针对这样的处理，JQuery提供了一个wrap方法</p>
<h3 id="1-wrap-wrappingElement-："><a href="#1-wrap-wrappingElement-：" class="headerlink" title="(1).wrap( wrappingElement )："></a>(1).wrap( wrappingElement )：</h3><p>在集合中匹配的每个元素周围包裹一个HTML结构</p>
<p>简单的看一段代码：</p>
<pre><code>&lt;p&gt;p元素&lt;/p&gt;
给p元素增加一个div包裹
$(&apos;p&apos;).wrap(&apos;&lt;div&gt;&lt;/div&gt;&apos;)
</code></pre><p>最后的结构，p元素增加了一个父div的结构</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><h3 id="2-wrap-function-："><a href="#2-wrap-function-：" class="headerlink" title="(2).wrap( function ) ："></a>(2).wrap( function ) ：</h3><p>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象</p>
<p>使用后的效果与直接传递参数是一样，只不过可以把代码写在函数体内部，写法不同而已</p>
<p>以第一个案例为例：</p>
<pre><code>$(&apos;p&apos;).wrap(function() {
    return &apos;&lt;div&gt;&lt;/div&gt;&apos;;   //与第一种类似，只是写法不一样
})
</code></pre><h3 id="3-注意："><a href="#3-注意：" class="headerlink" title="(3).注意："></a>(3).注意：</h3><p>.wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套了好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。</p>
<h1 id="14-DOM包裹unwrap-方法"><a href="#14-DOM包裹unwrap-方法" class="headerlink" title="14.DOM包裹unwrap()方法"></a>14.DOM包裹unwrap()方法</h1><p>我们可以通过wrap方法给选中元素增加一个包裹的父元素。相反，如果删除选中元素的父元素要如何处理 ?</p>
<p>jQuery提供了一个unwarp()方法 ，作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。</p>
<p>看一段简单案例：</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>我要删除这段代码中的div，一般常规的方法会直接通过remove或者empty方法</p>
<pre><code>$(&apos;div&apos;).remove();
</code></pre><p>但是如果我还要保留内部元素p，这样就意味着需要多做很多处理，步骤相对要麻烦很多，为了更便捷，jQuery提供了unwarp方法很方便的处理了这个问题</p>
<pre><code>$(&apos;p&apos;).unwarp();
</code></pre><p>找到p元素，然后调用unwarp方法，这样只会删除父辈div元素了</p>
<p>结果：</p>
<pre><code>&lt;p&gt;p元素&lt;/p&gt;
</code></pre><p>这个方法比较简单，也不接受任何参数，注意参考下案例的使用即可</p>
<h1 id="15-DOM包裹wrapAll-方法"><a href="#15-DOM包裹wrapAll-方法" class="headerlink" title="15.DOM包裹wrapAll()方法"></a>15.DOM包裹wrapAll()方法</h1><h3 id="1-wrapAll-wrappingElement-："><a href="#1-wrapAll-wrappingElement-：" class="headerlink" title="(1).wrapAll( wrappingElement )："></a>(1).wrapAll( wrappingElement )：</h3><p>给集合中匹配的元素增加一个外面包裹HTML结构</p>
<p>简单的看一段代码：</p>
<pre><code>&lt;p&gt;p元素&lt;/p&gt;
&lt;p&gt;p元素&lt;/p&gt;
</code></pre><p>给所有p元素增加一个div包裹</p>
<pre><code>$(&apos;p&apos;).wrapAll(&apos;&lt;div&gt;&lt;/div&gt;&apos;)
</code></pre><p>最后的结构，2个P元素都增加了一个父div的结构</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><h3 id="2-wrapAll-function-："><a href="#2-wrapAll-function-：" class="headerlink" title="(2).wrapAll( function ) ："></a>(2).wrapAll( function ) ：</h3><p>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象</p>
<p>通过回调的方式可以单独处理每一个元素<br>以上面案例为例，</p>
<pre><code>$(&apos;p&apos;).wrapAll(function() {
    return &apos;&lt;div&gt;&lt;div/&gt;&apos;; 
})
</code></pre><p>以上的写法的结果如下，等同于warp的处理了</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><h1 id="16-DOM包裹wrapInner-方法"><a href="#16-DOM包裹wrapInner-方法" class="headerlink" title="16.DOM包裹wrapInner()方法"></a>16.DOM包裹wrapInner()方法</h1><p>如果要将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素，针对这样的处理，JQuery提供了一个wrapInner方法</p>
<h3 id="1-wrapInner-wrappingElement-："><a href="#1-wrapInner-wrappingElement-：" class="headerlink" title="(1).wrapInner( wrappingElement )："></a>(1).wrapInner( wrappingElement )：</h3><p>给集合中匹配的元素的内部，增加包裹的HTML结构</p>
<p>听起来有点绕，可以用个简单的例子描述下，简单的看一段代码：</p>
<pre><code>&lt;div&gt;p元素&lt;/div&gt;
&lt;div&gt;p元素&lt;/div&gt;
给所有元素增加一个p包裹
$(&apos;div&apos;).wrapInner(&apos;&lt;p&gt;&lt;/p&gt;&apos;)
</code></pre><p>最后的结构，匹配的di元素的内部元素被p给包裹了</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><h3 id="2-wrapInner-function-："><a href="#2-wrapInner-function-：" class="headerlink" title="(2).wrapInner( function ) ："></a>(2).wrapInner( function ) ：</h3><p>允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容</p>
<p>以上面案例为例，</p>
<pre><code>$(&apos;div&apos;).wrapInner(function() {
    return &apos;&lt;p&gt;&lt;/p&gt;&apos;; 
})
</code></pre><p>以上的写法的结果如下，等同于第一种处理了</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</code></pre><p><strong>注意：</strong><br> 当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。</p>
<h1 id="17-jQuery遍历之children-方法"><a href="#17-jQuery遍历之children-方法" class="headerlink" title="17.jQuery遍历之children()方法"></a>17.jQuery遍历之children()方法</h1><p>jQuery是一个合集对象，如果想快速查找合集里面的第一级子元素，此时可以用children()方法。这里需要注意：.children(selector) 方法是返回匹配元素集合中每个元素的所有子元素（仅儿子辈，这里可以理解为就是父亲-儿子的关系）</p>
<p><strong>理解节点查找关系：</strong></p>
<pre><code>&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>代码如果是$(“div”).children()，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。</p>
<p><strong>children()无参数</strong><br>允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过children是匹配合集中每一给元素的第一级子元素</p>
</blockquote>
<p><strong>.children()方法选择性地接受同一类型选择器表达式</strong></p>
<pre><code>$(&quot;div&quot;).children(&quot;.selected&quot;)
</code></pre><p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
<hr>
<pre><code>.detach() 隐身

.remove 自杀

.empty 身体被掏空

.clone 复制 （true全复制 false 浅复制，无事件）

.replaceWith 删除并替换节点（结合.replaceAll()来记）

.wrap 每个人加个爸爸

.unwrap 爸爸没了

.wrapAll 所有人加个爸爸

.wrapAll（function）每个人加个爸爸

.wrapInner 加个儿子

.children() 找儿子
</code></pre><h1 id="18-jQuery遍历之find-方法"><a href="#18-jQuery遍历之find-方法" class="headerlink" title="18.jQuery遍历之find()方法"></a>18.jQuery遍历之find()方法</h1><p>jQuery是一个合集对象，如果想快速查找DOM树中的这些元素的后代元素，此时可以用find()方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系）</p>
<p><strong>理解节点查找关系：</strong></p>
<pre><code>&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>代码如果是$(“div”).find(“li”)，此时，li与div是祖辈关系，通过find方法就可以快速的查找到了。</p>
<p><strong>.find()方法要注意的知识点：</strong></p>
<ol>
<li>find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。</li>
</ol>
<ol>
<li>与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 ‘*’。<br>find只在后代中遍历，不包括自己。</li>
</ol>
<ol>
<li>选择器 context 是由 .find() 方法实现的；因此，$(‘.item-ii’).find(‘li’) 等价于 $(‘li’, ‘.item-ii’)(找到类名为item-ii的标签下的li标签)。</li>
</ol>
<p><strong>注意重点：</strong></p>
<ol>
<li>.find()和.children()方法是相似的</li>
</ol>
<ol>
<li>.children只查找第一级的子节点</li>
</ol>
<ol>
<li>.find查找范围包括子节点的所有后代节点</li>
</ol>
<h1 id="19-jQuery遍历之parent-方法"><a href="#19-jQuery遍历之parent-方法" class="headerlink" title="19.jQuery遍历之parent()方法"></a>19.jQuery遍历之parent()方法</h1><p>jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的父元素（这里可以理解为就是父亲-儿子的关系），此时可以用parent()方法</p>
<p>因为是父元素，这个方法只会向上查找一级</p>
<p><strong>理解节点查找关系：</strong></p>
<pre><code>&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>查找ul的父元素div, $(ul).parent()，就是这样简单的表达</p>
<p><strong>parent()无参数</strong></p>
<p>parent()方法允许我们能够在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素</p>
</blockquote>
<p><strong>parent()方法选择性地接受同一型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<h1 id="20-jQuery遍历之parents-方法"><a href="#20-jQuery遍历之parents-方法" class="headerlink" title="20.jQuery遍历之parents()方法"></a>20.jQuery遍历之parents()方法</h1><p>jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的所有祖辈元素，此时可以用parents()方法</p>
<p>其实也类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点</p>
<p><strong>理解节点查找关系：</strong></p>
<pre><code>&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><p>在li节点上找到祖 辈元素div， 这里可以用$(“li”).parents()方法</p>
<p><strong>parents()无参数</strong></p>
<p>parents()方法允许我们能够在DOM树中搜索到这些元素的祖先元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象;</p>
<p>返回的元素秩序是从离他们最近的父级元素开始的</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过parent是匹配合集中所有元素的祖辈元素</p>
</blockquote>
<p><strong>parents()方法选择性地接受同一型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<p><strong>注意事项：</strong></p>
<blockquote>
<p>1 .parents()和.parent()方法是相似的，但后者只是进行了一个单级的DOM树查找<br>2  $( “html” ).parent()方法返回一个包含document的集合，而$( “html” ).parents()返回一个空集合。</p>
</blockquote>
<h1 id="21-jQuery遍历之closest-方法"><a href="#21-jQuery遍历之closest-方法" class="headerlink" title="21.jQuery遍历之closest()方法"></a>21.jQuery遍历之closest()方法</h1><p>以选定的元素为中心，往内查找可以通过find、children方法。如果往上查找，也就是查找当前元素的父辈祖辈元素，jQuery提供了closest()方法，这个方法类似parents但是又有一些细微的区别，属于使用频率很高的方法</p>
<p><strong>closest()方法接受一个匹配元素的选择器字符串</strong></p>
<p>从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素</p>
<p>例如：在div元素中，往上查找所有的li元素，可以这样表达</p>
<pre><code>$(&quot;div&quot;).closet(&quot;li&apos;)
</code></pre><p><strong>注意：jQuery是一个合集对象，所以通过closest是匹配合集中每一个元素的祖先元素</strong></p>
<p><strong>closest()方法给定的jQuery集合或元素来过滤元素</strong></p>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个jQuery的对象</p>
<p><strong>注意事项</strong>：在使用的时候需要特别注意下</p>
<p>粗看.parents()和.closest()是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了</p>
<ol>
<li>起始位置不同：.closest开始于当前元素 .parents开始于父元素</li>
</ol>
<ol>
<li>遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合</li>
</ol>
<ol>
<li>结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象</li>
</ol>
<h1 id="22-jQuery遍历之next-方法"><a href="#22-jQuery遍历之next-方法" class="headerlink" title="22.jQuery遍历之next()方法"></a>22.jQuery遍历之next()方法</h1><p>jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合，此时可以用next()方法</p>
<p><strong>理解节点查找关系：</strong></p>
<p>如下class=”item-1”元素就是红色部分，那蓝色的class=”item-2”就是它的兄弟元素</p>
<pre><code>&lt;ul class=&quot;level-3&quot;&gt;
    &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><strong>next()无参数</strong></p>
<p>允许我们找遍元素集合中紧跟着这些元素的直接兄弟元素，并根据匹配的元素创建一个新的 jQuery 对象。</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素</p>
</blockquote>
<p><strong>next()方法选择性地接受同一类型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<h1 id="23-jQuery遍历之prev-方法"><a href="#23-jQuery遍历之prev-方法" class="headerlink" title="23.jQuery遍历之prev()方法"></a>23.jQuery遍历之prev()方法</h1><p>jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合，此时可以用prev()方法</p>
<p><strong>理解节点查找关系：</strong></p>
<p>如下蓝色的class=”item-2”的li元素，红色的节点就是它的prev兄弟节点</p>
<pre><code>&lt;ul class=&quot;level-3&quot;&gt;
    &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><strong>prev()无参数</strong></p>
<p>取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过prev是匹配合集中每一个元素的上一个兄弟元素</p>
</blockquote>
<p><strong>prev()方法选择性地接受同一类型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<h1 id="24-jQuery遍历之siblings"><a href="#24-jQuery遍历之siblings" class="headerlink" title="24.jQuery遍历之siblings()"></a>24.jQuery遍历之siblings()</h1><p>jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素的同辈元素，此时可以用siblings()方法</p>
<p><strong>理解节点查找关系：</strong></p>
<p>如下蓝色的class=”item-2”的li元素，红色的节点就是它的siblings兄弟节点</p>
<pre><code>&lt;ul class=&quot;level-3&quot;&gt;
    &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p><strong>siblings()无参数</strong></p>
<p>取得一个包含匹配的元素集合中每一个元素的同辈元素的元素集合</p>
<blockquote>
<p>注意：jQuery是一个合集对象，所以通过siblings是匹配合集中每一个元素的同辈元素</p>
</blockquote>
<p><strong>siblings()方法选择性地接受同一类型选择器表达式</strong></p>
<blockquote>
<p>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</p>
</blockquote>
<h1 id="25-jQuery遍历之add-方法"><a href="#25-jQuery遍历之add-方法" class="headerlink" title="25.jQuery遍历之add()方法"></a>25.jQuery遍历之add()方法</h1><p>jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？jQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中</p>
<blockquote>
<p>.add()的参数可以几乎接受任何的$()，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用。</p>
</blockquote>
<p>简单的看一个案例：</p>
<p>操作：选择所有的li元素，之后把p元素也加入到li的合集中</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;list item 1&lt;/li&gt;
    &lt;li&gt;list item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新的p元素&lt;/p&gt;
</code></pre><h3 id="处理一：传递选择器"><a href="#处理一：传递选择器" class="headerlink" title="处理一：传递选择器"></a>处理一：传递选择器</h3><pre><code>$(&apos;li&apos;).add(&apos;p&apos;)
</code></pre><h3 id="处理二：传递dom元素"><a href="#处理二：传递dom元素" class="headerlink" title="处理二：传递dom元素"></a>处理二：传递dom元素</h3><pre><code>$(&apos;li&apos;).add(document.getElementsByTagName(&apos;p&apos;)[0])
</code></pre><p>还有一种方式，就是动态创建P标签加入到合集，然后插入到指定的位置，但是这样就改变元素的本身的排列了</p>
<pre><code>$(&apos;li&apos;).add(&apos;&lt;p&gt;新的p元素&lt;/p&gt;&apos;).appendTo(目标位置)
</code></pre><h1 id="26-jQuery遍历之each"><a href="#26-jQuery遍历之each" class="headerlink" title="26.jQuery遍历之each()"></a>26.jQuery遍历之each()</h1><p>jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。比如我们操作$(“li”).css(‘’) 给所有的li设置style值，因为jQuery是一个合集对象，所以css方法内部就必须封装一个遍历的方法，被称为隐式迭代的过程。要一个一个给合集中每一个li设置颜色，这里方法就是each</p>
<p>.each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数</p>
<p>所以大体上了解3个重点：</p>
<ol>
<li>each是一个for循环的包装迭代器</li>
</ol>
<ol>
<li>each通过回调的方式处理，并且会有2个固定的实参，索引与元素</li>
</ol>
<ol>
<li>each回调方法中的this指向当前迭代的dom元素</li>
<li><p>看一个简单的案例</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;慕课网&lt;/li&gt;
    &lt;li&gt;Aaron&lt;/li&gt;
&lt;/ul&gt;
</code></pre></li>
</ol>
<p>开始迭代li，循环2次</p>
<pre><code>$(&quot;li&quot;).each(function(index, element) {
     index 索引 0,1
     element是对应的li节点 li,li
     this 指向的是li
})
</code></pre><p>这样可以在循环体会做一些逻辑操作了，如果需要提前退出，可以以通过返回 false以便在回调函数内中止循</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/person.jpg"
               alt="ZhangWei2222" />
          <p class="site-author-name" itemprop="name">ZhangWei2222</p>
           
              <p class="site-description motion-element" itemprop="description">Dream high</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">59</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangWei2222</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
