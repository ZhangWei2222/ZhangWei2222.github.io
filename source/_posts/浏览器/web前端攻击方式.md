---
title: web前端攻击方式
date: 2019-11-18 11:11:37
categories:
- 浏览器
tags:
comments: false
---

## CSRF   

> 跨站点伪造请求(cross site request forgery),利用的是网站对用户网页浏览器的信任。攻击者盗用你的身份，以你的名义发送恶意请求，会造成个人隐私泄露以及财产安全。
>
> 常见场景：以你名义发送邮件，发消息；盗取你的账号，购买商品，虚拟货币转账等等。

### 攻击流程
1. 用户登录受信任网站A，并在本地生成保存Cookie
2. 在不登出A的情况下，访问病毒网站B
3. 网站B要求访问A，发出请求
4. 根据网站B的请求，浏览器带着保存的Cookie访问A
5. A不知道上述请求是来自用户还是病毒网站B，由于请求中带上了Cookie，A会根据用户的权限处理请求，达到模拟用户操作的目的

### 防御

#### 1、验证 HTTP Referer 字段

HTTP的referer字段保存了http的来源地址，受访网站可以验证这个地址是否合法，如果不合法，则有可能为CSRF攻击，拒绝该请求。但这种方法不是万无一失的，referer的值是由浏览器提供的，我们并不能保证浏览器没有安全漏洞，目前已有一些方法可以篡改referer值，而且有些用户为了保护自己的隐私可以设置浏览器在发送请求时不再提供referer值。

#### 2、在请求地址中添加token并验证

CSRF利用cookie来进行攻击，那么我们可以在请求中添加不可伪造的信息并不存在与cookie中，可以在请求中以参数形式随机产生一个token，并在服务器建立一个拦截器验证这个token。

#### 3、在HTTP头中自定义属性并验证

解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

#### 4、Cookie Hashing（所有表单都包含同一个伪随机数）

#### 5、验证码

每次用户提交都需要用户在表单中填写一个图片上的随机字符串

## XSS  

> 跨站脚本攻击(corss site scripting),利用的是用户对指定网站的信任。攻击者通过在网页中注入恶意脚本，当用户浏览网页时，恶意脚本执行，控制用户浏览器行为的一种攻击方式。
>
> 常见场景：强制弹出广告页面，刷流量，传播跨站脚本蠕虫，网页挂马；窃取用户Cookie，获取用户隐私，盗取用户账号；劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账、强制发表日志、发送电子邮件等。


### 分类
1. 反射型xss。出现在URL中作为参数提交到服务器，服务器解析并响应，响应结果中包含xss代码，最后浏览器解析执行。
2. 存储型xss。攻击者输入恶意的脚本数据存入数据库，当其他用户读取时，用户浏览器将解析执行这段脚本。

### 防御

#### 1、浏览器自带防御

现今主流浏览器（IE，Chrome 和 Safari）带有 HTTP `X-XSS-Protection` 响应头，当检测到跨站脚本攻击(XSS)时，浏览器将停止加载页面。

`X-XSS-Protection` 响应头有以下 4 个值：
- `X-XSS-Protection: 0` 禁止XSS过滤
- `X-XSS-Protection: 1` 启用XSS过滤（通常浏览器是默认的）。如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。
- `X-XSS-Protection: 1; mode=block` 启用XSS过滤。如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。
- `X-XSS-Protection: 1; report=<reporting-uri>` 启用XSS过滤。如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。

**注意**
- 存在兼容性问题
- 只对反射型 XSS 有一定的防御力，其原理也只是检查 URL 和 DOM 中元素的相关性

#### 2、转义

在客户端和服务端，对用户输入的数据进行转义。常见需要转义的特殊字符如 `<`，`>`，`&`，`"`，`'`。

```
function escapeHTML(str) {
    if (!str) return '';
    str = str.replace(/&/g, "&amp;");
    str = str..replace(/</g, "&lt;");
    str = str..replace(/>/g, "&gt;");
    str = str..replace(/"/g, "&quot;");
    str = str..replace(/'/g, "&#39;");
    return str;
};
```

#### 3、过滤

常见于富文本内容，因为其需要保留 HTML，所以不能直接使用转义方法，而可以通过**使用白名单**，来允许特定的 HTML 标签及属性，来抵御 XSS 攻击。

#### 4、内容安全策略（CSP）

白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。

1. 通过 HTTP 头信息的 Content-Security-Policy 的字段：

```
Content-Security-Policy: script-src 'self';
                         object-src 'none';
                         style-src cdn.example.org third-party.org;
                         child-src https:
```

2. 通过网页的 <meta> 标签

```
<meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:">
```

上述解释

- 脚本：只信任当前域名
- `<object>`标签：不信任任何 URL，即不加载任何资源
- 样式表：只信任 `cdn.example.org`和`third-party.org`
- 页面子内容，如 `<frame>`、`<iframe>`：必须使用HTTPS协议加载
- 其他资源：没有限制
- 启用后，不符合 CSP 的外部资源就会被阻止加载。


## SQL注入
什么是SQL注入？攻击者向服务器提交恶意的sql代码，导致源程序执行包含恶意代码的sql。

### 典型实例为：
用户输入的信息带有 delete 、drop等危害性十足的sql，就像用户登录时输入了用户名 ' or 1=1 #（mysql是#，oracle是--），那么在我们没有任何防御措施的情况下就会变为“select * from user where username='' or 1=1 # passport=md5()”。#后面是注释，所以一定会执行

  防止SQL注入

1）在JAVA中使用预编译PreparedStatement；

2）对数据库特殊字符进行转义处理或编码转换；

3）在应用发布前，使用专业的sql 注入检测工具进行检测，及时发现和修补sql注入漏洞；

## <四>文件上传漏洞
-典型实例为：
没有对用户上传的文件做校验，恶意用户长时间上传超大文件占用系统资源，上传可执行脚本获取获取服务器信息

-推荐防御措施：
对用户上传做限流，每个用户每天最多上传多少内容。
对文件类型进行判断，不能通过后缀名判断，而要通过判断魔数（文件起始的几个字节）来判断，很多文件类型的魔数是不变的。


## <五>DDOS：分布式拒绝服务攻击
-典型实例为：
1.攻击者提前控制大量计算机，并在某一时刻指挥大量计算机同时对某一服务器进行访问来达到瘫痪主机的目的。

2.相信大家都知道TCP三次握手的机制，（如不了解请参考文章底部补充）攻击者利用此机制对服务器返回的ACK确认包不回应，这样服务器就会存在大量的等待列表，不断重试，等待队列满了以后不再接受TCP连接，从而阻挡了正常用户的使用

3.攻击者向DNS服务器发送海量的域名解析请求，DNS首先查缓存，如果缓存不存在的话会去递归调用上级服务器查询，直到查询到全球13台根服务器为止，当解析请求过多时正常用户访问就会出现DNS解析超时问题

-推荐防御措施：
使用缓存，当缓存中存在时就直接取出，不要频繁的连接数据库。

缩短 SYN Timeout时间，即缩短从接受到SYN报文到确定这个报文无效并丢弃该连接的时间。

限制源ip每秒发起的DNS请求等
