---
title: this指向练习题
date: 2021-02-24 09:35:48
categories:
- JavaScript
tags:
- this/call/apply/bind
comments: true
---

普通方法和对象方法 this 指向结论：

1. this的指向，是在函数被调用的时候确定的

2. 函数调用时，看其是否被某个对象所拥有，假如被某个对象拥有，那么函数中的this，指向的是其拥有的对象
   
   > 例如：obj.fn()。fn() 函数被 obj 所拥有，那么 fn 里面的 this，指向的是 obj
   
3. 如果函数独立调用，那么该函数内部的this，则指向undefined。在非严格模式中，当this指向undefined时，它会被自动指向全局对象。
  
   > 例如aaa() 是独立调用，那么aaa函数里面的this会指向undefined，在非严格模式下面指向的是全局对象

<!-- more -->

## 练习

```js
var value = 1;

var foo = {
  value: 2,
  bar: function () {
    return this.value;
  }
}

//示例1
console.log(foo.bar()); // 2
//示例2
console.log((foo.bar)()); // 2
//示例3
console.log((foo.bar = foo.bar)()); // 1
//示例4
console.log((false || foo.bar)()); // 1
//示例5
console.log((foo.bar, foo.bar)()); // 1
// 注意后面3个例子，其实都是bar函数, 已经脱离了foo context
bar == (foo.bar = foo.bar);  // true foo.bar = foo.bar是一个语句，调用时执行该语句返回一个function，已丢失foo，又因为全局调用，所以this被赋值为当前全局对象。
bar == (foo.bar,foo.bar); // true
bar == (false || foo.bar); // true
```



独立调用，非严格模式下 this 指向全局对象

```js
// demo1
var a = 20;
function fn() {
  console.log(this.a);
}
fn(); 

// demo02
var a = 20;
function fn() {
  function foo() {
    console.log(this.a);
  }
  foo();
}
fn();

// demo3
// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局
function fn() {
  'use strict';
  console.log(this);
}

// demo04
fn();  // fn是调用者，独立调用
window.fn();  // fn是调用者，被window所拥有

function foo() {
  console.log(this.a)
}

function active(fn) {
  fn(); // 真实调用者，为独立调用
}

var a = 20;
var obj = {
  a: 10,
  getA: foo
}

active(obj.getA);
```



obj.c 里面的 this.a 是赋值语句，并没有调用，this 是在调用时被决定的，现在只是定义，默认指向全局对象，this.a === window.a

```js
// demo01
var a = 20;
var obj = {
  a: 10,
  c: this.a + 20,
  fn: function () {
    return this.a;
  }
}

console.log(obj.c);
console.log(obj.fn());

// demo02
var a = 20;
function getA() {
  return this.a;
}
var foo = {
  a: 10,
  getA: getA
}
console.log(foo.getA());  // 10
```



## 参考文章

[前端基础进阶（七）：全方位解读this](https://www.jianshu.com/p/d647aa6d1ae6)