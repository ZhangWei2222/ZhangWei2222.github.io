---
title: call、apply模拟实现
date: 2021-03-02 21:44:48
categories:
- JavaScript
tags:
- this/call/apply/bind
comments: true
---

## 模拟思路

1. 将当前函数设置为 call、apply 对象的属性
2. 执行该函数
3. 删除该函数
4. 返回值

<!-- more -->



## call() 模拟实现

### es5实现

```js
//简单模拟Symbol属性
function mySymbol(obj) {
  var unique_proper = "00" + Math.random();
  if (obj.hasOwnProperty(unique_proper)) {
    arguments.callee(obj)//如果obj已经有了这个属性，递归调用，直到没有这个属性
  } else {
    return unique_proper;
  }
}

Function.prototype.call2 = function (context) {
  var context = Object(context) || window;
  var fn = mySymbol(context);
  context[fn] = this;

  var args = [];
  for(var i = 1, len = arguments.length; i < len; i++) {
    args.push('arguments[' + i + ']');
  }

  var result = eval('context[fn](' + args +')');

  delete context.fn
  return result;
}
```



### es6 实现

```js
Function.prototype.call2 = function (ctx, ...args) {
  // 获取调用`call2`的函数本身，用this获取，如果context不存在，则为window
  let context = Object(ctx) || window;
  let fn = Symbol(); // 保证fn函数的唯一性
  context[fn] = this;

  let result = context[fn](...args) //把参数传给context.fn执行返回

  delete context.fn
  return result;
}

// 测试一下
var value = 2;

var obj = {
  value: 1
}

function bar(name, age) {
  console.log(this.value);
  return {
    value: this.value,
    name: name,
    age: age
  }
}

bar.call(null); // 2

console.log(bar.call2(obj, 'kevin', 18));
// 1
// Object {
//    value: 1,
//    name: 'kevin',
//    age: 18
// }
```



## apply() 模拟实现

### es5实现

```js
//简单模拟Symbol属性
function mySymbol(obj) {
  var unique_proper = "00" + Math.random();
  if (obj.hasOwnProperty(unique_proper)) {
    arguments.callee(obj)//如果obj已经有了这个属性，递归调用，直到没有这个属性
  } else {
    return unique_proper;
  }
}

Function.prototype.myApply = function (context, arr) {
  var context = Object(context) || window;
  var fn = mySymbol(context);
  context[fn] = this;

  var result;
  if (!arr) {
    result = context[fn]();
  }
  else {
    var args = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      args.push('arr[' + i + ']');
    }
    result = eval('context[fn](' + args + ')')
  }

  delete context.fn
  return result;
}
```



### es6实现

```js
Function.prototype.myApply=function(ctx, args){
  // 获取调用`myApply`的函数本身，用this获取，如果context不存在，则为window
  let context = Object(ctx) || window;
  let fn = Symbol(); // 保证fn函数的唯一性
  context[fn] = this;

  let arr = args ? args : [];
  let result = context[fn](...arr);
  // 从上下文中删除函数引用
  delete context.fn;
  return result;
}

// 测试
var obj ={
  name: "xb",
  getName: function(age){
    console.log(this.name + ":" + age);
  }
}

var obj2 ={
  name: "xb",
  getName: function(age){
    return {
      value: this.name,
      age: age
    }
  }
}

var name = "window.name";

var me = {
  name: "axuebin"
}

obj.getName(25); // xb:25
obj.getName.myApply(); // window.name:undefined
obj.getName.myApply(null, [25]); // window.name:25
obj.getName.myApply(me, [25]); // axuebin:25
obj2.getName.myApply(me, [25]); // {value: "axuebin", age: 25}
```



### 用apply() 实现 call()

```js
Function.prototype.callOne = function(context) {
    return this.myApply(([].shift.myApply(arguments)), arguments)
    //巧妙地运用上面已经实现的applyFive函数
}

// 测试一下
var value = 2;

var obj = {
  value: 1
}

function bar(name, age) {
  console.log(this.value);
  return {
    value: this.value,
    name: name,
    age: age
  }
}

bar.callOne(null); // 2

console.log(bar.callOne(obj, 'kevin', 18));
// 1
// Object {
//    value: 1,
//    name: 'kevin',
//    age: 18
// }
```



## bind() 模拟实现

### es5实现





### es6实现

```js
Function.prototype.bind = function (context,...args) {
  if(typeof this !== 'function'){
    return new TypeError('must be function');
  }
  let self = this;
  return function bound(...newArgs){
    if(this instanceof bound){
      return new self(...args, ...newArgs);
    }
    return self.apply(context,...args,...newArgs);
  }
}
```



### 用call()、apply()实现









## 参考文章

[JavaScript深入之call和apply的模拟实现](https://juejin.cn/post/6844903476477034510#heading-2)

[JavaScript基础心法——call apply bind](https://github.com/axuebin/articles/issues/7)

更高阶版本：[面试官问：能否模拟实现JS的call和apply方法](https://juejin.cn/post/6844903728147857415#heading-6)





