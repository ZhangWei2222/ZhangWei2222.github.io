---
title: 闭包&变量污染&垃圾机制
date: 2019-03-06 15:32:37
categories:
- JavaScript
tags:
comments: false
---

### 闭包

闭包是JS总一个主要的设计理念，闭包简单来说，是 函数+函数里的变量 称作闭包。



    function test() {     
      var i = 0;     
      return function() {         
        console.log(++i)     
      } 
    } 
    var doAdd = test(); 
    doAdd(); 



#### 好处

1. 闭包里的变量，是安全的，并且是对于全局是隐藏的，在不对外暴露操作的方法时候，外界无法直接改变闭包中变量的值
2. 通过闭包的思维，来管理对象的属性变更的操作，可以增加代码的可读性，也易于管理



#### 缺点

1、闭包会使函数中的变量保存在内存中，内存消耗很大，所以不能滥用闭包，解决办法是，退出函数之前，将不使用的局部变量删除。

2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。



#### 应用场景

**1、小范围代替全局变量**

全局变量有变量污染和变量安全问题，可以使用闭包（匿名函数），外部无法访问变量



**2、采用函数引用方式的setimeout调用**

原生的setTimeout有一个缺陷，你传递的第一个函数不能带参数

所以可以调用另一个函数来返回一个内部函数的调用，将这个内部函数对象的引用传递给settimeout函数。内部函数执行时需要的参数，在调用外部函数时传递给它。

    function callLater(paramA, paramB, paramC) {       
      /*使用函数表达式创建并放回一个匿名内部函数的引用*/       
      return (function () {           
        /*          
        这个内部函数将被setTimeout函数执行；          
        并且当它被执行时，          
        它能够访问并操作外部函数传递过来的参数          
        */           
        paramA[paramB] = paramC;       
      });   
    }    
    /*  
    调用这个函数将在它的执行上下文中创建，并最终返回内部函数对象的引用  
    传递过来的参数，内部函数在最终被执行时，将使用外部函数的参数  
    返回的引用被赋予了一个变量  
    */  
    var funcRef = callLater(elStyle, "display", "none");   
    /*调用setTimeout函数，传递内部函数的引用作为第一个参数*/   
    hideMenu = setTimeout(funcRef, 500); 

**3、回调（return)**



**4、访问私有函数和私有变量的公有函数**

一个函数内部的私有变量，外部想要访问，可以通过其内部的方法，能通过作用链访问到变量

![img](http://s3.mogucdn.com/mlcdn/c45406/190614_8a498i8a2ihkh6gkdi3hgh4h05c5h_707x287.png)







### 作用域

每一个变量、函数都有其作用的范围，超出作用不得使用，这个叫做作用域



全局变量、局部变量

![img](http://s3.mogucdn.com/mlcdn/c45406/190614_36fedfhi7ej7e0ab132859091i5dh_640x336.png)



### 作用域链

函数被创建或者被定义的时候，函数对象有一个内部属性[[scope]]，它引用了一条作用域链，也可以理解为对象列表。

在函数func创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，当执行函数的时候，会创建一个该函数的执行期上下文的内部对象，当这个执行期上下文被创建时，他的作用域链会被初始化为当前执行的函数对象里的[[scope]]属性中所包含的对象，然后解释器创建一个活动对象，这个活动对象包含当前这个执行函数里所有的局部变量（内部var 声明的），命名参数（形参），参数合集（arguments）以及this。然后此对象会被推入执行期上下文里作用域链的前端。

![img](http://s11.mogucdn.com/mlcdn/c45406/190614_12j493aebd76bke685483d16ek241_776x625.png)

当函数执行完毕，该执行期上下文就会被销毁。



作用域链的作用是用于解析标识符，函数执行上下文被创建好之后，解释器开始自上至下的解释代码了，这时每遇到一个标示符，都会遍历这个执行上下文里的作用域链：首先在最顶层的活动对象里去找，如果没找到，再找下一层，最终找到全局作用域，如果还没找到一般会报语法错误，但是当对未定义的变量执行赋值运算时，解释器会在全局作用域创建该变量并赋值。这一点很重要，编程时要小心，防止污染全局环境，或者造成内存泄露的问题。



### 减少全局变量污染

*全局变量的三种定义方式：*

1. 在任何函数外部var声明一个变量；
2. 在window对象中声明一个变量；
3. 在函数内部不先var声明变量后直接使用变量（隐式全局变量）



**1、使用唯一全局变量**

这个方法是在全局声明一个对象字面量，作为我们的全局变量容器，这样全局就只出现一个全局变量：

	var myApp = {};

此时，变量myApp就成了我们的变量容器了，所有的全局变量都可以保存在这里：

    myApp.students = {      
      name:"小明"，      
      age:18   
    }; 



**2、使用闭包**



**3、0全局变量**

用let声明



### 垃圾回收机制

为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。



**JS垃圾回收方式**

标记清除、引用计数



#### 标记清除

**工作原理**：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。



**工作流程：**

1.    垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。

2.    去掉环境中的变量以及被环境中的变量引用的变量的标记。

3.    再被加上标记的会被视为准备删除的变量。

4.    垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。



#### 引用计数

**工作原理**：跟踪记录每个值被引用的次数。



**工作流程**：

1.    声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。

2.    同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.

3.    当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.

4.    当引用次数变成0时，说明没办法访问这个值了。

5.    当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。



但是循环引用的时候就会释放不掉内存。循环引用就是对象A中包含另一个指向对象B的指针，B中也包含一个指向A的引用。



因为IE中的BOM、DOM的实现使用了COM，而COM对象使用的垃圾收集机制是引用计数策略。所以会存在循环引用的问题。



解决：手工断开js对象和DOM之间的链接。赋值为null。IE9把DOM和BOM转换成真正的JS对象了，所以避免了这个问题。



### 什么情况会引起内存泄漏？

虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。



**1.    意外的全局变量引起的内存泄漏。**

原因：全局变量，不会被回收。

解决：使用严格模式避免。



**2.    闭包引起的内存泄漏**

原因：闭包可以维持函数内局部变量，使其得不到释放。

解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。



**3.    没有清理的DOM元素引用**

原因：虽然别的地方删除了，但是对象中还存在对dom的引用

解决：手动删除。



**4.    被遗忘的定时器或者回调**

原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。

解决：手动删除定时器和dom。



**5.    子元素存在引用引起的内存泄漏**

原因：div中的ul li  得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。

解决：手动删除清空。



### 什么放在内存中？什么不放在内存中？

基本类型是：Undefined/Null/Boolean/Number/String

基本类型的值存在内存中，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。



引用类型：object

引用类型的值是对象，保存在堆内存中。



1.    包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。

2.    js不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。



### 栈和堆的区别

　　**一、堆栈空间分配区别：**

　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；

　　2、堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。



　　**二、堆栈缓存方式区别：**

　　1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；

　　2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

　　三、堆栈数据结构区别：

　　堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

　　栈（数据结构）：一种先进后出的数据结构。