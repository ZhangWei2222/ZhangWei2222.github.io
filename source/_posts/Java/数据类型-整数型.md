---
title:  Java-整数型
date: 2020-02-07 18:01:37
categories:
- Java
comments: false
---



Java 语言中的”整数型字面值“被默认当作 int 类型来处理；要让这个”整数型字面值“被当作 long 类型来处理的话，需要在后面添加 l/L，建议使用大写的 L

<!-- more -->

## 类型转换

1. 字面值为 int类型，赋值类型也为 int类型 

```java
// 123 是 int类型，i 也是 int类型，不存在类型转换
int i = 123;
System.out.println(i);

// 456 是 int类型 占用4个字节，x 是 long类型 占用8个字节，存在类型转换
// 但 小容量可以自动转换成大容量，称为自动类型转换机制
long x = 456;
System.out.println(x);
```



2. 字面值为 int类型，赋值类型为 long类型 

```java
long y = 2147483647;
System.out.println(w);

// 编译出错：2147483648 超出 int类型 范围
long z = 2147483648;
System.out.println(z);

// 解决错误：在字面值后面加 L，一开始便当作 long类型 处理
long w = 2147483648L;
System.out.println(w);
```



3. 字面值为 long类型，赋值类型为 int类型

```java
long xx = 100L;
// 编译报错：大容量不能直接赋值给小容量
// int yy = xx;

// 大容量赋值给小容量，需要进行强制类型转换
// 强制类型转换 需要添加“强制类型转换符”
// 即使编译通过了，运行阶段可能损失精度
// 所以 强制类型转换，需要谨慎使用，因为损失精度之后可能损失很严重
int yy = (int) xx;
System.out.println(yy);
```

4. 字面值为 int类型，赋值类型为 byte、short、char类型

```java
// 当一个整数字面值没有超过 byte、short、char 的取值范围，这个字面值可以直接赋值给 byte、short、char类型的变量
// 这种机制 SUN 允许了，目的是为了方便程序员的编程

byte m = 120;
// byte m = (byte)120;
System.out.println(m);
```



## 精度损失

计算机在任何情况下底层表示和存储数据的时候采用了补码形式

- 正数的补码：和原码相同
- 负数的补码：负数的绝对值对应的二进制码所有二进制位取反，再加1

补码：1000000

原码计算过程：

1. 10000000 - 1 --> 01111111
2. 10000000 --> 128
3. -128

所以，如果 `byte b1 = 128`，是一定会损失精度的。原始数据 `00000000 00000000 00000000 10000000`，强转之后`100000000`，这是一个补码，按照上面过程，原码就是 -128 





