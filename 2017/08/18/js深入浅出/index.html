<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="js," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="一.数据类型原始类型 number string boolean null undefined  object 对象 Function Array Date  2.隐式转换字符串变数字  num - 0  数字变字符串  num + ‘’  37” – 7 // 30 “37” + 7 // 377 a===b类型不同  返回false  类型相同  NaN ≠ NaN new Object ≠">
<meta name="keywords" content="js">
<meta property="og:type" content="article">
<meta property="og:title" content="js深入浅出">
<meta property="og:url" content="http://super-wei.xyz/2017/08/18/js深入浅出/index.html">
<meta property="og:site_name" content="ZhangWei2222">
<meta property="og:description" content="一.数据类型原始类型 number string boolean null undefined  object 对象 Function Array Date  2.隐式转换字符串变数字  num - 0  数字变字符串  num + ‘’  37” – 7 // 30 “37” + 7 // 377 a===b类型不同  返回false  类型相同  NaN ≠ NaN new Object ≠">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oncweb6po.bkt.clouddn.com/181635468939277.png">
<meta property="og:image" content="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712130113.png">
<meta property="og:image" content="http://oncweb6po.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712195942.png">
<meta property="og:image" content="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712215823.png">
<meta property="og:image" content="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712215946.png">
<meta property="og:image" content="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712220152.png">
<meta property="og:image" content="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712220251.png">
<meta property="og:updated_time" content="2017-08-24T09:36:20.072Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js深入浅出">
<meta name="twitter:description" content="一.数据类型原始类型 number string boolean null undefined  object 对象 Function Array Date  2.隐式转换字符串变数字  num - 0  数字变字符串  num + ‘’  37” – 7 // 30 “37” + 7 // 377 a===b类型不同  返回false  类型相同  NaN ≠ NaN new Object ≠">
<meta name="twitter:image" content="http://oncweb6po.bkt.clouddn.com/181635468939277.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://super-wei.xyz/2017/08/18/js深入浅出/"/>





  <title>js深入浅出 | ZhangWei2222</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZhangWei2222</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://super-wei.xyz/2017/08/18/js深入浅出/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZhangWei2222">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/person.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangWei2222">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js深入浅出</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-18T12:25:00+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一.数据类型"></a>一.数据类型</h1><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><blockquote>
<p>number</p>
<p>string</p>
<p>boolean</p>
<p>null</p>
<p>undefined</p>
</blockquote>
<h3 id="object-对象"><a href="#object-对象" class="headerlink" title="object 对象"></a>object 对象</h3><blockquote>
<p>Function</p>
<p>Array</p>
<p>Date</p>
</blockquote>
<h2 id="2-隐式转换"><a href="#2-隐式转换" class="headerlink" title="2.隐式转换"></a>2.隐式转换</h2><p>字符串变数字</p>
<blockquote>
<p>num - 0</p>
</blockquote>
<p>数字变字符串</p>
<blockquote>
<p>num + ‘’</p>
</blockquote>
<pre><code>37” – 7 // 30
“37” + 7 // 377
</code></pre><h3 id="a-b"><a href="#a-b" class="headerlink" title="a===b"></a>a===b</h3><p>类型不同</p>
<blockquote>
<p>返回false</p>
</blockquote>
<p>类型相同</p>
<blockquote>
<p>NaN ≠ NaN</p>
<p>new Object ≠ new Object</p>
<p>null === null</p>
<p>undefined === undefined</p>
</blockquote>
<h3 id="a-b-1"><a href="#a-b-1" class="headerlink" title="a == b"></a>a == b</h3><p>类型相同</p>
<blockquote>
<p>同===</p>
</blockquote>
<p>类型不同，尝试类型转换和比较:</p>
<blockquote>
<p>null == undefined 相等</p>
<p>number == string 转number<br>1 == “1.0” // true</p>
<p>boolean == ?  转number<br>1 == true  // true</p>
<p>object == number | string<br>尝试对象转为基本类型<br>new String(‘hi’) == ‘hi’ // true</p>
<p>其它：false</p>
</blockquote>
<h2 id="3-包装对象"><a href="#3-包装对象" class="headerlink" title="3.包装对象"></a>3.包装对象</h2><pre><code>var a = “string”;
alert(a.length);
a.t = 3;
alert(a.t);
</code></pre><p>当对一个字符串（或数组或数字或布尔）（基本类型）进行对象访问的时候，会创建一个对象，当访问完毕，对象立刻销毁，所以a.t设置完后，不存在</p>
<h2 id="4-类型检测"><a href="#4-类型检测" class="headerlink" title="4.类型检测"></a>4.类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><pre><code>typeof 100 === “number”
typeof true === “boolean”
typeof function () {} === “function”

typeof(undefined) ) === “undefined”
typeof(new Object() ) === “object”
typeof( [1， 2] ) === “object”
typeof(NaN ) === “number”
**typeof(null) === “object”**
</code></pre><h3 id="obj-instanceof-Object"><a href="#obj-instanceof-Object" class="headerlink" title="obj instanceof Object"></a>obj instanceof Object</h3><pre><code>[1, 2] instanceof Array === true
new Object() instanceof Array === false
</code></pre><p>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>
<p>Instanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/181635468939277.png" alt=""></p>
<p><strong>Caution！不同window或iframe间的对象类型检测不能使用instanceof！</strong></p>
<h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h3><pre><code>Object.prototype.toString.apply([]); === “[object Array]”;
Object.prototype.toString.apply(function(){}); === “[object Function]”;
Object.prototype.toString.apply(null); === “[object Null]”
Object.prototype.toString.apply(undefined); === “[object Undefined]”

IE6/7/8 Object.prototype.toString.apply(null) 返回”[object Object]”
</code></pre><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>constructor会指向构造这个对象的构造器或构造函数，constructor可以改写，使用时要小心</p>
<h3 id="duck-type"><a href="#duck-type" class="headerlink" title="duck type"></a>duck type</h3><p>通过一些特征来判断</p>
<h2 id="类型检测小结"><a href="#类型检测小结" class="headerlink" title="类型检测小结"></a>类型检测小结</h2><blockquote>
<p>typeof</p>
<p>适合基本类型及function检测，遇到null失效。</p>
<p>[[Class]]</p>
<p>通过{}.toString拿到，适合内置对象和基元类型，遇到null和undefined失效(IE678等返回[object Object])。</p>
<p>instanceof</p>
<p>适合自定义对象，也可以用来检测原生对象，在不同iframe和window间检测时失效。</p>
</blockquote>
<h1 id="二-表达式和运算符"><a href="#二-表达式和运算符" class="headerlink" title="二.表达式和运算符"></a>二.表达式和运算符</h1><p>表达式是一种JS短语，可使JS解释器用来产生一个值。</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="1-原始表达式"><a href="#1-原始表达式" class="headerlink" title="1.原始表达式"></a>1.原始表达式</h3><blockquote>
<p>1.常量、直接量</p>
<p>3.14, “test”</p>
<p>2.关键字</p>
<p>null, this, true</p>
<p>3.变量</p>
<p>i, k, j</p>
<p>复合表达式 10*20</p>
</blockquote>
<h3 id="2-数组、对象的初始化表达式"><a href="#2-数组、对象的初始化表达式" class="headerlink" title="2.数组、对象的初始化表达式"></a>2.数组、对象的初始化表达式</h3><p>[1, 2] </p>
<blockquote>
<p>new Array(1, 2);</p>
</blockquote>
<p>[1, , , 4]</p>
<blockquote>
<p>[1, undefined, undefined , 4]</p>
</blockquote>
<p>{ x : 1, y : 2} </p>
<blockquote>
<p>var o = new Object();<br>o.x = 1; o.y = 2;</p>
</blockquote>
<h3 id="3-函数表达式"><a href="#3-函数表达式" class="headerlink" title="3.函数表达式"></a>3.函数表达式</h3><p>var fe = function(){};</p>
<h3 id="4-属性访问表达式"><a href="#4-属性访问表达式" class="headerlink" title="4.属性访问表达式"></a>4.属性访问表达式</h3><p>var o = {x : 1};</p>
<blockquote>
<p>o.x</p>
<p>o[‘x’]</p>
</blockquote>
<h3 id="5-调用表达式"><a href="#5-调用表达式" class="headerlink" title="5.调用表达式"></a>5.调用表达式</h3><p>func();</p>
<h3 id="6-对象创建表达式"><a href="#6-对象创建表达式" class="headerlink" title="6.对象创建表达式"></a>6.对象创建表达式</h3><p>new Func(1, 2);<br>new Object;</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>一元 +num</p>
<p>二元 a + b</p>
<p>三元 c ? a : b</p>
<p>赋值 x += 1</p>
<p>比较 a == b</p>
<p>算术 a - b</p>
<p>位 a | b</p>
<p>逻辑 exp1 &amp;&amp; exp2</p>
<p>字符串 “a” + “b”</p>
<p><strong>特殊</strong> </p>
<h3 id="1-delete-obj-x"><a href="#1-delete-obj-x" class="headerlink" title="1.delete obj.x"></a>1.delete obj.x</h3><pre><code>var obj = {x : 1};
obj.x;  // 1
delete obj.x;
obj.x;  // undefined

var obj = {};
Object.defineProperty(obj, &apos;x&apos;, {
    configurable : false, 
    value : 1
});
delete obj.x; // false
obj.x;// 1
</code></pre><blockquote>
<p><strong>神奇的Object.defineProperty</strong></p>
</blockquote>
<pre><code>var a={}
Object.defineProperty(a,&quot;b&quot;,{value:123})
console.log(a,b);//123
</code></pre><p> 传入参数</p>
<blockquote>
<p>第一个参数:目标对象</p>
<p>第二个参数:需要定义的属性或方法的名字。</p>
<p>第三个参数:目标属性所拥有的特性。(默认为false)（descriptor）</p>
</blockquote>
<p>前两个参数不多说了，一看代码就懂，主要看第三个参数descriptor，看看有哪些取值</p>
<blockquote>
<p>value:属性的值(不用多说了)</p>
<pre><code>var a= {}
Object.defineProperty(a,&quot;b&quot;,{
  value:123
})
console.log(a.b);//123
</code></pre><p>writable:如果为false，属性的值就不能被重写,只能为只读了<br>    var a = {}; </p>
<pre><code>Object.defineProperty(o, &quot;b&quot;, { 
value : 123,
writable : false });

console.log(a.b); // 打印 37
a.b = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）
console.log(o.a); // 打印 37， 赋值不起作用。
</code></pre><p>configurable:总开关，一旦为false，就不能再设置他的（value，writable，configurable）</p>
<p>enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。</p>
<pre><code>var a= {}
Object.defineProperty(a,&quot;b&quot;,{
  value:3445,
  enumerable:true
})
console.log(Object.keys(a));// 打印[&quot;b&quot;]
改为false

var a= {}
Object.defineProperty(a,&quot;b&quot;,{
  value:3445,
  enumerable:false //注意咯这里改了
})
console.log(Object.keys(a));// 打印[]
</code></pre><p>get:一会细说</p>
<p>set:一会细说</p>
</blockquote>
<h3 id="2-in"><a href="#2-in" class="headerlink" title="2.in"></a>2.in</h3><pre><code>window.x = 1;
‘x’ in window; // true
</code></pre><h3 id="3-instanceof-typeof"><a href="#3-instanceof-typeof" class="headerlink" title="3.instanceof, typeof"></a>3.instanceof, typeof</h3><pre><code>{} instanceof Object// true
typeof 100 === ‘number’ // true
</code></pre><h3 id="4-new"><a href="#4-new" class="headerlink" title="4.new"></a>4.new</h3><pre><code>function Foo(){}
Foo.prototype.x = 1;
var obj = new Foo();
obj.x;  // 1
obj.hasOwnProperty(&apos;x&apos;); // false
obj.__proto__.hasOwnProperty(&apos;x&apos;); // true
</code></pre><blockquote>
<p>hasOwnProperty 本身的属性</p>
<p><strong>proto</strong>即原型，obj这个对象的原型指向Foo这个函数的prototype</p>
</blockquote>
<h3 id="5-this"><a href="#5-this" class="headerlink" title="5.this"></a>5.this</h3><pre><code>this;  // window (浏览器)
var obj = {
func : function(){return this;}
};
obj.func(); // obj
</code></pre><h3 id="6-void"><a href="#6-void" class="headerlink" title="6.void"></a>6.void</h3><pre><code>void 0  // undefined
void(0) // undefined
</code></pre><h1 id="三-语句"><a href="#三-语句" class="headerlink" title="三.语句"></a>三.语句</h1><h3 id="1-block"><a href="#1-block" class="headerlink" title="1.block"></a>1.block</h3><p>请注意：没有块级作用域</p>
<pre><code>var i = 0
for (; i &lt; 10; i++) {
var str = &quot;hi&quot;;
console.log(str);
}
</code></pre><p>为了防止混淆，把for循环中的定义变量var，拿出去写</p>
<h3 id="2-var"><a href="#2-var" class="headerlink" title="2.var"></a>2.var</h3><pre><code>var a = b = 1;
</code></pre><p>b隐式创建了全局变量（所以一条语句定义多个变量，一定要分开）</p>
<h3 id="3-try-catch"><a href="#3-try-catch" class="headerlink" title="3.try catch"></a>3.try catch</h3><pre><code>try {
   throw &quot;test&quot;;
} catch (ex) {
console.log(ex); // test
} finally {
console.log(&apos;finally&apos;);
}
</code></pre><p>先执行try catch中的代码，如果抛出了异常，会由catch从句捕获并且执行，如果没有发生异常，catch部分的代码被忽略掉，但不管是否出现异常，都会执行finally从句；try后面必须接一个catch或一个finally</p>
<pre><code>try {
try {
throw new Error(&quot;oops&quot;);
}
finally {
console.log(&quot;finally&quot;);
}
}
catch (ex) {
console.error(&quot;outer&quot;, ex.message);
}

&quot;finally&quot;
&quot;outer&quot; &quot;oops&quot;
</code></pre><hr>
<pre><code>try {
  try {
  throw new Error(&quot;oops&quot;);
  }
  catch (ex) {
console.error(&quot;inner&quot;, ex.message);
  }
  finally {
console.log(&quot;finally&quot;);
  }
}
catch (ex) {
  console.error(&quot;outer&quot;, ex.message);
}

&quot;inner&quot; &quot;oops&quot;
&quot;finally&quot;
</code></pre><hr>
<pre><code>try {
  try {
throw new Error(&quot;oops&quot;);
  }
  catch (ex) {
console.error(&quot;inner&quot;, ex.message);
throw ex;
  }
  finally {
console.log(&quot;finally&quot;);
  }
}
catch (ex) {
  console.error(&quot;outer&quot;, ex.message);
}

&quot;inner&quot; &quot;oops&quot;
&quot;finally&quot;
&quot;outer&quot; &quot;oops&quot;
</code></pre><h3 id="4-function"><a href="#4-function" class="headerlink" title="4.function"></a>4.function</h3><pre><code>fd(); // true
function fd() {
// do sth.
return true;
}
</code></pre><p>函数声明，会被前置处理掉</p>
<pre><code>fe(); // TypeError
var fe = function() {
// do sth.
};
</code></pre><p>函数表达式，不会提前处理</p>
<h3 id="5-for…in"><a href="#5-for…in" class="headerlink" title="5.for…in"></a>5.for…in</h3><pre><code>var p;
var obj = {x : 1, y: 2}

for (p in obj) {
}
</code></pre><ol>
<li>顺序不确定</li>
<li>enumerable为false时不会出现</li>
<li>for in对象属性时受原型链影响</li>
</ol>
<h3 id="6-switch"><a href="#6-switch" class="headerlink" title="6.switch"></a>6.switch</h3><h3 id="7-循环"><a href="#7-循环" class="headerlink" title="7.循环"></a>7.循环</h3><h3 id="8-with"><a href="#8-with" class="headerlink" title="8.with"></a>8.with</h3><pre><code>with ({x : 1}) {
console.log(x);
}

with (document.forms[0]) {
console.log(name.value);
}

var form = document.forms[0];
console.log(form.name.value);
</code></pre><p>通俗的理解就是，with代表了那个对象。可是这样写有几个缺点：（因此，应该采用变量取对象的方法）</p>
<p>让JS引擎优化更难</p>
<p>可读性差</p>
<p>可被变量定义代替</p>
<p>严格模式下被禁用</p>
<p><strong>修改当前的作用域</strong></p>
<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>严格模式是一种特殊的执行模式，<br>它修复了部分语言上的不足，提供更强的错误检查，并增强安全性。</p>
<pre><code>function func() {
&apos;use strict&apos;;
}

 &apos;use strict&apos;;
function func() {

}
</code></pre><h3 id="1-不允许用with"><a href="#1-不允许用with" class="headerlink" title="1.不允许用with"></a>1.不允许用with</h3><pre><code>!function() {
    &apos;use strict&apos;;
     with({x : 1}) {
console.log(x);
  }
}(); //SyntaxError
</code></pre><h3 id="2-不允许未声明的变量被赋值"><a href="#2-不允许未声明的变量被赋值" class="headerlink" title="2.不允许未声明的变量被赋值"></a>2.不允许未声明的变量被赋值</h3><pre><code>!function() {
    &apos;use strict&apos;;
     x = 1;
  console.log(window.x);
}(); //ReferenceError
</code></pre><h3 id="3-arguments变为参数的静态副本"><a href="#3-arguments变为参数的静态副本" class="headerlink" title="3.arguments变为参数的静态副本"></a>3.arguments变为参数的静态副本</h3><pre><code>!function(a) {
    arguments[0] = 100;
    console.log(a);
}(1);  //100
</code></pre><blockquote>
<p>在一般模式下，如果定义了一个函数，调用它并且传递参数，那么它对应的形参和arguments[0]有一个相互的绑定关系，就是说如果我们修改了arguments[0]，那么这个函数对应的形参b就会被修改了，所以输出100。</p>
<p>如果我们现在不给函数传值，就是像下面这个样子，</p>
</blockquote>
<pre><code>! function (a){
arguments[0]=100;
console.log(a);//undefined
  }();
</code></pre><blockquote>
<p>那么无论我们如何修改arguments[0]的值，输出的都是undefined，因为宝宝你没有传递参数进去啊，~ o(￣▽￣)ブ</p>
</blockquote>
<pre><code>!function(a) {
    &apos;use strict&apos;;
    arguments[0] = 100;
    console.log(a);
}(1);  //1
</code></pre><blockquote>
<p>在严格模式下，arguments[0]变为参数的静态副本，就是说无论函数的参数有没有传递，都不会和arguments相互影响</p>
</blockquote>
<pre><code>!function(a) {
&apos;use strict&apos;;
arguments[0].x = 100;
console.log(a.x);
}({x:1});  //100
</code></pre><blockquote>
<p>但是如果传入的是一个对象的话，将会按照共享传递，使用arguments修改对象的属性，那么还是会相互影响的。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>arguments用法</strong></p>
<p>每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。</p>
</blockquote>
<pre><code>var sum = function (n) {
if (1 == n) {
return 1;
} else {
return n + arguments.callee(n - 1);
}
}
alert(sum(6));
</code></pre><hr>
<h3 id="4-delete参数、函数名报错"><a href="#4-delete参数、函数名报错" class="headerlink" title="4.delete参数、函数名报错"></a>4.delete参数、函数名报错</h3><pre><code>!function(a) {
    &apos;use strict&apos;;
    delete a;
}(1); //SyntaxError
</code></pre><h3 id="5-delete不可配置的属性报错"><a href="#5-delete不可配置的属性报错" class="headerlink" title="5.delete不可配置的属性报错"></a>5.delete不可配置的属性报错</h3><pre><code>!function(a) {
    &apos;use strict&apos;;
    var obj = {};
    Object.defineProperty(obj, 
    &apos;a&apos;, {configurable : false});
    delete obj.a;
}(1); //TypeError
</code></pre><h3 id="6-对象字面量重复属性名报错"><a href="#6-对象字面量重复属性名报错" class="headerlink" title="6.对象字面量重复属性名报错"></a>6.对象字面量重复属性名报错</h3><pre><code>!function() {
    &apos;use strict&apos;;
    var obj = {x : 1, x : 2};
}();  //SyntaxError
</code></pre><h3 id="7-禁止八进制字面量"><a href="#7-禁止八进制字面量" class="headerlink" title="7.禁止八进制字面量"></a>7.禁止八进制字面量</h3><pre><code>!function() {
    &apos;use strict&apos;;
    console.log(0123);
}(); //SyntaxError
</code></pre><h3 id="8-eval-arguments变为关键字，不能作为变量、函数名"><a href="#8-eval-arguments变为关键字，不能作为变量、函数名" class="headerlink" title="8.eval, arguments变为关键字，不能作为变量、函数名"></a>8.eval, arguments变为关键字，不能作为变量、函数名</h3><pre><code>!function() {
    &apos;use strict&apos;;
    function eval(){}
}();  //SyntaxError
</code></pre><h3 id="9-eval独立作用域"><a href="#9-eval独立作用域" class="headerlink" title="9.eval独立作用域"></a>9.eval独立作用域</h3><pre><code>!function() {
    &apos;use strict&apos;;
    eval(&apos;var evalVal = 2;&apos;);
    console.log(typeof evalVal);
}();  //undefined
</code></pre><p><strong>小结</strong></p>
<blockquote>
<p>1.不允许用with</p>
<p>2.所有变量必须声明, 赋值给为声明的变量报错，而不是隐式创建全局变量。</p>
<p>3.eval中的代码不能创建eval所在作用域下的变量、函数。而是为eval单独创建一个作用域，并在eval返回时丢弃。</p>
<p>4.函数中得特殊对象arguments是静态副本，而不像非严格模式那样，修改arguments或修改参数变量会相互影响。</p>
<p>5.删除configurable=false的属性时报错，而不是忽略</p>
<p>6.禁止八进制字面量，如010 (八进制的8)</p>
<p>7.eval, arguments变为关键字，不可作为变量名、函数名等</p>
<p>8.一般函数调用时(不是对象的方法调用，也不使用apply/call/bind等修改this)this指向null，而不是全局对象。</p>
<p>9.若使用apply/call，当传入null或undefined时，this将指向null或undefined，而不是全局对象。</p>
<p>10.试图修改不可写属性(writable=false)，在不可扩展的对象上添加属性时报TypeError，而不是忽略。</p>
<p>11.arguments.caller, arguments.callee被禁用</p>
</blockquote>
<h1 id="四-对象"><a href="#四-对象" class="headerlink" title="四.对象"></a>四.对象</h1><p>对象中包含一系列属性，这些属性是无序的。<br>每个属性都有一个字符串key和对应的value。</p>
<pre><code>var obj = {x : 1, y : 2};
obj.x; // 1
obj.y; // 2
</code></pre><p>##（1)对象创建-字面量<br>    var obj1 = {x : 1, y : 2};<br>    var obj2 = {<br>    x : 1,<br>    y : 2,<br>    o : {<br>        z : 3,<br>        n : 4<br>          }<br>    };</p>
<h3 id="1-创建对象-new-原型链"><a href="#1-创建对象-new-原型链" class="headerlink" title="1.创建对象-new/原型链"></a>1.创建对象-new/原型链</h3><pre><code>function foo(){}
foo.prototype.z = 3;

var obj =new foo();
obj.y = 2;
obj.x = 1;

obj.x; // 1
obj.y; // 2
obj.z; // 3
typeof obj.toString; // ‘function&apos;
&apos;z&apos; in obj; // true
obj.hasOwnProperty(&apos;z&apos;); // false
</code></pre><blockquote>
<p>obj.z不在obj中，会向上查找，即沿着原型链</p>
</blockquote>
<pre><code>obj.z = 5;

obj.hasOwnProperty(&apos;z&apos;); // true
foo.prototype.z; // still 3
obj.z; // 5

obj.z = undefined;
obj.z; // undefined

delete obj.z; // true
obj.z; // 3

delete obj.z; // true
**obj.z; // still 3!!!**
</code></pre><blockquote>
<p>不能delete掉原型链的属性z</p>
</blockquote>
<h3 id="2-对象创建-Object-create"><a href="#2-对象创建-Object-create" class="headerlink" title="2.对象创建-Object.create"></a>2.对象创建-Object.create</h3><pre><code>var obj = Object.create({x : 1});
obj.x // 1
typeof obj.toString // &quot;function&quot;
obj.hasOwnProperty(&apos;x&apos;);// false
</code></pre><blockquote>
<p>创建一个新对象，并将这个对象的原型指向Object.propotype，create后面的属性属于object.propotype中。</p>
</blockquote>
<pre><code>var obj = Object.create(null);
obj.toString // undefined
</code></pre><h2 id="2-属性操作"><a href="#2-属性操作" class="headerlink" title="(2)属性操作"></a>(2)属性操作</h2><h3 id="1-属性读写"><a href="#1-属性读写" class="headerlink" title="1.属性读写"></a>1.属性读写</h3><pre><code>var obj = {x : 1, y : 2};
obj.x; // 1
obj[&quot;y&quot;]; // 2

obj[&quot;x&quot;] = 3;
obj.y = 4;

var obj = {x1 : 1, x2 : 2};
var i = 1, n = 2;

for (; i &lt;= n; i++) {
console.log(obj[&apos;x&apos; + i]);
}
// 输出: 1, 2

var p;
for (p in obj) {
console.log(obj[p]);
}
</code></pre><h3 id="2-属性读写-异常"><a href="#2-属性读写-异常" class="headerlink" title="2.属性读写-异常"></a>2.属性读写-异常</h3><pre><code>var obj = {x : 1};
obj.y; // undefined
var yz = obj.y.z; // TypeError: Cannot read property &apos;z&apos; of undefined
obj.y.z = 2; // TypeError: Cannot set property &apos;z&apos; of undefined

var yz;
if (obj.y) {
    yz = obj.y.z;
}

var yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z;
</code></pre><h3 id="3-属性删除"><a href="#3-属性删除" class="headerlink" title="3.属性删除"></a>3.属性删除</h3><pre><code>var person = {age : 28, title : &apos;fe&apos;};
delete person.age; // true
delete person[&apos;title&apos;]; // true
person.age; // undefined
delete person.age; // true

delete Object.prototype; // false,

var descriptor = Object.getOwnPropertyDescriptor(Object, &apos;prototype&apos;);
descriptor.configurable; // false
</code></pre><blockquote>
<p>不能delete Object.prototype</p>
</blockquote>
<pre><code>var globalVal = 1;
delete globalVal; // false

(function() {
    var localVal = 1;
    return delete localVal;
}()); // false
</code></pre><blockquote>
<p>不能delete 变量</p>
</blockquote>
<pre><code>function fd() {}
delete fd; // false

(function() {
    function fd() {};
    return delete fd;
}()); // false
</code></pre><blockquote>
<p>不能delete 函数</p>
</blockquote>
<pre><code>ohNo = 1;
window.ohNo; // 1
delete ohNo; // true
</code></pre><blockquote>
<p>可以delete 全局变量</p>
</blockquote>
<h3 id="4-属性检测"><a href="#4-属性检测" class="headerlink" title="4.属性检测"></a>4.属性检测</h3><pre><code>var cat = new Object;
cat.legs = 4;
cat.name = &quot;Kitty&quot;;

&apos;legs&apos; in cat; // true
&apos;abc&apos; in cat; // false
&quot;toString&quot; in cat; // true, inherited property!!!


cat.hasOwnProperty(&apos;legs&apos;); // true
cat.hasOwnProperty(&apos;toString&apos;); // false

cat.propertyIsEnumerable(&apos;legs&apos;); // true
cat.propertyIsEnumerable(&apos;toString&apos;); // false
</code></pre><blockquote>
<p>如果判断的属性存在于Object对象的原型内，不管它是否可枚举都会返回false。</p>
</blockquote>
<pre><code>Object.defineProperty(cat, &apos;price&apos;, {enumerable : false, value : 1000});
cat.propertyIsEnumerable(&apos;price&apos;); // false
cat.hasOwnProperty(&apos;price&apos;); // true


if (cat &amp;&amp; cat.legs) {
    cat.legs *= 2;
}


if (cat.legs !== undefined) {
    // only if cat.legs is not undefined
}
</code></pre><h3 id="5-getter-setter方法-另一种读写属性的方式"><a href="#5-getter-setter方法-另一种读写属性的方式" class="headerlink" title="5.getter setter方法(另一种读写属性的方式)"></a>5.getter setter方法(另一种读写属性的方式)</h3><p>getter 是一种获得属性值的方法，setter是一种设置属性值的方法。</p>
<pre><code>var man = {
    name : &apos;Bosn&apos;,
    weibo : &apos;@Bosn&apos;,
    get age() {
        return new Date().getFullYear() - 1988;
    },
    set age(val) {
        console.log(&apos;Age can\&apos;t be set to &apos; + val);
    }
}
console.log(man.age); // 27
man.age = 100; // Age can&apos;t be set to 100
console.log(man.age); // still 27
</code></pre><hr>
<pre><code>var man = {
    weibo : &apos;@Bosn&apos;,
    $age : null,
    get age() {
        if (this.$age == undefined) {
            return new Date().getFullYear() - 1988;
        } else {
            return this.$age;
        }
    },
    set age(val) {
        val = +val;
        if (!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) {
            this.$age = +val;
        } else {
            throw new Error(&apos;Incorrect val = &apos; + val);
        }
    }
}
console.log(man.age); // 27
man.age = 100;
console.log(man.age); // 100;
man.age = &apos;abc&apos;; // error:Incorrect val = NaN
</code></pre><p>get/set与原型链</p>
<pre><code>function foo() {}

Object.defineProperty(foo.prototype, &apos;z&apos;, 
    {get : function(){return 1;}});

var obj = new foo();

obj.z; // 1
obj.z = 10;
obj.z; // still 1

Object.defineProperty(obj, &apos;z&apos;, 
{value : 100, configurable: true});
obj.z; // 100;
delete obj.z;
obj.z; // back to 1
</code></pre><blockquote>
<p>不能修改get的属性</p>
</blockquote>
<h2 id="3-属性标签"><a href="#3-属性标签" class="headerlink" title="(3)属性标签"></a>(3)属性标签</h2><pre><code>Object.getOwnPropertyDescriptor({pro : true}, &apos;pro&apos;);
// Object {value: true, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({pro : true}, &apos;a&apos;); // undefined
</code></pre><blockquote>
<p>Object.getOwnPropertyDescriptor 函数 </p>
<p>语法：Object.getOwnPropertyDescriptor(object, propertyname)</p>
<p>参数：<br>object   必需。包含属性的对象。<br>propertyname 必需。属性的名称。</p>
</blockquote>
<pre><code>var person = {};
Object.defineProperty(person, &apos;name&apos;, {
    configurable : false,
    writable : false,
    enumerable : true,
    value : &quot;Bosn Ma&quot;
});

person.name; // Bosn Ma
person.name = 1;
person.name; // still Bosn Ma
delete person.name; // false
</code></pre><blockquote>
<p>defineProperty中的属性默认false</p>
</blockquote>
<pre><code>Object.defineProperty(person, &apos;type&apos;, {
    configurable : true,
    writable : true,
    enumerable : false,
    value : &quot;Object&quot;
});

Object.keys(person); // [&quot;name&quot;]
</code></pre><hr>
<pre><code>Object.defineProperties(person, {
    title : {value : &apos;fe&apos;, enumerable : true},
    corp : {value : &apos;BABA&apos;, enumerable : true},
    salary : {value : 50000, enumerable : true, writable : true}
});

Object.getOwnPropertyDescriptor(person, &apos;salary&apos;);
// Object {value: 50000, writable: true, enumerable: true, configurable: false}
Object.getOwnPropertyDescriptor(person, &apos;corp&apos;);
// Object {value: &quot;BABA&quot;, writable: false, enumerable: true, configurable: false}
</code></pre><hr>
<pre><code>Object.defineProperties(person, {
    title : {value : &apos;fe&apos;, enumerable : true},
    corp : {value : &apos;BABA&apos;, enumerable : true},
    salary : {value : 50000, enumerable : true, writable : true},
    luck : {
    get : function() {
    return Math.random() &gt; 0.5 ? &apos;good&apos; : &apos;bad&apos;;
    }
    },
    promote : {
    set : function (level) {
    this.salary *= 1 + level * 0.1;
    }
   }
});

Object.getOwnPropertyDescriptor(person, &apos;salary&apos;);
// Object {value: 50000, writable: true, enumerable: true, configurable: false}
Object.getOwnPropertyDescriptor(person, &apos;corp&apos;);
// Object {value: &quot;BABA&quot;, writable: false, enumerable: true, configurable: false}
person.salary; // 50000
person.promote = 2;
person.salary; // 60000
</code></pre><blockquote>
<p>getOwnPropertyDescriptor属性值默认false</p>
</blockquote>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712130113.png" alt=""></p>
<blockquote>
<p>1.configurable为false时，不能delete,不能修改getter/setter方法，不能修改属性标签</p>
<p>2.writable为false时，不能通过属性赋值，修改属性的值</p>
<p>3.configurable和writeable都是false时，才不能修改属性的值</p>
</blockquote>
<p>##（4）.对象标签</p>
<h3 id="1-原型标签-proto"><a href="#1-原型标签-proto" class="headerlink" title="1.原型标签 _proto_"></a>1.原型标签 _proto_</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt=""></p>
<h3 id="2-class标签"><a href="#2-class标签" class="headerlink" title="2.class标签"></a>2.class标签</h3><pre><code>var toString = Object.prototype.toString;
function getType(o){return toString.call(o).slice(8,-1);};

toString.call(null); // &quot;[object Null]&quot;
getType(null); // &quot;Null&quot;
getType(undefined); // &quot;Undefined&quot;
getType(1); // &quot;Number&quot;
getType(new Number(1)); // &quot;Number&quot;
typeof new Number(1); // &quot;object&quot;
getType(true); // &quot;Boolean&quot;
getType(new Boolean(true)); // &quot;Boolean&quot;
</code></pre><blockquote>
<p>slice() 方法</p>
<p><strong>定义和用法</strong><br>slice() 方法可从已有的数组中返回选定的元素。</p>
<p><strong>语法</strong><br>arrayObject.slice(start,end)</p>
<p><strong>start</strong><br>必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p>
<p><strong>end</strong><br>可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
<p><strong>返回值</strong><br>返回一个新的数组，包含从 start 到 end （<strong>不包括该元素</strong>）的 arrayObject 中的元素。</p>
<p><strong>说明</strong><br>请注意，该方法并不会修改数组，而是返回一个子数组。</p>
</blockquote>
<p>3.extensible标签</p>
<h3 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h3><p>如果一个对象可以添加新的属性，则这个对象是可扩展的。让这个对象变的不可扩展，也就是不能再有新的属性</p>
<pre><code>var obj = {x : 1, y : 2};
Object.isExtensible(obj); // true
</code></pre><blockquote>
<p>对象的extensible属性用于表示是否允许在对象中动态添加新的property。ECMAScript 3标准中，所有的对象都是extensible的。</p>
</blockquote>
<pre><code>Object.preventExtensions(obj);
Object.isExtensible(obj); // false
</code></pre><blockquote>
<p>使一个对象变成不是extensible的，可以使用Object.preventExtensions()语句</p>
</blockquote>
<pre><code>obj.z = 1;
obj.z; // undefined, add new property failed
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: true}
</code></pre><h3 id="密封特性"><a href="#密封特性" class="headerlink" title="密封特性"></a>密封特性</h3><p>密封对象是指那些不可 扩展 的，且所有自身属性都不可配置的（non-configurable）对象。</p>
<p>或则说 密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象</p>
<pre><code>Object.seal(obj);
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: true, enumerable: true, configurable: false}
Object.isSealed(obj); // true
</code></pre><h3 id="冻结特性"><a href="#冻结特性" class="headerlink" title="冻结特性"></a>冻结特性</h3><p>冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。</p>
<pre><code>Object.freeze(obj);
Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);
// Object {value: 1, writable: false, enumerable: true, configurable: false}
Object.isFrozen(obj); // true

// [caution] not affects prototype chain!!!
</code></pre><h2 id="5-序列化"><a href="#5-序列化" class="headerlink" title="(5).序列化"></a>(5).序列化</h2><pre><code>var obj = {x : 1, y : true, z : [1, 2, 3], nullVal : null};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null}&quot;

obj = {val : undefined, a : NaN, b : Infinity, c : new Date()};
JSON.stringify(obj); // &quot;{&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:&quot;2015-01-20T14:15:43.910Z&quot;}&quot;

obj = JSON.parse(&apos;{&quot;x&quot; : 1}&apos;);
obj.x; // 1
</code></pre><hr>
<pre><code>var obj = {
    x : 1,
    y : 2,
    o : {
        o1 : 1,
        o2 : 2,
        toJSON : function () {
            return this.o1 + this.o2;
        }
    }
};
JSON.stringify(obj); // &quot;{&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3}&quot;
</code></pre><blockquote>
<p>stringify()用于从一个对象解析出字符串，如</p>
<pre><code>var
 a = {a:1,b:2}

结果：

JSON.stringify(a)

&quot;{&quot;a&quot;:1,&quot;b&quot;:2}&quot;
</code></pre><p>parse用于从一个字符串中解析出json对象,如</p>
<pre><code>var str = &apos;{&quot;name&quot;:&quot;huangxiaojian&quot;,&quot;age&quot;:&quot;23&quot;}&apos;

结果：

JSON.parse(str)

Object

age: &quot;23&quot;
name: &quot;huangxiaojian&quot;
__proto__: Object
</code></pre><p>注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。</p>
</blockquote>
<p>##（5）.其他对象方法<br>    var obj = {x : 1, y : 2};<br>    obj.toString(); // “[object Object]”<br>    obj.toString = function() {return this.x + this.y};<br>    “Result “ + obj; // “Result 3”, by toString</p>
<pre><code>+obj; // 3, from toString

obj.valueOf = function() {return this.x + this.y + 100;};
+obj; // 103, from valueOf

&quot;Result &quot; + obj; // still &quot;Result 103&quot;
</code></pre><blockquote>
<p><strong>object.toString( )</strong></p>
<p>返回值  toString()函数的返回值为String类型。返回当前对象的字符串形式。</p>
<p>Array<br>将 Array 的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接。</p>
<p>Boolean<br>如果布尔值是true，则返回”true”。否则返回”false”。</p>
<p>Date<br>返回日期的文本表示。</p>
<p>Error<br>返回一个包含相关错误信息的字符串。</p>
<p>Function<br>返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }”</p>
<p>Number<br>    返回数值的字符串表示。还可返回以指定进制表示的字符串</p>
<p>String<br>    返回 String 对象的值。</p>
<p>Object(默认)<br>返回”[object ObjectName]”，其中 ObjectName 是对象类型的名称。</p>
<p><strong>object.valueOf( )</strong></p>
<p>返回值 函数返回指定对象的原始值。</p>
<p>Array<br>数组实例对象。</p>
<p>Boolean<br>布尔值。</p>
<p>Date<br>以毫秒数存储的时间值，从 UTC 1970 年 1 月 1 日午夜开始计算。</p>
<p>Function<br>函数本身。</p>
<p>Number<br>数字值。</p>
<p>Object<br>对象本身。这是默认设置。</p>
<p>String<br>字符串值。</p>
</blockquote>
<pre><code>var bbb = { 
i: 10, 
toString: function() { 
console.log(&apos;toString&apos;); 
return this.i; 
}, 
valueOf: function() { 
console.log(&apos;valueOf&apos;); 
return this.i; 
} 
} 
alert(bbb);// 10 toString 
alert(+bbb); // 10 valueOf 
alert(&apos;&apos;+bbb); // 10 valueOf 
alert(String(bbb)); // 10 toString 
alert(Number(bbb)); // 10 valueOf 
alert(bbb == &apos;10&apos;); // true valueOf 
alert(bbb === &apos;10&apos;); // false 
</code></pre><hr>
<pre><code>var aa = { 
i: 10, 
toString: function() { 
console.log(&apos;toString&apos;); 
return this.i; 
} 
} 
alert(aa);// 10 toString 
alert(+aa); // 10 toString 
alert(&apos;&apos;+aa); // 10 toString 
alert(String(aa)); // 10 toString 
alert(Number(aa)); // 10 toString 
alert(aa == &apos;10&apos;); // true toString 
再看valueOf。 
var bb = { 
i: 10, 
valueOf: function() { 
console.log(&apos;valueOf&apos;); 
return this.i; 
} 
} 
alert(bb);// [object Object] 
alert(+bb); // 10 valueOf 
alert(&apos;&apos;+bb); // 10 valueOf 
alert(String(bb)); // [object Object] 
alert(Number(bb)); // 10 valueOf 
alert(bb == &apos;10&apos;); // true valueOf 
发现有点不同吧？！它没有像上面toString那样统一规整。对于那个[object Object]，我估计是从Object那里继承过来的，我们再去掉它看看。 
Object.prototype.toString = null; 
var cc = { 
i: 10, 
valueOf: function() { 
console.log(&apos;valueOf&apos;); 
return this.i; 
} 
} 
alert(cc);// 10 valueOf 
alert(+cc); // 10 valueOf 
alert(&apos;&apos;+cc); // 10 valueOf 
alert(String(cc)); // 10 valueOf 
alert(Number(cc)); // 10 valueOf 
alert(cc == &apos;10&apos;); // true valueOf 
</code></pre><blockquote>
<p>总结：valueOf偏向于运算，toString偏向于显示。</p>
<p>1、 在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。</p>
<p>2、 在有运算操作符的情况下，valueOf的优先级高于toString。</p>
<p>3.如果只重写了toString，对象转换时会无视valueOf的存在来进行转换。但是，如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法。在不能调用toString的情况下，只能让valueOf上阵了。对于那个奇怪的字符串拼接问题，可能是出于操作符上，翻开ECMA262-5 发现都有一个getValue操作。嗯，那么谜底应该是揭开了。重写会加大它们调用的优化高，而在有操作符的情况下，valueOf的优先级本来就比toString的高。</p>
</blockquote>
<h1 id="五-数组"><a href="#五-数组" class="headerlink" title="五.数组"></a>五.数组</h1><p>数组是值的有序集合。每个值叫做元素，每个元素在数组中都有数字位置编号，也就是索引。JS中的数组是弱类型的，数组中可以含有不同类型的元素。数组元素甚至可以是对象或其它数组。</p>
<pre><code>var arr = [1, true, null, undefined, {x : 1}, [1, 2, 3]];
</code></pre><h3 id="1-创建数组-字面量"><a href="#1-创建数组-字面量" class="headerlink" title="1.创建数组-字面量"></a>1.创建数组-字面量</h3><pre><code>var BAT = [&apos;Alibaba&apos;, &apos;Tencent&apos;, &apos;Baidu&apos;];
var students = [{name : &apos;Bosn&apos;, age : 27}, {name : &apos;Nunnly&apos;, age : 3}];
var arr = [&apos;Nunnly&apos;, &apos;is&apos;, &apos;big&apos;, &apos;keng&apos;, &apos;B&apos;, 123, true, null];
var arrInArr = [[1, 2], [3, 4, 5]];

var commasArr1 = [1, , 2]; // 1, undefined, 2
var commasArr2 = [,,]; // undefined * 2

size from 0 to 4,294,967,295(2^23  -1 ) 
</code></pre><h3 id="2-创建数组-new-Array"><a href="#2-创建数组-new-Array" class="headerlink" title="2.创建数组-new Array"></a>2.创建数组-new Array</h3><pre><code>var arr = new Array(); 
var arrWithLength = new Array(100); // undefined * 100
var arrLikesLiteral = new Array(true, false, null, 1, 2, &quot;hi&quot;);
// 等价于[true, false, null, 1, 2, &quot;hi&quot;];
</code></pre><blockquote>
<p>new可以省略</p>
</blockquote>
<h3 id="3-数组元素读写"><a href="#3-数组元素读写" class="headerlink" title="3.数组元素读写"></a>3.数组元素读写</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr[1]; // 2
arr.length; // 5


arr[5] = 6;
arr.length; // 6


delete arr[0];
arr[0]; // undefined
</code></pre><h3 id="4-数组元素增删（动态的，无需指定大小）"><a href="#4-数组元素增删（动态的，无需指定大小）" class="headerlink" title="4.数组元素增删（动态的，无需指定大小）"></a>4.数组元素增删（动态的，无需指定大小）</h3><pre><code>var arr = [];
arr[0] = 1;
arr[1] = 2;
arr.push(3);
arr; // [1, 2, 3]

arr[arr.length] = 4; // equal to arr.push(4);
arr; // [1, 2, 3, 4]

arr.unshift(0);
arr; // [0, 1, 2, 3, 4];

delete arr[2];
arr; // [0, 1, undefined, 3, 4]
arr.length; // 5
2 in arr; // false

arr.length -= 1;
arr; // [0, 1, undefined, 3, 4],  4 is removed

arr.pop(); // 3 returned by pop
arr; // [0, 1, undefined], 3 is removed

arr.shift(); // 0 returned by shift
arr; // [1, undefined]
</code></pre><blockquote>
<p>1.向后插入元素 push()</p>
<p>2.向前插入元素 unshift()</p>
<p>3.从后移除元素 pop()</p>
<p>4.从前移除元素 shift()</p>
<p>5.length不固定，可随意更改</p>
<p>6.delete只会删除当前位置的值，长度不会变</p>
</blockquote>
<h3 id="5-数组迭代"><a href="#5-数组迭代" class="headerlink" title="5.数组迭代"></a>5.数组迭代</h3><pre><code>var i = 0, n = 10;
var arr = [1, 2, 3, 4, 5];
for (; i &lt; n; i++) {
    console.log(arr[i]); // 1, 2, 3, 4, 5
}

for(i in arr) {
    console.log(arr[i]); // 1, 2, 3, 4, 5
}

Array.prototype.x = &apos;inherited&apos;;

for(i in arr) {
    console.log(arr[i]); // 1, 2, 3, 4, 5, inherited
}

for(i in arr) {
    if (arr.hasOwnProperty(i)) {
        console.log(arr[i]); // 1, 2, 3, 4, 5
    }
}
</code></pre><blockquote>
<p>for…in  会受原型影响</p>
</blockquote>
<p>##（2）.二维数组、稀疏数组<br>    var arr = [[0, 1], [2, 3], [4, 5]];<br>    var i = 0, j = 0;<br>    var row;<br>    for (; i &lt; arr.length; i++) {<br>         row = arr[i];<br>         console.log(‘row ‘ + i);<br>         for (j = 0; j &lt; row.length; j++) {<br>              console.log(row[j]);<br>         }<br>    }</p>
<pre><code>// result:
// row 0
// 0
// 1
// row 1
// 2
// 3
// row 2
// 4
// 5
</code></pre><p>稀疏数组并不含有从0开始的连续索引。一般length属性值比实际元素个数大。</p>
<pre><code>var arr1 = [undefined];
var arr2 = new Array(1);
0 in arr1; // true
0 in arr2; // false
arr1.length = 100;
arr1[99] = 123;
99 in arr1; // true
98 in arr1; // false

var arr = [,,];
0 in arr; // false
</code></pre><p>##（3）.数组方法</p>
<h3 id="1-Array-prototype-join（将数组转为字符串）"><a href="#1-Array-prototype-join（将数组转为字符串）" class="headerlink" title="1.Array.prototype.join（将数组转为字符串）"></a>1.Array.prototype.join（将数组转为字符串）</h3><pre><code>var arr = [1, 2, 3];
arr.join(); // &quot;1,2,3&quot;
arr.join(&quot;_&quot;); // &quot;1_2_3&quot;

function repeatString(str, n) {
     return new Array(n + 1).join(str);
}
repeatString(&quot;a&quot;, 3); // &quot;aaa&quot;
repeatString(&quot;Hi&quot;, 5); // &quot;HiHiHiHiHi&quot;
</code></pre><h3 id="2-Array-prototype-reverse（将数组逆序）"><a href="#2-Array-prototype-reverse（将数组逆序）" class="headerlink" title="2.Array.prototype.reverse（将数组逆序）"></a>2.Array.prototype.reverse（将数组逆序）</h3><pre><code>var arr = [1, 2, 3];
arr.reverse(); // [3, 2, 1]
arr; // [3, 2, 1]
//原数组被修改
</code></pre><h3 id="3-Array-prototype-sort（排序）"><a href="#3-Array-prototype-sort（排序）" class="headerlink" title="3.Array.prototype.sort（排序）"></a>3.Array.prototype.sort（排序）</h3><pre><code>var arr = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];
arr.sort(); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

arr = [13, 24, 51, 3];
arr.sort(); // [13, 24, 3, 51]
arr; // [13, 24, 3, 51]
//原数组被修改，
</code></pre><p>因为sort是按字母排序的，所以数字排序运用函数</p>
<pre><code>arr.sort(function(a, b) {
     return a - b;
}); // [3, 13, 24, 51]
</code></pre><hr>
<pre><code>arr = [{age : 25}, {age : 39}, {age : 99}];
arr.sort(function(a, b) {
     return a.age - b.age;
});
arr.forEach(function(item) {
     console.log(&apos;age&apos;, item.age);
});
// result:
// age 25
// age 39
// age 99
</code></pre><h3 id="4-Array-prototype-concat（数组合并）"><a href="#4-Array-prototype-concat（数组合并）" class="headerlink" title="4.Array.prototype.concat（数组合并）"></a>4.Array.prototype.concat（数组合并）</h3><pre><code>var arr = [1, 2, 3];
arr.concat(4, 5); // [1, 2, 3, 4, 5]
arr; // [1, 2, 3] 原数组被修改

arr.concat([10, 11], 13); // [1, 2, 3, 10, 11, 13]

arr.concat([1, [2, 3]]); // [1, 2, 3, 1, [2, 3]]
</code></pre><h3 id="5-Array-prototype-slice（返回部分数组）"><a href="#5-Array-prototype-slice（返回部分数组）" class="headerlink" title="5.Array.prototype.slice（返回部分数组）"></a>5.Array.prototype.slice（返回部分数组）</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr.slice(1, 3); // [2, 3]
arr.slice(1); // [2, 3, 4, 5]
arr.slice(1, -1); // [2, 3, 4]
arr.slice(-4, -3); // [2]
//原数组未被修改
</code></pre><h3 id="6-Array-prototype-splice（数组拼接）"><a href="#6-Array-prototype-splice（数组拼接）" class="headerlink" title="6.Array.prototype.splice（数组拼接）"></a>6.Array.prototype.splice（数组拼接）</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr.splice(2); // returns [3, 4, 5]
arr; // [1, 2];

arr = [1, 2, 3, 4, 5];
arr.splice(2, 2); // returns [3, 4] 第二个参数表示截取几个
arr; // [1, 2, 5];

arr = [1, 2, 3, 4, 5];
arr.splice(1, 1, &apos;a&apos;, &apos;b&apos;); // returns [2]
arr; // [1, &quot;a&quot;, &quot;b&quot;, 3, 4, 5]
//原数组被修改
</code></pre><h3 id="7-Array-prototype-forEach（数组遍历）"><a href="#7-Array-prototype-forEach（数组遍历）" class="headerlink" title="7.Array.prototype.forEach（数组遍历）"></a>7.Array.prototype.forEach（数组遍历）</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
    console.log(x + &apos;|&apos; + index + &apos;|&apos; + (a === arr));
});
// 1|0|true
// 2|1|true
// 3|2|true
// 4|3|true
// 5|4|true
</code></pre><h3 id="8-Array-prototype-map（数组映射）"><a href="#8-Array-prototype-map（数组映射）" class="headerlink" title="8.Array.prototype.map（数组映射）"></a>8.Array.prototype.map（数组映射）</h3><pre><code>var arr = [1, 2, 3];
arr.map(function(x) {
     return x + 10;
}); // [11, 12, 13]
arr; // [1, 2, 3]
//原数组未被修改
</code></pre><h3 id="9-Array-prototype-filter（数组过滤）"><a href="#9-Array-prototype-filter（数组过滤）" class="headerlink" title="9.Array.prototype.filter（数组过滤）"></a>9.Array.prototype.filter（数组过滤）</h3><pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.filter(function(x, index) {
     return index % 3 === 0 || x &gt;= 8;
}); // returns [1, 4, 7, 8, 9, 10]
arr; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
//原数组未被修改
</code></pre><h3 id="10-Array-prototype-every-amp-some（数组判断）"><a href="#10-Array-prototype-every-amp-some（数组判断）" class="headerlink" title="10.Array.prototype.every &amp; some（数组判断）"></a>10.Array.prototype.every &amp; some（数组判断）</h3><pre><code>var arr = [1, 2, 3, 4, 5];
arr.every(function(x) {
     return x &lt; 10;
}); // true

arr.every(function(x) {
     return x &lt; 3;
}); // false

var arr = [1, 2, 3, 4, 5];
arr.some(function(x) {
     return x === 3;
}); // true

arr.some(function(x) {
     return x === 100;
}); // false
</code></pre><blockquote>
<p>类似逻辑与、逻辑或</p>
</blockquote>
<h3 id="11-Array-prototype-reduce-amp-reduceRight"><a href="#11-Array-prototype-reduce-amp-reduceRight" class="headerlink" title="11.Array.prototype.reduce&amp;reduceRight"></a>11.Array.prototype.reduce&amp;reduceRight</h3><pre><code>var arr = [1, 2, 3];
var sum = arr.reduce(function(x, y) {
     return x + y
}, 0); // 6
arr; //[1, 2, 3]

arr = [3, 9, 6];
var max = arr.reduce(function(x, y) {
     console.log(x + &quot;|&quot; + y);
     return x &gt; y ? x : y;
});
// 3|9
// 9|6
max; // 9
</code></pre><hr>
<pre><code>max = arr.reduceRight(function(x, y) {
     console.log(x + &quot;|&quot; + y);
     return x &gt; y ? x : y;
});
// 6|9
// 9|3
max; // 9
</code></pre><blockquote>
<p>整个数组聚合成唯一一个结果</p>
</blockquote>
<h3 id="12-Array-prototype-indexOf-amp-lastIndexOf-（数组检索）"><a href="#12-Array-prototype-indexOf-amp-lastIndexOf-（数组检索）" class="headerlink" title="12.Array.prototype.indexOf&amp;lastIndexOf （数组检索）"></a>12.Array.prototype.indexOf&amp;lastIndexOf （数组检索）</h3><pre><code>var arr = [1, 2, 3, 2, 1];
arr.indexOf(2); // 1
arr.indexOf(99); // -1
arr.indexOf(1, 1); // 4
arr.indexOf(1, -3); // 4
arr.indexOf(2, -1); // -1
arr.lastIndexOf(2); // 3
arr.lastIndexOf(2, -2); // 3
arr.lastIndexOf(2, -3); // 1
</code></pre><blockquote>
<p>第一个参数是检索的对象，第二个参数是检索的位置，负数即从后面开始。</p>
</blockquote>
<h3 id="13-Array-isArray（判断是否为数组）"><a href="#13-Array-isArray（判断是否为数组）" class="headerlink" title="13.Array.isArray（判断是否为数组）"></a>13.Array.isArray（判断是否为数组）</h3><pre><code>Array.isArray([]); // true
</code></pre><p>##（4）.数组  VS.  一般对象<br>相同</p>
<p>都可以继承<br>数组是对象，对象不一定是数组<br>都可以当做对象添加删除属性</p>
<p>不同</p>
<p>数组自动更新length<br>按索引访问数组常常比访问一般对象属性明显迅速。<br>数组对象继承Array.prototype上的大量数组操作方法</p>
<h2 id="5-字符串和数组"><a href="#5-字符串和数组" class="headerlink" title="(5).字符串和数组"></a>(5).字符串和数组</h2><pre><code>var str = &quot;hello world&quot;;
str.charAt(0); // &quot;h&quot;
str[1]; // e

Array.prototype.join.call(str, &quot;_&quot;);
// &quot;h_e_l_l_o_ _w_o_r_l_d&quot;
</code></pre><blockquote>
<p><strong>call()和apply()方法</strong></p>
<p>1、方法定义</p>
<p>call方法: </p>
<p>语法：call([thisObj[,arg1[, arg2[,   [,.argN]]]]]) </p>
<p>定义：调用一个对象的一个方法，以另一个对象替换当前对象。 </p>
<p>说明：<br>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。<br>如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </p>
<p>apply方法： </p>
<p>语法：apply([thisObj[,argArray]]) </p>
<p>定义：应用某一对象的一个方法，用另一个对象替换当前对象。 </p>
<p>说明：<br>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。<br>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。</p>
<p>2、常用实例</p>
<p>a、</p>
<pre><code>function add(a,b)  
{  
    alert(a+b);  
}  
function sub(a,b)  
{  
    alert(a-b);  
}  

add.call(sub,3,1);
</code></pre><p>这个例子中的意思就是用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); // 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</p>
<p>b、</p>
<pre><code>function Animal(){    
    this.name = &quot;Animal&quot;;    
    this.showName = function(){    
        alert(this.name);    
    }    
}    

function Cat(){    
    this.name = &quot;Cat&quot;;    
}    

var animal = new Animal();    
var cat = new Cat();    

//通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。    
//输入结果为&quot;Cat&quot;    
animal.showName.call(cat,&quot;,&quot;);    
//animal.showName.apply(cat,[]);  
</code></pre><p>call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name 应该是 Cat</p>
<p>c、实现继承</p>
<pre><code>function Animal(name){      
    this.name = name;      
    this.showName = function(){      
        alert(this.name);      
    }      
}      

function Cat(name){    
    Animal.call(this, name);    
}      

var cat = new Cat(&quot;Black Cat&quot;);     
cat.showName(); 
</code></pre><p> Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么 Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了.</p>
<p>d、多重继承</p>
<pre><code>function Class10()  
{  
    this.showSub = function(a,b)  
    {  
        alert(a-b);  
    }  
}  

function Class11()  
{  
    this.showAdd = function(a,b)  
    {  
        alert(a+b);  
    }  
}  

function Class2()  
{  
    Class10.call(this);  
    Class11.call(this);  
} 
</code></pre><p> 很简单，使用两个 call 就实现多重继承了</p>
<p>说了call ，当然还有 apply，这两个方法基本上是一个意思，区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments<br>还有 callee，caller..</p>
</blockquote>
<h1 id="六-函数"><a href="#六-函数" class="headerlink" title="六.函数"></a>六.函数</h1><p>函数是一块JavaScript代码，被定义一次，但可执行和调用多次。<br>JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递 所以我们也常叫JS中的函数为函数对象。</p>
<h3 id="不同的调用方式"><a href="#不同的调用方式" class="headerlink" title="不同的调用方式"></a>不同的调用方式</h3><p>直接调用<br>foo();</p>
<p>对象方法<br>o.method();</p>
<p>构造器<br>new Foo();</p>
<p>call/apply/bind<br>func.call(o);</p>
<h2 id="2-函数声明和函数表达式"><a href="#2-函数声明和函数表达式" class="headerlink" title="(2).函数声明和函数表达式"></a>(2).函数声明和函数表达式</h2><h3 id="1-函数声明"><a href="#1-函数声明" class="headerlink" title="1.函数声明"></a>1.函数声明</h3><pre><code>function add (a, b) { a = +a;
b = +b;
if (isNaN(a) || isNaN(b)) { return;
}
return a + b;
}
</code></pre><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><pre><code>// function variable
var add = function (a, b) {
// do sth
};

// IEF(Immediately Executed Function)
(function() {
// do sth
})();

// first-class function 
return function() {
// do sth
};

// NFE (Named Function Expression)
//命名函数表达式（有名字的函数表达式） 
var add = function foo (a, b) {
// do sth

};
</code></pre><h3 id="2-变量-amp-函数的声明前置"><a href="#2-变量-amp-函数的声明前置" class="headerlink" title="2.变量&amp;函数的声明前置"></a>2.变量&amp;函数的声明前置</h3><pre><code>//函数声明会前置，即
//function add(a,b) 
var num = add(1, 2);
console.log(num);  //result:3

function add (a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) 
        { return;
    }
    return a + b;
}

//函数表达式中，函数不会前置，可是变量会
//var add 但是它是undefined，没有赋值，只是声明
var num = add(1, 2);
console.log(num);

vaar add = function (a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) 
        { return;
    }
    return a + b;
}
</code></pre><h3 id="3-命名函数表达式"><a href="#3-命名函数表达式" class="headerlink" title="3.命名函数表达式"></a>3.命名函数表达式</h3><pre><code>var func = function nfe() {};
alert(func === nfe);
</code></pre><blockquote>
<p>IE6~8中，会弹出false窗口，即两个不相等，可是外部可以访问nfe;</p>
<p>IE9+中，nfe undefined。即外部不可调用nfe。</p>
<pre><code>// 递归调用
var func = function nfe() {/** do sth.**/ nfe();}
</code></pre></blockquote>
<h3 id="4-Function-构造器"><a href="#4-Function-构造器" class="headerlink" title="4.Function 构造器"></a>4.Function 构造器</h3><pre><code>var func = new Function(&apos;a&apos;, &apos;b&apos;, &apos;console.log(a + b);&apos;);
func(1, 2);    // 3

var func = Function(&apos;a&apos;, &apos;b&apos;, &apos;console.log(a + b);&apos;); func(1, 2);    // 3
</code></pre><hr>
<pre><code>//CASE 1
Function(&apos;var localVal = &quot;local&quot;;
console.log(localVal);&apos;)();
console.log(typeof localVal);
// result: local, undefined
</code></pre><p>localVal仍为局部变量</p>
<pre><code>// CASE 2
var globalVal = &apos;global&apos;;
(function() {
    var localVal = &apos;local&apos;;
    Function(&apos;console.log(typeof localVal, typeof globalVal);&apos;)();
})();
// result: undefined, string
</code></pre><p>local不可访问，全局变量global可以访问</p>
<p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712195942.png" alt=""></p>
<p>##（2）.this</p>
<h3 id="1-全局的this（浏览器）"><a href="#1-全局的this（浏览器）" class="headerlink" title="1.全局的this（浏览器）"></a>1.全局的this（浏览器）</h3><pre><code>console.log(this.document === document); // true
console.log(this === window); // true this.a = 37;
console.log(window.a); // 37
</code></pre><h3 id="2-一般函数的this（浏览器）"><a href="#2-一般函数的this（浏览器）" class="headerlink" title="2.一般函数的this（浏览器）"></a>2.一般函数的this（浏览器）</h3><pre><code>function f1(){ 
    return this;
}

f1() === window; // true, global object

//严格模式的this指向undefined（全局）
function f2(){
    &quot;use strict&quot;; // see strict mode return this;
}

f2() === undefined; // true
</code></pre><h3 id="3-作为对象方法的函数的this"><a href="#3-作为对象方法的函数的this" class="headerlink" title="3.作为对象方法的函数的this"></a>3.作为对象方法的函数的this</h3><pre><code>var o = 
{ prop: 
37,
    f: function() 
    { return 
        this.prop;
    }
};

console.log(o.f()); // logs 37
</code></pre><hr>
<pre><code>var o = {prop: 37};

function independent() 
{ return this.prop;
}

o.f = independent;

console.log(o.f()); // logs 37
</code></pre><h3 id="4-对象原型链上的this"><a href="#4-对象原型链上的this" class="headerlink" title="4.对象原型链上的this"></a>4.对象原型链上的this</h3><pre><code>var o = {f:function(){ return this.a + this.b; }}; 
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5
</code></pre><h3 id="5-get-set方法与this"><a href="#5-get-set方法与this" class="headerlink" title="5.get/set方法与this"></a>5.get/set方法与this</h3><pre><code>function modulus(){
    return Math.sqrt(this.re * this.re + this.im * this.im);
}

var o = 
    { re: 1,
    im: -1,
    get phase(){
        return Math.atan2(this.im, this.re);
    }
};


Object.defineProperty(o, &apos;modulus&apos;, {
get: modulus, enumerable:true, configurable:true});

console.log(o.phase, o.modulus); // logs -0.78 1.4142
</code></pre><p>get,set的this指向它本身的函数</p>
<h3 id="6-构造器中的this"><a href="#6-构造器中的this" class="headerlink" title="6.构造器中的this"></a>6.构造器中的this</h3><pre><code>function MyClass(){
this.a = 37;

}

var o = new    MyClass(); 
console.log(o.a); // 37


function C2(){ 
    this.a = 37; 
    return {a : 38};
}

o = new    C2(); 
console.log(o.a); // 38
</code></pre><h3 id="7-call-apply方法与this"><a href="#7-call-apply方法与this" class="headerlink" title="7.call/apply方法与this"></a>7.call/apply方法与this</h3><pre><code>function add(c, d){
return this.a + this.b + c + d;

}

var o = {a:1, b:3};

add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16

add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 

function bar() {
    console.log(Object.prototype.toString.call(this));

}

bar.call(7); // &quot;[object Number]&quot;
</code></pre><h3 id="8-bind方法与this（IE9-才有"><a href="#8-bind方法与this（IE9-才有" class="headerlink" title="8.bind方法与this（IE9+才有)"></a>8.bind方法与this（IE9+才有)</h3><pre><code>function f(){ 
    return this.a;
}

var g = f.bind({a : &quot;test&quot;}); 
console.log(g()); // test

var o = {a : 37, f : f, g : g};
console.log(o.f(), o.g()); // 37, test
</code></pre><h2 id="（4）-函数属性和arguments"><a href="#（4）-函数属性和arguments" class="headerlink" title="（4）.函数属性和arguments"></a>（4）.函数属性和arguments</h2><pre><code>function foo(x, y, z) {
‘use strict’;
arguments.length; // 2
arguments[0]; // 1

arguments[0] = 10;
x; // change to 10; //绑定关系，严格模式下仍然是1

arguments[2] = 100;
z; // still undefined !! //未传参数失去绑定关系

arguments.callee === foo; // true //严格模式下不能使用
}
</code></pre><h3 id="1-apply-call方法（浏览器）"><a href="#1-apply-call方法（浏览器）" class="headerlink" title="1.apply/call方法（浏览器）"></a>1.apply/call方法（浏览器）</h3><pre><code>function foo(x, y) 
{ 
    console.log(x, y, this);
}

foo.call(100, 1, 2); // 1, 2, Number(100)
foo.apply(true, [3, 4]); // 3, 4, Boolean(true) 
foo.apply(null); // undefined, undefined, window 
foo.apply(undefined); // undefined, undefined, window
</code></pre><hr>
<pre><code>function foo(x, y) {
    &apos;use strict&apos;; 
    console.log(x, y, this);
}

foo.apply(null); //undefined,undefined,null 

foo.apply(undefined); // undefined, undefined, undefined
</code></pre><h3 id="2-bind方法"><a href="#2-bind方法" class="headerlink" title="2.bind方法"></a>2.bind方法</h3><pre><code>this.x = 9;
var module = { 
    x: 81,
    getX: function() { return this.x; }
};

module.getX(); // 81

var getX = module.getX; 
getX(); // 9 指向全局变量

var boundGetX = getX.bind(module); 
boundGetX(); // 81 将这个this指向参数的module
</code></pre><h3 id="3-bind与currying（函数颗粒化，把一个函数拆成多个单元）"><a href="#3-bind与currying（函数颗粒化，把一个函数拆成多个单元）" class="headerlink" title="3.bind与currying（函数颗粒化，把一个函数拆成多个单元）"></a>3.bind与currying（函数颗粒化，把一个函数拆成多个单元）</h3><pre><code>function add(a, b, c) {
    return a + b + c;
}

var func = add.bind(undefined, 100); 
func(1, 2); // 103 
//很多时候，我们不需要传入那么多参数，这里的100，固定赋值给a

var func2 = func.bind(undefined, 200); func2(10); // 310
</code></pre><hr>
<pre><code>function getConfig(colors, size, otherOptions) {
    console.log(colors, size, otherOptions);
}

var defaultConfig = getConfig.bind(null, &quot;#CC0000&quot;, &quot;1024 * 768&quot;); 
defaultConfig(&quot;123&quot;); // #CC0000 1024 * 768 123
defaultConfig(&quot;456&quot;); // #CC0000 1024 * 768 456
</code></pre><h3 id="4-bind-和-new"><a href="#4-bind-和-new" class="headerlink" title="4.bind 和 new"></a>4.bind 和 new</h3><pre><code>function foo() {
    this.b = 100; 
    return this.a;
}

var func = foo.bind({a:1}); 

func(); // 1
new func(); // {b : 100}
</code></pre><p>直接调用foo()的话，this指向全局对象，这里面相对于创建了一个全局变量b，并且赋值为100，返回的是全局变量的a属性</p>
<p>用bind的方法传入一个参数，一个字面量，只有一个属性a，直接调用的话，则this会指向bind的这样的一个参数。</p>
<p>用new的话，return除了是一个对象，否则会以this作为返回值，并且this会被初始化为一个默认的空对象，这个对象的原型是foo.prototype。虽然前面bind了，可是new了之后，会忽略bind，this指向么有bind所指向的。意思是如果用new调用的话，bind的作用会被忽略掉。</p>
<p>##（5）.理解闭包</p>
<p>当一个函数被调用完毕之后，这个局部变量就可以被释放掉了</p>
<p>闭包，以自己的话理解就是，函数被调用完后，局部变量没有被释放。执行上下文仍在栈中，没有出栈。因为下一个执行上下文需要用到。</p>
<h3 id="常见错误之循环闭包"><a href="#常见错误之循环闭包" class="headerlink" title="常见错误之循环闭包"></a>常见错误之循环闭包</h3><pre><code>document.body.innerHTML = &quot;&lt;div  id=div1&gt;aaa&lt;/div&gt;&quot;+ &quot;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;; 

for (var i = 1; i &lt; 4; i++) {
document.getElementById(&apos;div&apos; + i). addEventListener(&apos;click&apos;, function()
 { alert(i); // all are 4!
    });
}
</code></pre><hr>
<pre><code>document.body.innerHTML = &quot;&lt;div  id=div1&gt;aaa&lt;/div&gt;&quot;+ &quot;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;; 

for (var i = 1; i &lt; 4; i++) {
!function(i) 
        { 
            document.getElementById(&apos;div&apos; + i).
            addEventListener(&apos;click&apos;, function() { alert(i); // 1, 2, 3
        });
    }(i);
}
//将每次遍历的1，2，3的值，传到匿名函数（下面那个i），然后在这个匿名函数里面，再用到这个参数i
</code></pre><h3 id="闭包封装"><a href="#闭包封装" class="headerlink" title="闭包封装"></a>闭包封装</h3><pre><code>(function() {
    var _userId = 23492; 
    var _typeId = &apos;item&apos;; 
    var export = {};

    function converter(userId) { 
        return +userId;
    }

    export.getUserId = function() { 
        return converter(_userId);
    }

    export.getTypeId = function() { 
        return _typeId;
    }

    window.export = export;

}());

export.getUserId(); // 23492 
export.getTypeId();    // item

export._userId; // undefined 
export._typeId; // undefined 
export.converter; // undefined
</code></pre><p>函数有函数自己的作用域，里面定义的变量，外部是无法访问的。</p>
<p>我们在函数中定义变量，外部无法用，再用window.export=export这样的方式，把我们最终想输出的对象输出去</p>
<p>外部只能通过export这个对象提供的方法来访问到里面的具体的函数的变量</p>
<p>##（6）.作用域<br>     var a = 10;        全局<br>    (function() {<br>         var b = 20;函数<br>    })();</p>
<pre><code>console.log(a);    // 10
console.log(b);    // error, b in not defined

for (var item in {a : 1, b : 2}) { 
    console.log(item);

}

console.log(item);    // item still in scope

eval(&quot;var a = 1;&quot;); //eval
</code></pre><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><pre><code>function outer2() {
    var local2 = 1; 
    function outer1() {
        var local1 = 1;
        // visit local1, local2 or global3 作用域链从初开始向上找创建该作用域的函数
    }
    outer1();
}
var global3 = 1;
outer2();

function outer() { 
    var i = 1;
    var func = new Function(&quot;console.log(typeof i);&quot;); 
    func();    // undefined}  //Function中的变量外部无法访问
outer();
</code></pre><h3 id="利用函数作用域封装"><a href="#利用函数作用域封装" class="headerlink" title="利用函数作用域封装"></a>利用函数作用域封装</h3><pre><code>(function() {
    // do sth here 
    var a, b;
})();

!function() {
    // do sth here 
    var a, b;
}();
</code></pre><blockquote>
<p>写成函数表达式，为了防止变量被提前声明。留下一堆括号，会报语法错误</p>
</blockquote>
<p>##（7）.ES3执行上下文<br>图文详情参见《js深入了解闭包和原型》</p>
<blockquote>
<p><strong>JS解释器如何找到我们定义的函数和变量？</strong></p>
<p>变量对象(Variable Object, 缩写为VO)是一个抽象 概念中的“对象”，它用于存储执行上下文中的：</p>
<ol>
<li>变量</li>
<li>函数声明</li>
<li>函数参数</li>
</ol>
</blockquote>
<pre><code>var a = 10; 
function test(x) {
    var b = 20;
}
test(30);

VO(globalContext) = { 
    a : 10,
    test : &lt;ref to function&gt;
};
VO(test functionContext) = { 
    x : 30,
    b: 20
};
</code></pre><h3 id="1-变量初始化阶段（对于函数来说）"><a href="#1-变量初始化阶段（对于函数来说）" class="headerlink" title="1.变量初始化阶段（对于函数来说）"></a>1.变量初始化阶段（对于函数来说）</h3><blockquote>
<p><strong>VO按照如下顺序填充:</strong></p>
<ol>
<li><p>函数参数 (若未传⼊入，初始化该参数值为undefined)</p>
</li>
<li><p>函数声明 (若发⽣生命名冲突，会覆盖)</p>
</li>
<li><p>变量声明 (初始化变量值为undefined，若发⽣生命名冲突，会忽略。)</p>
</li>
</ol>
</blockquote>
<pre><code>function test(a, b) {
    var c = 10; function d() {}
    var e = function _e() {}; (function x() {});
    b = 20;
}
test(10);

AO(test) = { 
    a: 10,
    b: undefined, 
    c: undefined,
    d: &lt;ref to func &quot;d&quot;&gt; 
    e: undefined
};
//函数表达式不会影响VO
</code></pre><h3 id="2-代码执行阶段"><a href="#2-代码执行阶段" class="headerlink" title="2.代码执行阶段"></a>2.代码执行阶段</h3><pre><code>function test(a, b) {
    var c = 10; function d() {}
    var e = function _e() {}; (function x() {});
    b = 20;
}
test(10);

AO(test) = { 
    a: 10,
    b: 20,
    c: 10,
    d: &lt;reference to FunctionDeclaration &quot;d&quot;&gt; 
    e: function _e() {};
};
</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>alert(x);    // function

var x = 10; 
alert(x);    // 10
x = 20;

function x() {} 
alert(x);    // 20

if (true) { 
    var a = 1;
} else {
    var b = true;
}

alert(a);    // 1
alert(b);    // undefined
</code></pre><p>首先，vo对象里面，有一个x，值是一个函数对象（函数声明前置），有一个a和b，值是undefined。var x=10：因为变量名和函数名冲突，忽略</p>
<p>然后进入代码执行阶段，var x=10,赋值成功，alert为10；因为b被前置处理，所以alert b不会报错，undefined</p>
<h1 id="七-oop（面向对象程序设计）"><a href="#七-oop（面向对象程序设计）" class="headerlink" title="七.oop（面向对象程序设计）"></a>七.oop（面向对象程序设计）</h1><p>1.继承</p>
<p>2.原型链</p>
<p>3.prototype</p>
<p>4.instanceof</p>
<p>以上《js深入了解闭包和原型》</p>
<p>5.实现继承的方法</p>
<pre><code>Student.prototype = Object.create(Person.prototype)
</code></pre><blockquote>
<p>创建一个空对象，并将其原型指向person.prototype(ES5之后才可以使用）</p>
</blockquote>
<pre><code>if(!Object.create){
    Object.create = function(proto){
        function F(){}
        F.prototype = proto;
        return new F;
    };
}//ES5之前使用方法
</code></pre><h3 id="6-模拟重载"><a href="#6-模拟重载" class="headerlink" title="6.模拟重载"></a>6.模拟重载</h3><p>重载的定义是指函数的方法名相同，但参数不同。比如我写两个关于js的同名函数：</p>
<pre><code>&lt;script type = &quot;text/javascript&quot; &gt;
    function add(a,b){
        var sum = a+b;
        alert (sum);
    }
    add(2,3);

    //第二个函数
    function add(c,d,e){
        var sum2 = c+d+e;
        alert (sum2);
    }
    add(2,3,4);

&lt;/script&gt;
</code></pre><blockquote>
<p>结果为NaN 9 ，这就说明后面的函数把前一个同名函数覆盖掉了，从而可以得出js函数不存在重载，永远调用最后一个方法。</p>
<p>虽说JS函数不存在重载，但是我们可以实现js里面的模拟重载，接下来见证奇迹的时刻到了。要想实现js模拟重载必先回用到 arguments.用来存放js参数。实现方法如下：</p>
</blockquote>
<pre><code>function add1(){
    //比如传递的是两个参数
    if(arguments.length == 2){
        return arguments[0] +arguments[1];
    }else if(arguments.length ==3){
        return arguments[0]+arguments[1]+arguments[2];
    }else if(arguments.length == 4){
        return arguments[0]+arguments[1]+arguments[2]+arguments[3];
    }else{
        return 0 ;
    }
}

    //调用
    alert(add1(1,2));
    alert(add2(1,2,3));
    alert(add3(1,2,3,4));
    alert(add4(1,2,3,4,5));

    结果 3 6 10 0
</code></pre><h3 id="7-调用子类的方法（子掉父）"><a href="#7-调用子类的方法（子掉父）" class="headerlink" title="7.调用子类的方法（子掉父）"></a>7.调用子类的方法（子掉父）</h3><pre><code>function Person(name){
  this.name=name;
}

function Student(name,className){
  this.className=className;
  Person.call(this,name);//调用别的构造器   
}

var mike=new Student(&apos;mike&apos;,&apos;Network3&apos;);

//子类调用已被覆盖的父类的方法
Person.prototype.init=function{
...
}
Student.prototype.inti=function{
  Person.prototype.init.apply(this,arguments);    
}
</code></pre><h3 id="8-链式调用"><a href="#8-链式调用" class="headerlink" title="8.链式调用"></a>8.链式调用</h3><pre><code>function ClassManager(){} //先定义一个构造器
ClassManager.prototype.addClass = function(str){
    console.log(&apos;Class + str + &apos;added&apos;);
    return this;
};

 //然后在ClassMannager构造器上增加addclass方法,需要注意一点，最后return this，this指向classmanager的实例

var manager = new ClassManager();
manager.addClass(&apos;classA&apos;).addClass(&apos;classB&apos;).addClass(&apos;classC&apos;);
//Class:class A added
//Class:class B added
//Class:class C added
</code></pre><h3 id="9-抽象类"><a href="#9-抽象类" class="headerlink" title="9.抽象类**"></a>9.抽象类**</h3><h3 id="9-模块化"><a href="#9-模块化" class="headerlink" title="9.模块化"></a>9.模块化</h3><p>所谓模块化就是将需要用到的方法封装成为一个模块，哪里需要直接调用即可，比如你需要计算1+1和2+2，那么你只需要调用a+b的方法即可，无需反复重写，但是由于js并不支持类的继承，因此如何封装和调用方法就成为js模块化的重要思路。</p>
<blockquote>
<p>最简单的方式</p>
<pre><code>function sum(a,b){
        alert(a+b);
    }
function sub(a,b){
        alert(a-b);
    }
    sum(1,1);
    sum(2,2);
    sub(11,1);
</code></pre><p>上面的sum（），sub（）分别都可以算作是一个模块，需要用的时候直接调用即可，但是这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。比如a，b是全局变量同时方法中需要改变a，b值的时候。</p>
<p>因此大多时候我们都会将其采用对象的写法：</p>
<pre><code>var Sum=new Object({
        a:1,
        b:2,
        sum:function(){
            alert(this.a-this.b);
        }
    });
    Sum.sum();
</code></pre><p> 上面的函数sum()，封装在Sum对象里。使用的时候，就是调用这个对象的属性。</p>
<p>Sum.sum();</p>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写,比如：</p>
<p>sum.a=2;</p>
<p>因此，在这个的基础上，我们可以采用立即执行函数写法：</p>
<pre><code>var Sum=(function(){
       var a=1;
       var b=2;
       var sum=function(){
           alert(a+b);
       };
       var sub=function(){
           alert(a-b);
       };
       return {
           sum:sum,
           sub:sub
       }
   })();
   alert(Sum.a);
   Sum.sum();
</code></pre><p> 第一个输出的Sum.a是undefind，外部是无法获取我们模块内部参数的，但是由于方法我们返回成为一个对象，因此是可以由外部调用的。</p>
<p>同时该模块还可以为其添加新的方法</p>
<pre><code>Sum=(function () {

        m3 = function () {
            alert(&quot;开始计算&quot;);
        };
        return {m3:m3}
    })(Sum);
        Sum.m3();
</code></pre><p>但是注意，这里不能直接调用Sum中的变量a，b，如果需要使用这些参数还需要重新赋予，关于解决方式大家有好的办法欢迎回复。</p>
<p>另外为了避免执行顺序等干扰造成程序报错，在添加方法时也可以写成</p>
</blockquote>
<pre><code>Sum=(function () {

    m3 = function () {
        alert(&quot;im&quot;);
    };
    return {m3:m3}
})(window.Sum || {});
</code></pre><p>这样即使是空对象也可以添加成功。</p>
<h1 id="八-正则与模式匹配"><a href="#八-正则与模式匹配" class="headerlink" title="八.正则与模式匹配"></a>八.正则与模式匹配</h1><h3 id="1-什么是正则？"><a href="#1-什么是正则？" class="headerlink" title="1.什么是正则？"></a>1.什么是正则？</h3><p> 在常见的字符串检索或替换中，我们需要提供一种模式表示检索或替换的规则。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串</p>
<h3 id="2-正则基础"><a href="#2-正则基础" class="headerlink" title="2.正则基础"></a>2.正则基础</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712215823.png" alt=""></p>
<h3 id="3-范围符号"><a href="#3-范围符号" class="headerlink" title="3.范围符号"></a>3.范围符号</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712215946.png" alt=""></p>
<h3 id="4-特殊字符转义"><a href="#4-特殊字符转义" class="headerlink" title="4.特殊字符转义"></a>4.特殊字符转义</h3><pre><code>/\^abc/.test(&apos;^abc&apos;);
</code></pre><h3 id="5-分组"><a href="#5-分组" class="headerlink" title="5.分组"></a>5.分组</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712220152.png" alt=""></p>
<h3 id="6-重复"><a href="#6-重复" class="headerlink" title="6.重复"></a>6.重复</h3><p><img src="http://oncweb6po.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170712220251.png" alt=""></p>
<h3 id="7-三个Flag"><a href="#7-三个Flag" class="headerlink" title="7.三个Flag"></a>7.三个Flag</h3><p>global </p>
<p>ignoreCase </p>
<p>multiline</p>
<pre><code>/abc/gim.test(&quot;ABC&quot;); //true
RegExp(&quot;abc&quot;,&quot;mgi&quot;);
</code></pre><h3 id="8-RegExp-对象属性"><a href="#8-RegExp-对象属性" class="headerlink" title="8.RegExp 对象属性"></a>8.RegExp 对象属性</h3><p>global </p>
<p>ignoreCase </p>
<p>multiline </p>
<p>source</p>
<pre><code>/abc/g.global //true
/abc/g.ignoreCase //false
/abc/g.multiline //false
/abc/g.source //&quot;abc&quot;
</code></pre><h3 id="9-RegExp-对象方法"><a href="#9-RegExp-对象方法" class="headerlink" title="9.RegExp 对象方法"></a>9.RegExp 对象方法</h3><p>complie exec test toString</p>
<pre><code>/abc/.exec(&quot;abcdef&quot;); //&quot;abc&quot;
/abc/.test(&quot;abcde&quot;); //true
/abc/.toString(); //&quot;/abc/&quot;

var reg = /abc/;
reg.compile(&quot;def&quot;);
reg.test(&quot;def&quot;); //true
</code></pre><h3 id="10-string类型与正则相关的方法"><a href="#10-string类型与正则相关的方法" class="headerlink" title="10.string类型与正则相关的方法"></a>10.string类型与正则相关的方法</h3><p>String.prototype.search</p>
<pre><code>&quot;abcabcdef&quot;.search(/(abc)\1); //0
</code></pre><p>String.prototype.replace</p>
<pre><code>&quot;aabbbbcc&quot;.repalce(/b+?/,&quot;1&quot;); //aa1bbbcc
</code></pre><p>String.prototype.match</p>
<pre><code>&quot;aabbbbcc&quot;.match(/b+/); //[&quot;bbbb&quot;]

&quot;aabbbbccbbaa&quot;.match(/b+/g); //[&quot;bbbb&quot;,&quot;bb&quot;]
</code></pre><p>String.prototype.split</p>
<pre><code>&quot;aabbbbccbbaa&quot;.split(/b+/); //[&quot;aa&quot;,&quot;cc&quot;,&quot;aa&quot;]
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag"># js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/18/dom事件探秘/" rel="next" title="dom事件探秘">
                <i class="fa fa-chevron-left"></i> dom事件探秘
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/18/jquery-一-样式篇/" rel="prev" title="jquery(一)样式篇">
                jquery(一)样式篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/person.jpg"
               alt="ZhangWei2222" />
          <p class="site-author-name" itemprop="name">ZhangWei2222</p>
           
              <p class="site-description motion-element" itemprop="description">Dream high</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一-数据类型"><span class="nav-number">1.</span> <span class="nav-text">一.数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原始类型"><span class="nav-number">1.0.1.</span> <span class="nav-text">原始类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object-对象"><span class="nav-number">1.0.2.</span> <span class="nav-text">object 对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-隐式转换"><span class="nav-number">1.1.</span> <span class="nav-text">2.隐式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-b"><span class="nav-number">1.1.1.</span> <span class="nav-text">a===b</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-b-1"><span class="nav-number">1.1.2.</span> <span class="nav-text">a == b</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-包装对象"><span class="nav-number">1.2.</span> <span class="nav-text">3.包装对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-类型检测"><span class="nav-number">1.3.</span> <span class="nav-text">4.类型检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof"><span class="nav-number">1.3.1.</span> <span class="nav-text">typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#obj-instanceof-Object"><span class="nav-number">1.3.2.</span> <span class="nav-text">obj instanceof Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-toString"><span class="nav-number">1.3.3.</span> <span class="nav-text">Object.prototype.toString</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor-NaN"><span class="nav-number">1.3.4.</span> <span class="nav-text">constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#duck-type"><span class="nav-number">1.3.5.</span> <span class="nav-text">duck type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型检测小结"><span class="nav-number">1.4.</span> <span class="nav-text">类型检测小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二-表达式和运算符"><span class="nav-number">2.</span> <span class="nav-text">二.表达式和运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#表达式"><span class="nav-number">2.1.</span> <span class="nav-text">表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-原始表达式"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.原始表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-数组、对象的初始化表达式"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.数组、对象的初始化表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-函数表达式"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-属性访问表达式"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.属性访问表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-调用表达式"><span class="nav-number">2.1.5.</span> <span class="nav-text">5.调用表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-对象创建表达式"><span class="nav-number">2.1.6.</span> <span class="nav-text">6.对象创建表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符"><span class="nav-number">2.2.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-delete-obj-x"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.delete obj.x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-in"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.in</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-instanceof-typeof"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.instanceof, typeof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-new"><span class="nav-number">2.2.4.</span> <span class="nav-text">4.new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-this"><span class="nav-number">2.2.5.</span> <span class="nav-text">5.this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-void"><span class="nav-number">2.2.6.</span> <span class="nav-text">6.void</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三-语句"><span class="nav-number">3.</span> <span class="nav-text">三.语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-block"><span class="nav-number">3.0.1.</span> <span class="nav-text">1.block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-var"><span class="nav-number">3.0.2.</span> <span class="nav-text">2.var</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-try-catch"><span class="nav-number">3.0.3.</span> <span class="nav-text">3.try catch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-function"><span class="nav-number">3.0.4.</span> <span class="nav-text">4.function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-for…in"><span class="nav-number">3.0.5.</span> <span class="nav-text">5.for…in</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-switch"><span class="nav-number">3.0.6.</span> <span class="nav-text">6.switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-循环"><span class="nav-number">3.0.7.</span> <span class="nav-text">7.循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-with"><span class="nav-number">3.0.8.</span> <span class="nav-text">8.with</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#严格模式"><span class="nav-number">3.1.</span> <span class="nav-text">严格模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-不允许用with"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.不允许用with</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-不允许未声明的变量被赋值"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.不允许未声明的变量被赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-arguments变为参数的静态副本"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.arguments变为参数的静态副本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-delete参数、函数名报错"><span class="nav-number">3.1.4.</span> <span class="nav-text">4.delete参数、函数名报错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-delete不可配置的属性报错"><span class="nav-number">3.1.5.</span> <span class="nav-text">5.delete不可配置的属性报错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-对象字面量重复属性名报错"><span class="nav-number">3.1.6.</span> <span class="nav-text">6.对象字面量重复属性名报错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-禁止八进制字面量"><span class="nav-number">3.1.7.</span> <span class="nav-text">7.禁止八进制字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-eval-arguments变为关键字，不能作为变量、函数名"><span class="nav-number">3.1.8.</span> <span class="nav-text">8.eval, arguments变为关键字，不能作为变量、函数名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-eval独立作用域"><span class="nav-number">3.1.9.</span> <span class="nav-text">9.eval独立作用域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四-对象"><span class="nav-number">4.</span> <span class="nav-text">四.对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-创建对象-new-原型链"><span class="nav-number">4.0.1.</span> <span class="nav-text">1.创建对象-new/原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-对象创建-Object-create"><span class="nav-number">4.0.2.</span> <span class="nav-text">2.对象创建-Object.create</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-属性操作"><span class="nav-number">4.1.</span> <span class="nav-text">(2)属性操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-属性读写"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.属性读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-属性读写-异常"><span class="nav-number">4.1.2.</span> <span class="nav-text">2.属性读写-异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-属性删除"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.属性删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-属性检测"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.属性检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-getter-setter方法-另一种读写属性的方式"><span class="nav-number">4.1.5.</span> <span class="nav-text">5.getter setter方法(另一种读写属性的方式)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-属性标签"><span class="nav-number">4.2.</span> <span class="nav-text">(3)属性标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-原型标签-proto"><span class="nav-number">4.2.1.</span> <span class="nav-text">1.原型标签 _proto_</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-class标签"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.class标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展特性"><span class="nav-number">4.2.3.</span> <span class="nav-text">扩展特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#密封特性"><span class="nav-number">4.2.4.</span> <span class="nav-text">密封特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冻结特性"><span class="nav-number">4.2.5.</span> <span class="nav-text">冻结特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-序列化"><span class="nav-number">4.3.</span> <span class="nav-text">(5).序列化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五-数组"><span class="nav-number">5.</span> <span class="nav-text">五.数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-创建数组-字面量"><span class="nav-number">5.0.1.</span> <span class="nav-text">1.创建数组-字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-创建数组-new-Array"><span class="nav-number">5.0.2.</span> <span class="nav-text">2.创建数组-new Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-数组元素读写"><span class="nav-number">5.0.3.</span> <span class="nav-text">3.数组元素读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-数组元素增删（动态的，无需指定大小）"><span class="nav-number">5.0.4.</span> <span class="nav-text">4.数组元素增删（动态的，无需指定大小）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-数组迭代"><span class="nav-number">5.0.5.</span> <span class="nav-text">5.数组迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Array-prototype-join（将数组转为字符串）"><span class="nav-number">5.0.6.</span> <span class="nav-text">1.Array.prototype.join（将数组转为字符串）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Array-prototype-reverse（将数组逆序）"><span class="nav-number">5.0.7.</span> <span class="nav-text">2.Array.prototype.reverse（将数组逆序）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Array-prototype-sort（排序）"><span class="nav-number">5.0.8.</span> <span class="nav-text">3.Array.prototype.sort（排序）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Array-prototype-concat（数组合并）"><span class="nav-number">5.0.9.</span> <span class="nav-text">4.Array.prototype.concat（数组合并）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Array-prototype-slice（返回部分数组）"><span class="nav-number">5.0.10.</span> <span class="nav-text">5.Array.prototype.slice（返回部分数组）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Array-prototype-splice（数组拼接）"><span class="nav-number">5.0.11.</span> <span class="nav-text">6.Array.prototype.splice（数组拼接）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Array-prototype-forEach（数组遍历）"><span class="nav-number">5.0.12.</span> <span class="nav-text">7.Array.prototype.forEach（数组遍历）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Array-prototype-map（数组映射）"><span class="nav-number">5.0.13.</span> <span class="nav-text">8.Array.prototype.map（数组映射）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Array-prototype-filter（数组过滤）"><span class="nav-number">5.0.14.</span> <span class="nav-text">9.Array.prototype.filter（数组过滤）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Array-prototype-every-amp-some（数组判断）"><span class="nav-number">5.0.15.</span> <span class="nav-text">10.Array.prototype.every & some（数组判断）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Array-prototype-reduce-amp-reduceRight"><span class="nav-number">5.0.16.</span> <span class="nav-text">11.Array.prototype.reduce&reduceRight</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Array-prototype-indexOf-amp-lastIndexOf-（数组检索）"><span class="nav-number">5.0.17.</span> <span class="nav-text">12.Array.prototype.indexOf&lastIndexOf （数组检索）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Array-isArray（判断是否为数组）"><span class="nav-number">5.0.18.</span> <span class="nav-text">13.Array.isArray（判断是否为数组）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-字符串和数组"><span class="nav-number">5.1.</span> <span class="nav-text">(5).字符串和数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六-函数"><span class="nav-number">6.</span> <span class="nav-text">六.函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不同的调用方式"><span class="nav-number">6.0.1.</span> <span class="nav-text">不同的调用方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-函数声明和函数表达式"><span class="nav-number">6.1.</span> <span class="nav-text">(2).函数声明和函数表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-函数声明"><span class="nav-number">6.1.1.</span> <span class="nav-text">1.函数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数表达式"><span class="nav-number">6.1.2.</span> <span class="nav-text">函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-变量-amp-函数的声明前置"><span class="nav-number">6.1.3.</span> <span class="nav-text">2.变量&函数的声明前置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-命名函数表达式"><span class="nav-number">6.1.4.</span> <span class="nav-text">3.命名函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Function-构造器"><span class="nav-number">6.1.5.</span> <span class="nav-text">4.Function 构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-全局的this（浏览器）"><span class="nav-number">6.1.6.</span> <span class="nav-text">1.全局的this（浏览器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-一般函数的this（浏览器）"><span class="nav-number">6.1.7.</span> <span class="nav-text">2.一般函数的this（浏览器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-作为对象方法的函数的this"><span class="nav-number">6.1.8.</span> <span class="nav-text">3.作为对象方法的函数的this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-对象原型链上的this"><span class="nav-number">6.1.9.</span> <span class="nav-text">4.对象原型链上的this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-get-set方法与this"><span class="nav-number">6.1.10.</span> <span class="nav-text">5.get/set方法与this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-构造器中的this"><span class="nav-number">6.1.11.</span> <span class="nav-text">6.构造器中的this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-call-apply方法与this"><span class="nav-number">6.1.12.</span> <span class="nav-text">7.call/apply方法与this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-bind方法与this（IE9-才有"><span class="nav-number">6.1.13.</span> <span class="nav-text">8.bind方法与this（IE9+才有)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（4）-函数属性和arguments"><span class="nav-number">6.2.</span> <span class="nav-text">（4）.函数属性和arguments</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-apply-call方法（浏览器）"><span class="nav-number">6.2.1.</span> <span class="nav-text">1.apply/call方法（浏览器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-bind方法"><span class="nav-number">6.2.2.</span> <span class="nav-text">2.bind方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-bind与currying（函数颗粒化，把一个函数拆成多个单元）"><span class="nav-number">6.2.3.</span> <span class="nav-text">3.bind与currying（函数颗粒化，把一个函数拆成多个单元）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-bind-和-new"><span class="nav-number">6.2.4.</span> <span class="nav-text">4.bind 和 new</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见错误之循环闭包"><span class="nav-number">6.2.5.</span> <span class="nav-text">常见错误之循环闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包封装"><span class="nav-number">6.2.6.</span> <span class="nav-text">闭包封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域链"><span class="nav-number">6.2.7.</span> <span class="nav-text">作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用函数作用域封装"><span class="nav-number">6.2.8.</span> <span class="nav-text">利用函数作用域封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-变量初始化阶段（对于函数来说）"><span class="nav-number">6.2.9.</span> <span class="nav-text">1.变量初始化阶段（对于函数来说）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-代码执行阶段"><span class="nav-number">6.2.10.</span> <span class="nav-text">2.代码执行阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试"><span class="nav-number">6.2.11.</span> <span class="nav-text">测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七-oop（面向对象程序设计）"><span class="nav-number">7.</span> <span class="nav-text">七.oop（面向对象程序设计）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-模拟重载"><span class="nav-number">7.0.1.</span> <span class="nav-text">6.模拟重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-调用子类的方法（子掉父）"><span class="nav-number">7.0.2.</span> <span class="nav-text">7.调用子类的方法（子掉父）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-链式调用"><span class="nav-number">7.0.3.</span> <span class="nav-text">8.链式调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-抽象类"><span class="nav-number">7.0.4.</span> <span class="nav-text">9.抽象类**</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-模块化"><span class="nav-number">7.0.5.</span> <span class="nav-text">9.模块化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八-正则与模式匹配"><span class="nav-number">8.</span> <span class="nav-text">八.正则与模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-什么是正则？"><span class="nav-number">8.0.1.</span> <span class="nav-text">1.什么是正则？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-正则基础"><span class="nav-number">8.0.2.</span> <span class="nav-text">2.正则基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-范围符号"><span class="nav-number">8.0.3.</span> <span class="nav-text">3.范围符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-特殊字符转义"><span class="nav-number">8.0.4.</span> <span class="nav-text">4.特殊字符转义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-分组"><span class="nav-number">8.0.5.</span> <span class="nav-text">5.分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-重复"><span class="nav-number">8.0.6.</span> <span class="nav-text">6.重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-三个Flag"><span class="nav-number">8.0.7.</span> <span class="nav-text">7.三个Flag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-RegExp-对象属性"><span class="nav-number">8.0.8.</span> <span class="nav-text">8.RegExp 对象属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-RegExp-对象方法"><span class="nav-number">8.0.9.</span> <span class="nav-text">9.RegExp 对象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-string类型与正则相关的方法"><span class="nav-number">8.0.10.</span> <span class="nav-text">10.string类型与正则相关的方法</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhangWei2222</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
